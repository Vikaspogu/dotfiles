Time	Sum	Command
1113	19541	> builtin source /usr/local/Cellar/fish/3.1.2/share/fish/config.fish
66	66	-> set -g IFS \n\ \t
28	28	-> set -qg __fish_added_user_paths
27	27	-> set -g __fish_added_user_paths
6	30	-> if not set -q __fish_initialized
    set -U __fish_initialized 0
    if set -q __fish_init_2_39_8
        set __fish_initialized 2398
    else if set -q __fish_init_2_3_0
        set __fish_initialized 2300
    end
...
24	24	--> not set -q __fish_initialized
15	15	-> function __fish_default_command_not_found_handler
    printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
...
7	254	-> if status --is-interactive
    # Enable truecolor/24-bit support for select terminals
    # Ignore Screen and emacs' ansi-term as they swallow the sequences, rendering the text white.
    if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    end
else
    # Hook up the default as the principal command_not_found handler
    # in case we are not interactive
    function __fish_command_not_found_handler --on-event fish_command_not_found
        __fish_default_command_not_found_handler $argv
    end
...
28	28	--> status --is-interactive
15	219	--> if not set -q STY
        and not string match -q -- 'eterm*' $TERM
        and begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        end
        # Only set it if it isn't to allow override by setting to 0
        set -q fish_term24bit
        or set -g fish_term24bit 1
    ...
25	25	---> not set -q STY
57	57	---> not string match -q -- 'eterm*' $TERM
10	68	---> begin
            set -q KONSOLE_PROFILE_NAME # KDE's konsole
            or string match -q -- "*:*" $ITERM_SESSION_ID # Supporting versions of iTerm2 will include a colon here
            or string match -q -- "st-*" $TERM # suckless' st
            or test -n "$VTE_VERSION" -a "$VTE_VERSION" -ge 3600 # Should be all gtk3-vte-based terms after version 3.6.0.0
            or test "$COLORTERM" = truecolor -o "$COLORTERM" = 24bit # slang expects this
        ...
24	24	----> set -q KONSOLE_PROFILE_NAME
34	34	----> string match -q -- "*:*" $ITERM_SESSION_ID
24	24	---> set -q fish_term24bit
30	30	---> set -g fish_term24bit 1
27	27	-> set -l __extra_completionsdir
26	26	-> set -l __extra_functionsdir
26	26	-> set -l __extra_confdir
10	288	-> if test -f $__fish_data_dir/__fish_build_paths.fish
    source $__fish_data_dir/__fish_build_paths.fish
...
68	68	--> test -f $__fish_data_dir/__fish_build_paths.fish
120	210	--> source $__fish_data_dir/__fish_build_paths.fish
36	36	---> set __extra_completionsdir /usr/local/share/fish/vendor_completions.d
27	27	---> set __extra_functionsdir /usr/local/share/fish/vendor_functions.d
27	27	---> set __extra_confdir /usr/local/share/fish/vendor_conf.d
27	27	-> set -l xdg_data_dirs
9	64	-> if set -q XDG_DATA_DIRS
    set --path xdg_data_dirs $XDG_DATA_DIRS
    set xdg_data_dirs (string replace -r '([^/])/$' '$1' -- $xdg_data_dirs)/fish
else
    set xdg_data_dirs $__fish_data_dir
...
24	24	--> set -q XDG_DATA_DIRS
31	31	--> set xdg_data_dirs $__fish_data_dir
32	32	-> set -l vendor_completionsdirs $xdg_data_dirs/vendor_completions.d
31	31	-> set -l vendor_functionsdirs $xdg_data_dirs/vendor_functions.d
31	31	-> set -l vendor_confdirs $xdg_data_dirs/vendor_conf.d
9	84	-> if not contains -- $__extra_completionsdir $vendor_completionsdirs
    set -a vendor_completionsdirs $__extra_completionsdir
...
42	42	--> not contains -- $__extra_completionsdir $vendor_completionsdirs
33	33	--> set -a vendor_completionsdirs $__extra_completionsdir
16	83	-> if not contains -- $__extra_functionsdir $vendor_functionsdirs
    set -a vendor_functionsdirs $__extra_functionsdir
...
33	33	--> not contains -- $__extra_functionsdir $vendor_functionsdirs
34	34	--> set -a vendor_functionsdirs $__extra_functionsdir
7	71	-> if not contains -- $__extra_confdir $vendor_confdirs
    set -a vendor_confdirs $__extra_confdir
...
32	32	--> not contains -- $__extra_confdir $vendor_confdirs
32	32	--> set -a vendor_confdirs $__extra_confdir
7	80	-> if not set -q fish_function_path
    set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
else if not contains -- $__fish_data_dir/functions $fish_function_path
    set -a fish_function_path $__fish_data_dir/functions
...
25	25	--> not set -q fish_function_path
48	48	--> set fish_function_path $__fish_config_dir/functions $__fish_sysconf_dir/functions $vendor_functionsdirs $__fish_data_dir/functions
8	105	-> if not set -q fish_complete_path
    set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
else if not contains -- $__fish_data_dir/completions $fish_complete_path
    set -a fish_complete_path $__fish_data_dir/completions
...
25	25	--> not set -q fish_complete_path
72	72	--> set fish_complete_path $__fish_config_dir/completions $__fish_sysconf_dir/completions $vendor_completionsdirs $__fish_data_dir/completions $__fish_user_data_dir/generated_completions
9	9	-> function : -d "no-op function"
    # for compatibility with sh, bash, and others.
    # Often used to insert a comment into a chain of commands without having
    # it eat up the remainder of the line, handy in Makefiles.
    # This command always succeeds
    true
...
2	164	-> if begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; end
    not contains -- /usr/xpg4/bin $PATH
    and set PATH /usr/xpg4/bin $PATH
...
13	162	--> begin; not set -q FISH_UNIT_TESTS_RUNNING; and test -d /usr/xpg4/bin; ...
104	104	---> not set -q FISH_UNIT_TESTS_RUNNING
45	45	---> test -d /usr/xpg4/bin
16	16	-> function __fish_reconstruct_path -d "Update PATH when fish_user_paths changes" --on-variable fish_user_paths
    set -l local_path $PATH

    for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    end

    set -g __fish_added_user_paths
    if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    end

    set -xg PATH $local_path
...
30	30	-> function fish_sigtrap_handler --on-signal TRAP --no-scope-shadowing --description "Signal handler for the TRAP signal. Launches a debug prompt."
    breakpoint
...
8	8	-> function __fish_on_interactive --on-event fish_prompt
    __fish_config_interactive
    functions -e __fish_on_interactive
...
268	1039	-> __fish_set_locale
439	449	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_set_locale.fish
10	10	---> function __fish_set_locale
    set -l LOCALE_VARS
    set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
    set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
    set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION

    # We check LC_ALL to figure out if we have a locale but we don't set it later. That is because
    # locale.conf doesn't allow it so we should not set it.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end

    # Try to extract the locale from the kernel boot commandline. The splitting here is a bit weird,
    # but we operate under the assumption that the locale can't include whitespace. Other whitespace
    # shouldn't concern us, but a quoted "locale.LANG=SOMETHING" as a value to something else might.
    # Here the last definition of a variable takes precedence.
    if test -r /proc/cmdline
        for var in (string match -ra 'locale.[^=]+=\S+' < /proc/cmdline)
            set -l kv (string replace 'locale.' '' -- $var | string split '=')
            # Only set locale variables, not other stuff contained in these files - this also
            # automatically ignores comments.
            if contains -- $kv[1] $LOCALE_VARS
                and set -q kv[2]
                set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
            end
        end
    end

    # Now read the config files we know are used by various OS distros.
    #
    # /etc/sysconfig/i18n is for old Red Hat derivatives (and possibly of no use anymore).
    #
    # /etc/env.d/02locale is from OpenRC.
    #
    # The rest are systemd inventions but also used elsewhere (e.g. Void Linux). systemd's
    # documentation is a bit unclear on this. We merge all the config files (and the commandline),
    # which seems to be what systemd itself does. (I.e. the value for a variable will be taken from
    # the highest-precedence source) We read the systemd files first since they are a newer
    # invention and therefore the rest are likely to be accumulated cruft.
    #
    # NOTE: Slackware puts the locale in /etc/profile.d/lang.sh, which we can't use because it's a
    # full POSIX-shell script.
    set -l user_cfg_dir (set -q XDG_CONFIG_HOME; and echo $XDG_CONFIG_HOME; or echo ~/.config)
    for f in $user_cfg_dir/locale.conf /etc/locale.conf /etc/env.d/02locale /etc/sysconfig/i18n
        if test -r $f
            while read -l kv
                set kv (string split '=' -- $kv)
                if contains -- $kv[1] $LOCALE_VARS
                    and set -q kv[2]
                    # Do not set already set variables again - this makes the merging happen.
                    if not set -q $kv[1]
                        set -gx $kv[1] (string trim -c '\'"' -- $kv[2])
                    end
                end
            end <$f
        end
    end

    # If we really cannot get anything, at least set character encoding to UTF-8.
    for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    end
    set -gx LC_CTYPE en_US.UTF-8
...
35	35	--> set -l LOCALE_VARS
34	34	--> set -a LOCALE_VARS LANG LANGUAGE LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE
35	35	--> set -a LOCALE_VARS LC_MONETARY LC_MESSAGES LC_PAPER LC_NAME LC_ADDRESS
34	34	--> set -a LOCALE_VARS LC_TELEPHONE LC_MEASUREMENT LC_IDENTIFICATION
45	184	--> for locale_var in $LOCALE_VARS LC_ALL
        if set -q $locale_var
            return 0
        end
    ...
6	36	---> if set -q $locale_var
            return 0
        ...
30	30	----> set -q $locale_var
4	32	---> if set -q $locale_var
            return 0
        ...
28	28	----> set -q $locale_var
11	71	---> if set -q $locale_var
            return 0
        ...
29	29	----> set -q $locale_var
31	31	----> return 0
15	15	-> function . -d 'Evaluate a file (deprecated, use "source")' --no-scope-shadowing --wraps source
    if [ (count $argv) -eq 0 ] && isatty 0
        echo "source: using source via '.' is deprecated, and stdin doesn't work."\n"Did you mean 'source' or './'?" >&2
        return 1
    else
        source $argv
    end
...
5	45	-> if test $__fish_initialized -lt 2300
    if set -q fish_user_abbreviations
        set -l fab
        for abbr in $fish_user_abbreviations
            set -a fab (string replace -r '^([^ =]+)=(.*)$' '$1 $2' -- $abbr)
        end
        set fish_user_abbreviations $fab
    end
...
40	40	--> test $__fish_initialized -lt 2300
5	31	-> if status --is-login
    if command -sq /usr/libexec/path_helper
        # Adapt construct_path from the macOS /usr/libexec/path_helper
        # executable for fish; see
        # https://opensource.apple.com/source/shell_cmds/shell_cmds-203/path_helper/path_helper.c.auto.html .
        function __fish_macos_set_env -d "set an environment variable like path_helper does (macOS only)"
            set -l result

            # Populate path according to config files
            for path_file in $argv[2] $argv[3]/*
                if [ -f $path_file ]
                    while read -l entry
                        if not contains -- $entry $result
                            test -n "$entry"
                            and set -a result $entry
                        end
                    end <$path_file
                end
            end

            # Merge in any existing path elements
            for existing_entry in $$argv[1]
                if not contains -- $existing_entry $result
                    set -a result $existing_entry
                end
            end

            set -xg $argv[1] $result
        end

        __fish_macos_set_env 'PATH' '/etc/paths' '/etc/paths.d'
        if [ -n "$MANPATH" ]
            __fish_macos_set_env 'MANPATH' '/etc/manpaths' '/etc/manpaths.d'
        end
        functions -e __fish_macos_set_env
    end

    #
    # Put linux consoles in unicode mode.
    #
    if test "$TERM" = linux
        and string match -qir '\.UTF' -- $LANG
        and command -sq unicode_start
        unicode_start
    end
...
26	26	--> status --is-login
49	1321	-> __fish_reconstruct_path
52	52	--> set -l local_path $PATH
17	17	--> for x in $__fish_added_user_paths
        set -l idx (contains --index -- $x $local_path)
        and set -e local_path[$idx]
    ...
28	28	--> set -g __fish_added_user_paths
11	1057	--> if set -q fish_user_paths
        # Explicitly split on ":" because $fish_user_paths might not be a path variable,
        # but $PATH definitely is.
        for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        end
    ...
25	25	---> set -q fish_user_paths
153	1021	---> for x in (string split ":" -- $fish_user_paths[-1..1])
            if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            end
            set -p local_path $x
        ...
139	139	----> string split ":" -- $fish_user_paths[-1..1]
52	393	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
118	288	-----> set -l idx (contains --index -- $x $local_path)
170	170	------> contains --index -- $x $local_path
53	53	-----> set -e local_path[$idx]
74	74	----> set -p local_path $x
11	221	----> if set -l idx (contains --index -- $x $local_path)
                set -e local_path[$idx]
            else
                set -ga __fish_added_user_paths $x
            ...
96	163	-----> set -l idx (contains --index -- $x $local_path)
67	67	------> contains --index -- $x $local_path
47	47	-----> set -e local_path[$idx]
41	41	----> set -p local_path $x
118	118	--> set -xg PATH $local_path
12	12	-> function __fish_expand_pid_args
    for arg in $argv
        if string match -qr '^%\d+$' -- $arg
            # set newargv $newargv (jobs -p $arg)
            jobs -p $arg
            if not test $status -eq 0
                return 1
            end
        else
            printf "%s\n" $arg
        end
    end
...
39	93	-> for jobbltn in bg fg wait disown
    function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    end
...
15	15	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
13	13	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
12	12	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
14	14	--> function $jobbltn -V jobbltn
        builtin $jobbltn (__fish_expand_pid_args $argv)
    ...
6	6	-> function kill
    command kill (__fish_expand_pid_args $argv)
...
60	60	-> set -l sourcelist
676	14184	-> for file in $__fish_config_dir/conf.d/*.fish $__fish_sysconf_dir/conf.d/*.fish $vendor_confdirs/*.fish
    set -l basename (string replace -r '^.*/' '' -- $file)
    contains -- $basename $sourcelist
    and continue
    set sourcelist $sourcelist $basename
    # Also skip non-files or unreadable files.
    # This allows one to use e.g. symlinks to /dev/null to "mask" something (like in systemd).
    [ -f $file -a -r $file ]
    and source $file
...
269	461	--> set -l basename (string replace -r '^.*/' '' -- $file)
192	192	---> string replace -r '^.*/' '' -- $file
41	41	--> contains -- $basename $sourcelist
34	34	--> set sourcelist $sourcelist $basename
69	69	--> [ -f $file -a -r $file ]
164	174	--> source $file
10	10	---> function _nvm_uninstall -e nvm_uninstall
    if test -s "$nvm_config/version"
        read -l ver <$nvm_config/version
        if set -l i (contains -i -- "$nvm_config/$ver/bin" $fish_user_paths)
            set -e fish_user_paths[$i]
        end
        command rm -f $nvm_config/version
    end

    for name in (set -n | command awk '/^nvm_/')
        set -e "$name"
    end

    functions -e (functions -a | command awk '/^_nvm_/')
...
86	138	--> set -l basename (string replace -r '^.*/' '' -- $file)
52	52	---> string replace -r '^.*/' '' -- $file
36	36	--> contains -- $basename $sourcelist
34	34	--> set sourcelist $sourcelist $basename
65	65	--> [ -f $file -a -r $file ]
106	12456	--> source $file
30	30	---> set -q XDG_DATA_HOME
36	36	---> set -gx OMF_PATH "$HOME/.local/share/omf"
344	12284	---> source $OMF_PATH/init.fish
8	39	----> if not set -q OMF_CONFIG
  set -q XDG_CONFIG_HOME; or set -l XDG_CONFIG_HOME "$HOME/.config"
  set -gx OMF_CONFIG "$XDG_CONFIG_HOME/omf"
...
31	31	-----> not set -q OMF_CONFIG
42	42	----> test -f $OMF_CONFIG/before.init.fish
82	82	----> emit perf:timer:start "Oh My Fish initialisation"
38	38	----> test -f $OMF_CONFIG/theme
83	83	----> read -l theme < $OMF_CONFIG/theme
42	42	----> set -l core_function_path $OMF_PATH/lib{,/git}
616	616	----> set -l theme_function_path {$OMF_CONFIG,$OMF_PATH}/themes*/$theme{,/functions}
65	65	----> set fish_function_path $fish_function_path[1] \
                       $core_function_path \
                       $theme_function_path \
                       $fish_function_path[2..-1]
98	98	----> emit perf:timer:start "Oh My Fish init installed packages"
338	8253	----> require --path {$OMF_PATH,$OMF_CONFIG}/pkg/*
431	441	-----> source /Users/tkg/.local/share/omf/lib/require.fish
10	10	------> function require
  set packages $argv

  if test -z "$packages"
    echo 'usage: require <name>...'
    echo '       require --path <path>...'
    echo '       require --no-bundle --path <path>...'
    return 1
  end

  # If bundle should be
  if set index (contains -i -- --no-bundle $packages)
    set -e packages[$index]
    set ignore_bundle
  end

  # Requiring absolute paths
  if set index (contains -i -- --path $packages)
    set -e packages[$index]
    set package_path $packages

  # Requiring specific packages from default paths
  else
    set package_path {$OMF_PATH,$OMF_CONFIG}/pkg*/$packages

    # Exit with error if no package paths were generated
    test -z "$package_path"
      and return 1
  end

  set function_path $package_path/functions*
  set complete_path $package_path/completions*
  set init_path $package_path/init.fish*
  set conf_path $package_path/conf.d/*.fish

  # Autoload functions
  test -n "$function_path"
    and set fish_function_path $fish_function_path[1] \
                               $function_path \
                               $fish_function_path[2..-1]

  # Autoload completions
  test -n "$complete_path"
    and set fish_complete_path $fish_complete_path[1] \
                               $complete_path \
                               $fish_complete_path[2..-1]

  for init in $init_path
    emit perf:timer:start $init
    set -l IFS '/'
    echo $init | read -la components

    set path (printf '/%s' $components[1..-2])

    contains $path $omf_init_path
      and continue

    set package $components[-2]

    if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    end

    source $init $path

    emit init_$package $path

    set -g omf_init_path $omf_init_path $path
    emit perf:timer:finish $init
  end

  for conf in $conf_path
    source $conf
  end

  return 0
...
44	44	-----> set packages $argv
5	39	-----> if test -z "$packages"
    echo 'usage: require <name>...'
    echo '       require --path <path>...'
    echo '       require --no-bundle --path <path>...'
    return 1
  ...
34	34	------> test -z "$packages"
6	212	-----> if set index (contains -i -- --no-bundle $packages)
    set -e packages[$index]
    set ignore_bundle
  ...
97	206	------> set index (contains -i -- --no-bundle $packages)
109	109	-------> contains -i -- --no-bundle $packages
12	229	-----> if set index (contains -i -- --path $packages)
    set -e packages[$index]
    set package_path $packages

  # Requiring specific packages from default paths
  else
    set package_path {$OMF_PATH,$OMF_CONFIG}/pkg*/$packages

    # Exit with error if no package paths were generated
    test -z "$package_path"
      and return 1
  ...
89	143	------> set index (contains -i -- --path $packages)
54	54	-------> contains -i -- --path $packages
38	38	------> set -e packages[$index]
36	36	------> set package_path $packages
472	472	-----> set function_path $package_path/functions*
249	249	-----> set complete_path $package_path/completions*
253	253	-----> set init_path $package_path/init.fish*
251	251	-----> set conf_path $package_path/conf.d/*.fish
34	34	-----> test -n "$function_path"
70	70	-----> set fish_function_path $fish_function_path[1] \
                               $function_path \
                               $fish_function_path[2..-1]
34	34	-----> test -n "$complete_path"
56	56	-----> set fish_complete_path $fish_complete_path[1] \
                               $complete_path \
                               $fish_complete_path[2..-1]
54	5496	-----> for init in $init_path
    emit perf:timer:start $init
    set -l IFS '/'
    echo $init | read -la components

    set path (printf '/%s' $components[1..-2])

    contains $path $omf_init_path
      and continue

    set package $components[-2]

    if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    end

    source $init $path

    emit init_$package $path

    set -g omf_init_path $omf_init_path $path
    emit perf:timer:finish $init
  ...
122	122	------> emit perf:timer:start $init
29	29	------> set -l IFS '/'
208	208	------> echo $init | read -la components
97	249	------> set path (printf '/%s' $components[1..-2])
152	152	-------> printf '/%s' $components[1..-2]
105	105	------> contains $path $omf_init_path
33	33	------> set package $components[-2]
22	150	------> if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    ...
26	26	-------> not set -q ignore_bundle
34	34	-------> set bundle $path/bundle
27	27	-------> set dependencies
5	41	-------> if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      ...
36	36	--------> test -f $bundle
233	4321	------> source $init $path
36	36	-------> set -g OMF_MISSING_ARG   1
29	29	-------> set -g OMF_UNKNOWN_OPT   2
27	27	-------> set -g OMF_INVALID_ARG   3
26	26	-------> set -g OMF_UNKNOWN_ERR   4
7	7	-------> function omf::em
  set_color cyan 2> /dev/null
...
4	4	-------> function omf::dim
  set_color 555 2> /dev/null
...
3	3	-------> function omf::err
  set_color red --bold 2> /dev/null
...
4	4	-------> function omf::under
  set_color --underline 2> /dev/null
...
4	4	-------> function omf::off
  set_color normal 2> /dev/null
...
153	3948	-------> autoload $path/functions/{compat,core,index,packages,themes,bundle,util,repo,cli,search}
317	333	--------> source /Users/tkg/.local/share/omf/lib/autoload.fish
7	7	---------> function autoload
  switch "$argv[1]"
  case '-e' '--erase'
    test (count $argv) -ge 2
      and __autoload_erase $argv[2..-1]
      or echo "usage: autoload $argv[1] <path>..." >&2
  case "-*" "--*"
    echo "autoload: invalid option $argv[1]"
    return 1
  case '*'
    test (count $argv) -ge 1
      and __autoload_insert $argv
      or echo "usage: autoload <path>..." >&2
  end
...
5	5	---------> function __autoload_insert
  set -l function_path
  set -l complete_path
  for path in $argv
    not test -d "$path"; and continue
    set -l IFS '/'
    echo $path | read -la components
    if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    end;
  end;
  test -n "$function_path"
    and set fish_function_path $fish_function_path[1] $function_path $fish_function_path[2..-1]
  test -n "$complete_path"
    and set fish_complete_path $fish_complete_path[1] $complete_path $fish_complete_path[2..-1]
  return 0
...
4	4	---------> function __autoload_erase
  set -l function_indexes
  set -l complete_indexes
  for path in $argv
    set -l IFS '/'
    echo $path | read -la components
    test "x$components[-1]" = xcompletions
      and set complete_indexes $complete_indexes (contains -i $path $fish_complete_path)
      or  set function_indexes $function_indexes (contains -i $path $fish_function_path)
  end;
  test -n "$function_indexes"
    and set -e fish_function_path["$function_indexes"]
  test -n "$complete_indexes"
    and set -e fish_complete_path["$complete_indexes"]
  return 0
...
26	3462	--------> switch "$argv[1]"
  case '-e' '--erase'
    test (count $argv) -ge 2
      and __autoload_erase $argv[2..-1]
      or echo "usage: autoload $argv[1] <path>..." >&2
  case "-*" "--*"
    echo "autoload: invalid option $argv[1]"
    return 1
  case '*'
    test (count $argv) -ge 1
      and __autoload_insert $argv
      or echo "usage: autoload <path>..." >&2
  ...
71	198	---------> test (count $argv) -ge 1
127	127	----------> count $argv
75	3238	---------> __autoload_insert $argv
31	31	----------> set -l function_path
26	26	----------> set -l complete_path
147	2939	----------> for path in $argv
    not test -d "$path"; and continue
    set -l IFS '/'
    echo $path | read -la components
    if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    end;
  ...
41	41	-----------> not test -d "$path"
30	30	-----------> set -l IFS '/'
96	96	-----------> echo $path | read -la components
13	134	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
33	33	------------> test "x$components[-1]" = xcompletions
54	54	------------> contains -- $path $fish_function_path
34	34	------------> set function_path $function_path $path
40	40	-----------> not test -d "$path"
29	29	-----------> set -l IFS '/'
90	90	-----------> echo $path | read -la components
12	132	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
32	32	------------> test "x$components[-1]" = xcompletions
53	53	------------> contains -- $path $fish_function_path
35	35	------------> set function_path $function_path $path
39	39	-----------> not test -d "$path"
40	40	-----------> set -l IFS '/'
91	91	-----------> echo $path | read -la components
13	130	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
32	32	------------> test "x$components[-1]" = xcompletions
48	48	------------> contains -- $path $fish_function_path
37	37	------------> set function_path $function_path $path
39	39	-----------> not test -d "$path"
29	29	-----------> set -l IFS '/'
97	97	-----------> echo $path | read -la components
12	133	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
33	33	------------> test "x$components[-1]" = xcompletions
48	48	------------> contains -- $path $fish_function_path
40	40	------------> set function_path $function_path $path
39	39	-----------> not test -d "$path"
28	28	-----------> set -l IFS '/'
90	90	-----------> echo $path | read -la components
13	143	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
32	32	------------> test "x$components[-1]" = xcompletions
57	57	------------> contains -- $path $fish_function_path
41	41	------------> set function_path $function_path $path
39	39	-----------> not test -d "$path"
29	29	-----------> set -l IFS '/'
91	91	-----------> echo $path | read -la components
13	133	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
31	31	------------> test "x$components[-1]" = xcompletions
47	47	------------> contains -- $path $fish_function_path
42	42	------------> set function_path $function_path $path
38	38	-----------> not test -d "$path"
28	28	-----------> set -l IFS '/'
90	90	-----------> echo $path | read -la components
13	134	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
31	31	------------> test "x$components[-1]" = xcompletions
47	47	------------> contains -- $path $fish_function_path
43	43	------------> set function_path $function_path $path
39	39	-----------> not test -d "$path"
28	28	-----------> set -l IFS '/'
89	89	-----------> echo $path | read -la components
13	140	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
31	31	------------> test "x$components[-1]" = xcompletions
52	52	------------> contains -- $path $fish_function_path
44	44	------------> set function_path $function_path $path
39	39	-----------> not test -d "$path"
28	28	-----------> set -l IFS '/'
88	88	-----------> echo $path | read -la components
15	204	-----------> if test "x$components[-1]" = xcompletions
      contains -- $path $fish_complete_path
        or set complete_path $complete_path $path
    else
      contains -- $path $fish_function_path
        or set function_path $function_path $path
    ...
31	31	------------> test "x$components[-1]" = xcompletions
107	107	------------> contains -- $path $fish_function_path
51	51	------------> set function_path $function_path $path
41	41	-----------> not test -d "$path"
24	24	-----------> continue
38	38	----------> test -n "$function_path"
76	76	----------> set fish_function_path $fish_function_path[1] $function_path $fish_function_path[2..-1]
28	28	----------> test -n "$complete_path"
25	25	----------> return 0
151	151	------> emit init_$package $path
36	36	------> set -g omf_init_path $omf_init_path $path
38	38	------> emit perf:timer:finish $init
10	10	-----> for conf in $conf_path
    source $conf
  ...
25	25	-----> return 0
39	39	----> emit perf:timer:finish "Oh My Fish init installed packages"
209	412	----> functions -q fish_user_key_bindings
196	203	-----> source /Users/tkg/.config/fish/functions/fish_user_key_bindings.fish
7	7	------> function fish_user_key_bindings
  fzf_key_bindings
...
159	159	----> not functions -q __original_fish_user_key_bindings
50	50	----> functions -c fish_user_key_bindings __original_fish_user_key_bindings
7	7	----> function fish_user_key_bindings
  test -f $OMF_CONFIG/theme
    and read -l theme < $OMF_CONFIG/theme
    or set -l theme default
  test -e $OMF_CONFIG/key_bindings.fish;
    and source $OMF_CONFIG/key_bindings.fish
  # Prepare packages key bindings paths
  set -l key_bindings {$OMF_CONFIG,$OMF_PATH}/pkg/*/key_bindings.fish \
                      {$OMF_CONFIG,$OMF_PATH}/themes*/$theme/key_bindings.fish
  # Source all keybindings collected
  for file in $key_bindings
    source $file
  end
  # Call original key bindings if existent
  functions -q __original_fish_user_key_bindings
    and __original_fish_user_key_bindings
...
39	39	----> emit perf:timer:start "Oh My Fish init user config path"
195	1541	----> require --no-bundle --path $OMF_CONFIG
314	322	-----> source /Users/tkg/.local/share/omf/lib/require.fish
8	8	------> function require
  set packages $argv

  if test -z "$packages"
    echo 'usage: require <name>...'
    echo '       require --path <path>...'
    echo '       require --no-bundle --path <path>...'
    return 1
  end

  # If bundle should be
  if set index (contains -i -- --no-bundle $packages)
    set -e packages[$index]
    set ignore_bundle
  end

  # Requiring absolute paths
  if set index (contains -i -- --path $packages)
    set -e packages[$index]
    set package_path $packages

  # Requiring specific packages from default paths
  else
    set package_path {$OMF_PATH,$OMF_CONFIG}/pkg*/$packages

    # Exit with error if no package paths were generated
    test -z "$package_path"
      and return 1
  end

  set function_path $package_path/functions*
  set complete_path $package_path/completions*
  set init_path $package_path/init.fish*
  set conf_path $package_path/conf.d/*.fish

  # Autoload functions
  test -n "$function_path"
    and set fish_function_path $fish_function_path[1] \
                               $function_path \
                               $fish_function_path[2..-1]

  # Autoload completions
  test -n "$complete_path"
    and set fish_complete_path $fish_complete_path[1] \
                               $complete_path \
                               $fish_complete_path[2..-1]

  for init in $init_path
    emit perf:timer:start $init
    set -l IFS '/'
    echo $init | read -la components

    set path (printf '/%s' $components[1..-2])

    contains $path $omf_init_path
      and continue

    set package $components[-2]

    if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    end

    source $init $path

    emit init_$package $path

    set -g omf_init_path $omf_init_path $path
    emit perf:timer:finish $init
  end

  for conf in $conf_path
    source $conf
  end

  return 0
...
39	39	-----> set packages $argv
5	36	-----> if test -z "$packages"
    echo 'usage: require <name>...'
    echo '       require --path <path>...'
    echo '       require --no-bundle --path <path>...'
    return 1
  ...
31	31	------> test -z "$packages"
10	298	-----> if set index (contains -i -- --no-bundle $packages)
    set -e packages[$index]
    set ignore_bundle
  ...
76	225	------> set index (contains -i -- --no-bundle $packages)
149	149	-------> contains -i -- --no-bundle $packages
36	36	------> set -e packages[$index]
27	27	------> set ignore_bundle
11	199	-----> if set index (contains -i -- --path $packages)
    set -e packages[$index]
    set package_path $packages

  # Requiring specific packages from default paths
  else
    set package_path {$OMF_PATH,$OMF_CONFIG}/pkg*/$packages

    # Exit with error if no package paths were generated
    test -z "$package_path"
      and return 1
  ...
71	123	------> set index (contains -i -- --path $packages)
52	52	-------> contains -i -- --path $packages
34	34	------> set -e packages[$index]
31	31	------> set package_path $packages
101	101	-----> set function_path $package_path/functions*
86	86	-----> set complete_path $package_path/completions*
83	83	-----> set init_path $package_path/init.fish*
82	82	-----> set conf_path $package_path/conf.d/*.fish
29	29	-----> test -n "$function_path"
26	26	-----> test -n "$complete_path"
12	12	-----> for init in $init_path
    emit perf:timer:start $init
    set -l IFS '/'
    echo $init | read -la components

    set path (printf '/%s' $components[1..-2])

    contains $path $omf_init_path
      and continue

    set package $components[-2]

    if not set -q ignore_bundle
      set bundle $path/bundle
      set dependencies

      if test -f $bundle
        set -l IFS ' '
        while read -l type dependency
          test "$type" != package
            and continue
          require "$dependency"
          set dependencies $dependencies $dependency
        end < $bundle
      end
    end

    source $init $path

    emit init_$package $path

    set -g omf_init_path $omf_init_path $path
    emit perf:timer:finish $init
  ...
8	8	-----> for conf in $conf_path
    source $conf
  ...
25	25	-----> return 0
40	40	----> emit perf:timer:finish "Oh My Fish init user config path"
244	244	----> set -l theme_conf_path {$OMF_CONFIG,$OMF_PATH}/themes*/$theme/conf.d
11	11	----> for conf in $theme_conf_path/*.fish
  source $conf
...
40	40	----> emit perf:timer:finish "Oh My Fish initialisation"
74	74	> builtin source /usr/local/Cellar/fish/3.1.2/etc/fish/config.fish
107	6444	> builtin source /Users/tkg/.config/fish/config.fish
247	1972	-> export PATH="/Users/tkg/.deno/bin:$PATH"
237	253	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/export.fish
16	16	---> function export --description 'Set env variable. Alias for `set -gx` for bash compatibility.'
    if not set -q argv[1]
        set -x
        return 0
    end
    for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    end
...
7	40	--> if not set -q argv[1]
        set -x
        return 0
    ...
33	33	---> not set -q argv[1]
21	1432	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
116	293	---> set -l v (string split -m 1 "=" -- $arg)
177	177	----> string split -m 1 "=" -- $arg
82	1118	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
338	338	----> count $v
21	698	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
56	56	-----> contains -- $v[1] PATH CDPATH MANPATH
131	380	-----> set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
173	249	------> string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2]
76	76	-------> string join ":" -- $$v[1]
171	241	-----> set -gx $v[1] (string split ":" -- $colonized_path)
70	70	------> string split ":" -- $colonized_path
58	1377	-> export PATH="$HOME/.cargo/bin:$PATH"
5	35	--> if not set -q argv[1]
        set -x
        return 0
    ...
30	30	---> not set -q argv[1]
21	1284	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
141	201	---> set -l v (string split -m 1 "=" -- $arg)
60	60	----> string split -m 1 "=" -- $arg
87	1062	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
63	63	----> count $v
18	912	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
116	116	-----> contains -- $v[1] PATH CDPATH MANPATH
167	558	-----> set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
186	391	------> string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2]
205	205	-------> string join ":" -- $$v[1]
149	220	-----> set -gx $v[1] (string split ":" -- $colonized_path)
71	71	------> string split ":" -- $colonized_path
63	1180	-> export PATH="$PATH:$GOPATH/bin"
6	34	--> if not set -q argv[1]
        set -x
        return 0
    ...
28	28	---> not set -q argv[1]
23	1083	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
99	163	---> set -l v (string split -m 1 "=" -- $arg)
64	64	----> string split -m 1 "=" -- $arg
85	897	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
94	94	----> count $v
23	718	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
48	48	-----> contains -- $v[1] PATH CDPATH MANPATH
103	344	-----> set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
161	241	------> string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2]
80	80	-------> string join ":" -- $$v[1]
238	303	-----> set -gx $v[1] (string split ":" -- $colonized_path)
65	65	------> string split ":" -- $colonized_path
106	818	-> export VISUAL=nvim
10	72	--> if not set -q argv[1]
        set -x
        return 0
    ...
62	62	---> not set -q argv[1]
24	640	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
112	168	---> set -l v (string split -m 1 "=" -- $arg)
56	56	----> string split -m 1 "=" -- $arg
92	448	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
64	64	----> count $v
15	292	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
48	48	-----> contains -- $v[1] PATH CDPATH MANPATH
186	186	-----> true
43	43	-----> set -gx $v[1] $v[2]
70	521	-> export EDITOR="$VISUAL"
5	31	--> if not set -q argv[1]
        set -x
        return 0
    ...
26	26	---> not set -q argv[1]
19	420	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
111	159	---> set -l v (string split -m 1 "=" -- $arg)
48	48	----> string split -m 1 "=" -- $arg
64	242	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
51	51	----> count $v
12	127	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
46	46	-----> contains -- $v[1] PATH CDPATH MANPATH
33	33	-----> true
36	36	-----> set -gx $v[1] $v[2]
50	469	-> export FZF_DEFAULT_COMMAND='fd --type f'
4	31	--> if not set -q argv[1]
        set -x
        return 0
    ...
27	27	---> not set -q argv[1]
20	388	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
106	159	---> set -l v (string split -m 1 "=" -- $arg)
53	53	----> string split -m 1 "=" -- $arg
47	209	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
43	43	----> count $v
12	119	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
40	40	-----> contains -- $v[1] PATH CDPATH MANPATH
31	31	-----> true
36	36	-----> set -gx $v[1] $v[2]
144	152	> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_title.fish
8	8	-> function fish_title
    # emacs is basically the only term that can't handle it.
    if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    end
...
46	2679	> fish_title
9	2633	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
269	2594	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
212	2291	---> __fish_pwd
131	1928	----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_pwd.fish
72	1797	-----> switch (uname)
    case 'CYGWIN_*'
        function __fish_pwd --description "Show current path"
            pwd | sed -e 's-^/cygdrive/\(.\)/\?-\u\1:/-'
        end
    case '*'
        function __fish_pwd --description "Show current path"
            pwd
        end
...
1713	1713	------> uname
12	12	------> function __fish_pwd --description "Show current path"
            pwd
        ...
151	151	----> pwd
415	423	> source /Users/tkg/.config/fish/functions/fish_prompt.fish
8	8	-> function fish_prompt
	set -l __last_command_exit_status $status

    if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    end

    set -l cyan (set_color -o cyan)
    set -l yellow (set_color -o yellow)
    set -l red (set_color -o red)
    set -l green (set_color -o green)
    set -l blue (set_color -o blue)
    set -l normal (set_color normal)

    set -l arrow_color "$green"
    if test $__last_command_exit_status != 0
        set arrow_color "$red"
    end

    set -l arrow "$arrow_color➜ "
    if test "$USER" = 'root'
        set arrow "$arrow_color# "
    end

    set -l cwd $cyan(basename (prompt_pwd))

    if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    end

    echo -n -s $arrow ' '$cwd $repo_info $normal ' '
...
117	124	> source /Users/tkg/.local/share/omf/themes/default/fish_right_prompt.fish
7	7	-> function fish_right_prompt
  set_color $fish_color_autosuggestion 2> /dev/null; or set_color 555
  date "+%H:%M:%S"
  set_color normal
...
34	20544	> __fish_on_interactive
326	20471	-> __fish_config_interactive
1286	1300	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_config_interactive.fish
14	14	---> function __fish_config_interactive -d "Initializations that should be performed when entering interactive mode"
    if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    end

    # Make sure this function is only run once.
    if set -q __fish_config_interactive_done
        return
    end

    set -g __fish_config_interactive_done
    set -g __fish_active_key_bindings

    if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    end

    if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    end

    # usage: __init_uvar VARIABLE VALUES...
    function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    end

    #
    # If we are starting up for the first time, set various defaults.
    if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    end

    #
    # Generate man page completions if not present.
    #
    # Don't do this if we're being invoked as part of running unit tests.
    if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    end

    #
    # Print a greeting.
    # fish_greeting can be a function (preferred) or a variable.
    #
    if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    end

    #
    # This event handler makes sure the prompt is repainted when
    # fish_color_cwd{,_root} changes value. Like all event handlers, it can't be
    # autoloaded.
    #
    set -l varargs --on-variable fish_key_bindings
    for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    end
    function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    end

    #
    # Completions for SysV startup scripts. These aren't bound to any
    # specific command, so they can't be autoloaded.
    #
    if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    end

    #
    # We want to show our completions for the [ (test) builtin, but
    # we don't want to create a [.fish. test.fish will not be loaded until
    # the user tries [ interactively.
    #
    complete -c [ --wraps test
    complete -c ! --wraps not

    #
    # Only a few builtins take filenames; initialize the rest with no file completions
    #
    complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files

    # Reload key bindings when binding variable change
    function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    end

    # Load key bindings
    __fish_reload_key_bindings

    if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    end

    # Similarly, enable TMUX's focus reporting when in tmux.
    # This will be handled by
    # - The keybindings (reading the sequence and triggering an event)
    # - Any listeners (like the vi-cursor)
    if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    end

    function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    end

    # Notify terminals when $PWD changes (issue #906).
    # VTE based terminals, Terminal.app, and iTerm.app (TODO) support this.
    if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    end

    ### Command-not-found handlers
    # This can be overridden by defining a new __fish_command_not_found_handler function
    if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    end

    # Bump this whenever some code below needs to run once when upgrading to a new version.
    # The universal variable __fish_initialized is initialized in share/config.fish.
    set __fish_initialized 3100
...
5	104	--> if test $__fish_initialized -lt 3000
        # Perform transitions relevant to going from fish 2.x to 3.x.

        # Migrate old universal abbreviations to the new scheme.
        __fish_abbr_old | source
    ...
99	99	---> test $__fish_initialized -lt 3000
4	41	--> if set -q __fish_config_interactive_done
        return
    ...
37	37	---> set -q __fish_config_interactive_done
30	30	--> set -g __fish_config_interactive_done
27	27	--> set -g __fish_active_key_bindings
3	27	--> if not set -q fish_greeting
        set -l line1 (_ 'Welcome to fish, the friendly interactive shell')
        set -l line2 ''
        if test $__fish_initialized -lt 2300
            set line2 \n(_ 'Type `help` for instructions on how to use fish')
        end
        set -U fish_greeting "$line1$line2"
    ...
24	24	---> not set -q fish_greeting
4	28	--> if set -q fish_private_mode; and string length -q -- $fish_greeting
        set -l line (_ "fish is running in private mode, history will not be persisted.")
        set -g fish_greeting $fish_greeting.\n$line
    ...
24	24	---> set -q fish_private_mode
12	12	--> function __init_uvar -d "Sets a universal variable if it's not already set"
        if not set --query $argv[1]
            set --universal $argv
        end
    ...
2	32	--> if test $__fish_initialized -lt 3100

        # Regular syntax highlighting colors
        __init_uvar fish_color_normal normal
        __init_uvar fish_color_command 005fd7
        __init_uvar fish_color_param 00afff
        __init_uvar fish_color_redirection 00afff
        __init_uvar fish_color_comment 990000
        __init_uvar fish_color_error ff0000
        __init_uvar fish_color_escape 00a6b2
        __init_uvar fish_color_operator 00a6b2
        __init_uvar fish_color_end 009900
        __init_uvar fish_color_quote 999900
        __init_uvar fish_color_autosuggestion 555 brblack
        __init_uvar fish_color_user brgreen
        __init_uvar fish_color_host normal
        __init_uvar fish_color_host_remote yellow
        __init_uvar fish_color_valid_path --underline
        __init_uvar fish_color_status red

        __init_uvar fish_color_cwd green
        __init_uvar fish_color_cwd_root red

        # Background color for matching quotes and parenthesis
        __init_uvar fish_color_match --background=brblue

        # Background color for search matches
        __init_uvar fish_color_search_match bryellow --background=brblack

        # Background color for selections
        __init_uvar fish_color_selection white --bold --background=brblack

        # XXX fish_color_cancel was added in 2.6, but this was added to post-2.3 initialization
        # when 2.4 and 2.5 were already released
        __init_uvar fish_color_cancel -r

        # Pager colors
        __init_uvar fish_pager_color_prefix white --bold --underline
        __init_uvar fish_pager_color_completion
        __init_uvar fish_pager_color_description B3A06D yellow
        __init_uvar fish_pager_color_progress brwhite --background=cyan

        #
        # Directory history colors
        #
        __init_uvar fish_color_history_current --bold
    ...
30	30	---> test $__fish_initialized -lt 3100
15	94	--> if not set -q FISH_UNIT_TESTS_RUNNING
        if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        end
    ...
25	25	---> not set -q FISH_UNIT_TESTS_RUNNING
3	54	---> if not test -d $__fish_user_data_dir/generated_completions
            # Generating completions from man pages needs python (see issue #3588).

            # We cannot simply do `fish_update_completions &` because it is a function.
            # We cannot do `eval` since it is a function.
            # We don't want to call `fish -c` since that is unnecessary and sources config.fish again.
            # Hence we'll call python directly.
            # c_m_p.py should work with any python version.
            set -l update_args -B $__fish_data_dir/tools/create_manpage_completions.py --manpath --cleanup-in '~/.config/fish/completions' --cleanup-in '~/.config/fish/generated_completions'
            for py in python{3,2,}
                if command -sq $py
                    set -l c $py $update_args
                    # Run python directly in the background and swallow all output
                    $c (: fish_update_completions: generating completions from man pages) >/dev/null 2>&1 &
                    # Then disown the job so that it continues to run in case of an early exit (#6269)
                    disown 2>&1 >/dev/null
                    break
                end
            end
        ...
51	51	----> not test -d $__fish_user_data_dir/generated_completions
7	262	--> if status --is-interactive
        if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        end
    ...
27	27	---> status --is-interactive
8	228	---> if functions -q fish_greeting
            fish_greeting
        else
            # The greeting used to be skipped when fish_greeting was empty (not just undefined)
            # Keep it that way to not print superfluous newlines on old configuration
            test -n "$fish_greeting"
            and echo $fish_greeting
        ...
186	186	----> functions -q fish_greeting
34	34	----> test -n "$fish_greeting"
32	32	--> set -l varargs --on-variable fish_key_bindings
33	210	--> for var in user host cwd{,_root} status
        set -a varargs --on-variable fish_color_$var
    ...
36	36	---> set -a varargs --on-variable fish_color_$var
33	33	---> set -a varargs --on-variable fish_color_$var
35	35	---> set -a varargs --on-variable fish_color_$var
37	37	---> set -a varargs --on-variable fish_color_$var
36	36	---> set -a varargs --on-variable fish_color_$var
33	33	--> function __fish_repaint $varargs -d "Event handler, repaints the prompt when fish_color_cwd* changes"
        if status --is-interactive
            set -e __fish_prompt_cwd
            commandline -f repaint 2>/dev/null
        end
    ...
4	42	--> if test -d /etc/init.d
        complete -x -p "/etc/init.d/*" -a start --description 'Start service'
        complete -x -p "/etc/init.d/*" -a stop --description 'Stop service'
        complete -x -p "/etc/init.d/*" -a status --description 'Print service status'
        complete -x -p "/etc/init.d/*" -a restart --description 'Stop and then start service'
        complete -x -p "/etc/init.d/*" -a reload --description 'Reload service configuration'
    ...
38	38	---> test -d /etc/init.d
168	168	--> complete -c [ --wraps test
37	37	--> complete -c ! --wraps not
193	369	--> complete -c(builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)') --no-files
176	176	---> builtin -n | string match -rv '(source|cd|exec|realpath|set|\\[|test|for)'
14	14	--> function __fish_reload_key_bindings -d "Reload key bindings when binding variable change" --on-variable fish_key_bindings
        # Make sure some key bindings are set
        __init_uvar fish_key_bindings fish_default_key_bindings

        # Do nothing if the key bindings didn't actually change.
        # This could be because the variable was set to the existing value
        # or because it was a local variable.
        # If fish_key_bindings is empty on the first run, we still need to set the defaults.
        if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        end
        # Check if fish_key_bindings is a valid function.
        # If not, either keep the previous bindings (if any) or revert to default.
        # Also print an error so the user knows.
        if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        end
        set -g __fish_active_key_bindings "$fish_key_bindings"
        set -g fish_bind_mode default
        if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        end
        # Load user key bindings if they are defined
        if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        end
    ...
45	10902	--> __fish_reload_key_bindings
36	71	---> __init_uvar fish_key_bindings fish_default_key_bindings
3	35	----> if not set --query $argv[1]
            set --universal $argv
        ...
32	32	-----> not set --query $argv[1]
4	45	---> if test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
            return
        ...
41	41	----> test "$fish_key_bindings" = "$__fish_active_key_bindings" -a -n "$fish_key_bindings"
2	658	---> if not functions -q "$fish_key_bindings"
            echo "There is no fish_key_bindings function called: '$fish_key_bindings'" >&2
            # We need to see if this is a defined function, otherwise we'd be in an endless loop.
            if functions -q $__fish_active_key_bindings
                echo "Keeping $__fish_active_key_bindings" >&2
                # Set the variable to the old value so this error doesn't happen again.
                set fish_key_bindings $__fish_active_key_bindings
                return 1
            else if functions -q fish_default_key_bindings
                echo "Reverting to default bindings" >&2
                set fish_key_bindings fish_default_key_bindings
                # Return because we are called again
                return 0
            else
                # If we can't even find the default bindings, something is broken.
                # Without it, we would eventually run into the stack size limit, but that'd print hundreds of duplicate lines
                # so we should give up earlier.
                echo "Cannot find fish_default_key_bindings, falling back to very simple bindings." >&2
                echo "Most likely something is wrong with your installation." >&2
                return 0
            end
        ...
210	656	----> not functions -q "$fish_key_bindings"
435	446	-----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_default_key_bindings.fish
11	11	------> function fish_default_key_bindings -d "Default (Emacs-like) key bindings for fish"
    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    end

    # Silence warnings about unavailable keys. See #4431, 4188
    if not contains -- -s $argv
        set argv "-s" $argv
    end

    # These are shell-specific bindings that we share with vi mode.
    __fish_shared_key_bindings $argv
    or return # protect against invalid $argv

    # This is the default binding, i.e. the one used if no other binding matches
    bind --preset $argv "" self-insert
    or exit # protect against invalid $argv

    # Space expands abbrs _and_ inserts itself.
    bind --preset $argv " " self-insert expand-abbr

    bind --preset $argv \n execute
    bind --preset $argv \r execute

    bind --preset $argv \ck kill-line

    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char

    bind --preset $argv -k dc delete-char
    bind --preset $argv -k backspace backward-delete-char
    bind --preset $argv \x7f backward-delete-char

    # for PuTTY
    # https://github.com/fish-shell/fish-shell/issues/180
    bind --preset $argv \e\[1~ beginning-of-line
    bind --preset $argv \e\[3~ delete-char
    bind --preset $argv \e\[4~ end-of-line

    # OS X SnowLeopard doesn't have these keys. Don't show an annoying error message.
    bind --preset $argv -k home beginning-of-line 2>/dev/null
    bind --preset $argv -k end end-of-line 2>/dev/null
    bind --preset $argv \e\[3\;2~ backward-delete-char # Mavericks Terminal.app shift-ctrl-delete

    bind --preset $argv \ca beginning-of-line
    bind --preset $argv \ce end-of-line
    bind --preset $argv \ch backward-delete-char
    bind --preset $argv \cp up-or-search
    bind --preset $argv \cn down-or-search
    bind --preset $argv \cf forward-char
    bind --preset $argv \cb backward-char
    bind --preset $argv \ct transpose-chars
    bind --preset $argv \et transpose-words
    bind --preset $argv \eu upcase-word

    # This clashes with __fish_list_current_token
    # bind --preset $argv \el downcase-word
    bind --preset $argv \ec capitalize-word
    # One of these is alt+backspace.
    bind --preset $argv \e\x7f backward-kill-word
    bind --preset $argv \e\b backward-kill-word
    bind --preset $argv \eb backward-word
    bind --preset $argv \ef forward-word
    bind --preset $argv \e\[1\;5C forward-word
    bind --preset $argv \e\[1\;5D backward-word
    bind --preset $argv \e\< beginning-of-buffer
    bind --preset $argv \e\> end-of-buffer

    bind --preset $argv \ed kill-word

    # term-specific special bindings
    switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    end
...
58	58	---> set -g __fish_active_key_bindings "$fish_key_bindings"
31	31	---> set -g fish_bind_mode default
10	7461	---> if test "$fish_key_bindings" = fish_default_key_bindings
            # Redirect stderr per #1155
            fish_default_key_bindings 2>/dev/null
        else
            $fish_key_bindings 2>/dev/null
        ...
30	30	----> test "$fish_key_bindings" = fish_default_key_bindings
188	7421	----> fish_default_key_bindings 2>/dev/null
5	79	-----> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
40	40	------> contains -- -h $argv
34	34	------> contains -- --help $argv
6	218	-----> if not set -q argv[1]
        bind --erase --all --preset # clear earlier bindings, if any
        if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        end
    ...
25	25	------> not set -q argv[1]
149	149	------> bind --erase --all --preset
4	38	------> if test "$fish_key_bindings" != "fish_default_key_bindings"
            # Allow the user to set the variable universally
            set -q fish_key_bindings
            or set -g fish_key_bindings
            # This triggers the handler, which calls us again and ensures the user_key_bindings
            # are executed.
            set fish_key_bindings fish_default_key_bindings
            return
        ...
34	34	-------> test "$fish_key_bindings" != "fish_default_key_bindings"
6	73	-----> if not contains -- -s $argv
        set argv "-s" $argv
    ...
37	37	------> not contains -- -s $argv
30	30	------> set argv "-s" $argv
362	5000	-----> __fish_shared_key_bindings $argv
764	793	------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_shared_key_bindings.fish
11	11	-------> function __fish_shared_key_bindings -d "Bindings shared between emacs and vi mode"
    # These are some bindings that are supposed to be shared between vi mode and default mode.
    # They are supposed to be unrelated to text-editing (or movement).
    # This takes $argv so the vi-bindings can pass the mode they are valid in.

    if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    end

    bind --preset $argv \cy yank
    or return # protect against invalid $argv
    bind --preset $argv \ey yank-pop

    # Left/Right arrow
    bind --preset $argv -k right forward-char
    bind --preset $argv -k left backward-char
    bind --preset $argv \e\[C forward-char
    bind --preset $argv \e\[D backward-char
    # Some terminals output these when they're in in keypad mode.
    bind --preset $argv \eOC forward-char
    bind --preset $argv \eOD backward-char

    bind --preset $argv -k ppage beginning-of-history
    bind --preset $argv -k npage end-of-history

    # Interaction with the system clipboard.
    bind --preset $argv \cx fish_clipboard_copy
    bind --preset $argv \cv fish_clipboard_paste

    bind --preset $argv \e cancel
    bind --preset $argv \t complete
    bind --preset $argv \cs pager-toggle-search
    # shift-tab does a tab complete followed by a search.
    bind --preset $argv --key btab complete-and-search

    bind --preset $argv \e\n "commandline -i \n"
    bind --preset $argv \e\r "commandline -i \n"

    bind --preset $argv -k down down-or-search
    bind --preset $argv -k up up-or-search
    bind --preset $argv \e\[A up-or-search
    bind --preset $argv \e\[B down-or-search
    bind --preset $argv \eOA up-or-search
    bind --preset $argv \eOB down-or-search

    bind --preset $argv -k sright forward-bigword
    bind --preset $argv -k sleft backward-bigword

    # Alt-left/Alt-right
    bind --preset $argv \e\eOC nextd-or-forward-word
    bind --preset $argv \e\eOD prevd-or-backward-word
    bind --preset $argv \e\e\[C nextd-or-forward-word
    bind --preset $argv \e\e\[D prevd-or-backward-word
    bind --preset $argv \eO3C nextd-or-forward-word
    bind --preset $argv \eO3D prevd-or-backward-word
    bind --preset $argv \e\[3C nextd-or-forward-word
    bind --preset $argv \e\[3D prevd-or-backward-word
    bind --preset $argv \e\[1\;3C nextd-or-forward-word
    bind --preset $argv \e\[1\;3D prevd-or-backward-word
    bind --preset $argv \e\[1\;9C nextd-or-forward-word #iTerm2
    bind --preset $argv \e\[1\;9D prevd-or-backward-word #iTerm2

    # Alt-up/Alt-down
    bind --preset $argv \e\eOA history-token-search-backward
    bind --preset $argv \e\eOB history-token-search-forward
    bind --preset $argv \e\e\[A history-token-search-backward
    bind --preset $argv \e\e\[B history-token-search-forward
    bind --preset $argv \eO3A history-token-search-backward
    bind --preset $argv \eO3B history-token-search-forward
    bind --preset $argv \e\[3A history-token-search-backward
    bind --preset $argv \e\[3B history-token-search-forward
    bind --preset $argv \e\[1\;3A history-token-search-backward
    bind --preset $argv \e\[1\;3B history-token-search-forward
    bind --preset $argv \e\[1\;9A history-token-search-backward # iTerm2
    bind --preset $argv \e\[1\;9B history-token-search-forward # iTerm2
    # Bash compatibility
    # https://github.com/fish-shell/fish-shell/issues/89
    bind --preset $argv \e. history-token-search-backward

    bind --preset $argv \el __fish_list_current_token
    bind --preset $argv \ew __fish_whatis_current_token
    # ncurses > 6.0 sends a "delete scrollback" sequence along with clear.
    # This string replace removes it.
    bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
    bind --preset $argv \cc __fish_cancel_commandline
    bind --preset $argv \cu backward-kill-line
    bind --preset $argv \cw backward-kill-path-component
    bind --preset $argv \e\[F end-of-line
    bind --preset $argv \e\[H beginning-of-line

    bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
    bind --preset $argv \cd delete-or-exit

    # Prepend 'sudo ' to the current commandline
    bind --preset $argv \es __fish_prepend_sudo

    # Allow reading manpages by pressing F1 (many GUI applications) or Alt+h (like in zsh).
    bind --preset $argv -k f1 __fish_man_page
    bind --preset $argv \eh __fish_man_page

    # This will make sure the output of the current command is paged using the default pager when
    # you press Meta-p.
    # If none is set, less will be used.
    bind --preset $argv \ep '__fish_paginate'

    # Make it easy to turn an unexecuted command into a comment in the shell history. Also,
    # remove the commenting chars so the command can be further edited then executed.
    bind --preset $argv \e\# __fish_toggle_comment_commandline

    # The [meta-e] and [meta-v] keystrokes invoke an external editor on the command buffer.
    bind --preset $argv \ee edit_command_buffer
    bind --preset $argv \ev edit_command_buffer

    # Tmux' focus events.
    # Exclude paste mode because that should get _everything_ literally.
    for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    end

    # Support for "bracketed paste"
    # The way it works is that we acknowledge our support by printing
    # \e\[?2004h
    # then the terminal will "bracket" every paste in
    # \e\[200~ and \e\[201~
    # Every character in between those two will be part of the paste and should not cause a binding to execute (like \n executing commands).
    #
    # We enable it after every command and disable it before (in __fish_config_interactive.fish)
    #
    # Support for this seems to be ubiquitous - emacs enables it unconditionally (!) since 25.1
    # (though it only supports it since then, it seems to be the last term to gain support).
    #
    # NOTE: This is more of a "security" measure than a proper feature.
    # The better way to paste remains the `fish_clipboard_paste` function (bound to \cv by default).
    # We don't disable highlighting here, so it will be redone after every character (which can be slow),
    # and it doesn't handle "paste-stop" sequences in the paste (which the terminal needs to strip).
    #
    # See http://thejh.net/misc/website-terminal-copy-paste.

    # Bind the starting sequence in every bind mode, even user-defined ones.
    # Exclude paste mode or there'll be an additional binding after switching between emacs and vi
    for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    end
    # This sequence ends paste-mode and returns to the previous mode we have saved before.
    bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
    # In paste-mode, everything self-inserts except for the sequence to get out of it
    bind --preset -M paste "" self-insert
    # Without this, a \r will overwrite the other text, rendering it invisible - which makes the exercise kinda pointless.
    bind --preset -M paste \r "commandline -i \n"

    # We usually just pass the text through as-is to facilitate pasting code,
    # but when the current token contains an unbalanced single-quote (`'`),
    # we escape all single-quotes and backslashes, effectively turning the paste
    # into one literal token, to facilitate pasting non-code (e.g. markdown or git commitishes)
    bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
    bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
    # Only insert spaces if we're either quoted or not at the beginning of the commandline
    # - this strips leading spaces if they would trigger histignore.
    bind --preset -M paste " " self-insert-notfirst
...
10	10	-------> function __fish_commandline_insert_escaped --description 'Insert the first arg escaped if a second arg is given'
    if set -q argv[2]
        commandline -i \\$argv[1]
    else
        commandline -i $argv[1]
    end
...
4	4	-------> function __fish_start_bracketed_paste
    # Save the last bind mode so we can restore it.
    set -g __fish_last_bind_mode $fish_bind_mode
    # If the token is currently single-quoted,
    # we escape single-quotes (and backslashes).
    __fish_commandline_is_singlequoted
    and set -g __fish_paste_quoted 1
...
4	4	-------> function __fish_stop_bracketed_paste
    # Restore the last bind mode.
    set fish_bind_mode $__fish_last_bind_mode
    set -e __fish_paste_quoted
    commandline -f force-repaint
...
5	81	------> if contains -- -h $argv
        or contains -- --help $argv
        echo "Sorry but this function doesn't support -h or --help"
        return 1
    ...
41	41	-------> contains -- -h $argv
35	35	-------> contains -- --help $argv
39	39	------> bind --preset $argv \cy yank
42	42	------> bind --preset $argv \ey yank-pop
43	43	------> bind --preset $argv -k right forward-char
38	38	------> bind --preset $argv -k left backward-char
37	37	------> bind --preset $argv \e\[C forward-char
37	37	------> bind --preset $argv \e\[D backward-char
36	36	------> bind --preset $argv \eOC forward-char
36	36	------> bind --preset $argv \eOD backward-char
38	38	------> bind --preset $argv -k ppage beginning-of-history
48	48	------> bind --preset $argv -k npage end-of-history
38	38	------> bind --preset $argv \cx fish_clipboard_copy
46	46	------> bind --preset $argv \cv fish_clipboard_paste
40	40	------> bind --preset $argv \e cancel
36	36	------> bind --preset $argv \t complete
40	40	------> bind --preset $argv \cs pager-toggle-search
37	37	------> bind --preset $argv --key btab complete-and-search
38	38	------> bind --preset $argv \e\n "commandline -i \n"
38	38	------> bind --preset $argv \e\r "commandline -i \n"
39	39	------> bind --preset $argv -k down down-or-search
39	39	------> bind --preset $argv -k up up-or-search
38	38	------> bind --preset $argv \e\[A up-or-search
38	38	------> bind --preset $argv \e\[B down-or-search
37	37	------> bind --preset $argv \eOA up-or-search
37	37	------> bind --preset $argv \eOB down-or-search
40	40	------> bind --preset $argv -k sright forward-bigword
40	40	------> bind --preset $argv -k sleft backward-bigword
41	41	------> bind --preset $argv \e\eOC nextd-or-forward-word
38	38	------> bind --preset $argv \e\eOD prevd-or-backward-word
38	38	------> bind --preset $argv \e\e\[C nextd-or-forward-word
37	37	------> bind --preset $argv \e\e\[D prevd-or-backward-word
38	38	------> bind --preset $argv \eO3C nextd-or-forward-word
38	38	------> bind --preset $argv \eO3D prevd-or-backward-word
37	37	------> bind --preset $argv \e\[3C nextd-or-forward-word
37	37	------> bind --preset $argv \e\[3D prevd-or-backward-word
38	38	------> bind --preset $argv \e\[1\;3C nextd-or-forward-word
38	38	------> bind --preset $argv \e\[1\;3D prevd-or-backward-word
42	42	------> bind --preset $argv \e\[1\;9C nextd-or-forward-word
39	39	------> bind --preset $argv \e\[1\;9D prevd-or-backward-word
38	38	------> bind --preset $argv \e\eOA history-token-search-backward
37	37	------> bind --preset $argv \e\eOB history-token-search-forward
63	63	------> bind --preset $argv \e\e\[A history-token-search-backward
47	47	------> bind --preset $argv \e\e\[B history-token-search-forward
41	41	------> bind --preset $argv \eO3A history-token-search-backward
40	40	------> bind --preset $argv \eO3B history-token-search-forward
48	48	------> bind --preset $argv \e\[3A history-token-search-backward
38	38	------> bind --preset $argv \e\[3B history-token-search-forward
37	37	------> bind --preset $argv \e\[1\;3A history-token-search-backward
42	42	------> bind --preset $argv \e\[1\;3B history-token-search-forward
38	38	------> bind --preset $argv \e\[1\;9A history-token-search-backward
38	38	------> bind --preset $argv \e\[1\;9B history-token-search-forward
37	37	------> bind --preset $argv \e. history-token-search-backward
38	38	------> bind --preset $argv \el __fish_list_current_token
40	40	------> bind --preset $argv \ew __fish_whatis_current_token
40	40	------> bind --preset $argv \cl 'echo -n (clear | string replace \e\[3J ""); commandline -f repaint'
36	36	------> bind --preset $argv \cc __fish_cancel_commandline
37	37	------> bind --preset $argv \cu backward-kill-line
37	37	------> bind --preset $argv \cw backward-kill-path-component
64	64	------> bind --preset $argv \e\[F end-of-line
40	40	------> bind --preset $argv \e\[H beginning-of-line
40	40	------> bind --preset $argv \ed 'set -l cmd (commandline); if test -z "$cmd"; echo; dirh; commandline -f repaint; else; commandline -f kill-word; end'
41	41	------> bind --preset $argv \cd delete-or-exit
38	38	------> bind --preset $argv \es __fish_prepend_sudo
39	39	------> bind --preset $argv -k f1 __fish_man_page
37	37	------> bind --preset $argv \eh __fish_man_page
39	39	------> bind --preset $argv \ep '__fish_paginate'
37	37	------> bind --preset $argv \e\# __fish_toggle_comment_commandline
39	39	------> bind --preset $argv \ee edit_command_buffer
37	37	------> bind --preset $argv \ev edit_command_buffer
96	406	------> for mode in (bind --list-modes | string match -v paste)
        # We only need the in-focus event currently (to redraw the vi-cursor).
        bind --preset -M $mode \e\[I 'emit fish_focus_in'
        bind --preset -M $mode \e\[O false
        bind --preset -M $mode \e\[\?1004h false
    ...
175	175	-------> bind --list-modes | string match -v paste
55	55	-------> bind --preset -M $mode \e\[I 'emit fish_focus_in'
40	40	-------> bind --preset -M $mode \e\[O false
40	40	-------> bind --preset -M $mode \e\[\?1004h false
86	309	------> for mode in (bind --list-modes | string match -v paste)
        bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
    ...
154	154	-------> bind --list-modes | string match -v paste
69	69	-------> bind --preset -M $mode -m paste \e\[200~ '__fish_start_bracketed_paste'
43	43	------> bind --preset -M paste \e\[201~ '__fish_stop_bracketed_paste'
37	37	------> bind --preset -M paste "" self-insert
61	61	------> bind --preset -M paste \r "commandline -i \n"
121	121	------> bind --preset -M paste "'" "__fish_commandline_insert_escaped \' \$__fish_paste_quoted"
50	50	------> bind --preset -M paste \\ "__fish_commandline_insert_escaped \\\ \$__fish_paste_quoted"
38	38	------> bind --preset -M paste " " self-insert-notfirst
41	41	-----> bind --preset $argv "" self-insert
39	39	-----> bind --preset $argv " " self-insert expand-abbr
37	37	-----> bind --preset $argv \n execute
37	37	-----> bind --preset $argv \r execute
37	37	-----> bind --preset $argv \ck kill-line
37	37	-----> bind --preset $argv \eOC forward-char
36	36	-----> bind --preset $argv \eOD backward-char
37	37	-----> bind --preset $argv \e\[C forward-char
36	36	-----> bind --preset $argv \e\[D backward-char
38	38	-----> bind --preset $argv -k right forward-char
44	44	-----> bind --preset $argv -k left backward-char
38	38	-----> bind --preset $argv -k dc delete-char
38	38	-----> bind --preset $argv -k backspace backward-delete-char
37	37	-----> bind --preset $argv \x7f backward-delete-char
39	39	-----> bind --preset $argv \e\[1~ beginning-of-line
38	38	-----> bind --preset $argv \e\[3~ delete-char
37	37	-----> bind --preset $argv \e\[4~ end-of-line
77	77	-----> bind --preset $argv -k home beginning-of-line 2>/dev/null
63	63	-----> bind --preset $argv -k end end-of-line 2>/dev/null
41	41	-----> bind --preset $argv \e\[3\;2~ backward-delete-char
37	37	-----> bind --preset $argv \ca beginning-of-line
37	37	-----> bind --preset $argv \ce end-of-line
40	40	-----> bind --preset $argv \ch backward-delete-char
37	37	-----> bind --preset $argv \cp up-or-search
36	36	-----> bind --preset $argv \cn down-or-search
37	37	-----> bind --preset $argv \cf forward-char
37	37	-----> bind --preset $argv \cb backward-char
36	36	-----> bind --preset $argv \ct transpose-chars
37	37	-----> bind --preset $argv \et transpose-words
99	99	-----> bind --preset $argv \eu upcase-word
42	42	-----> bind --preset $argv \ec capitalize-word
88	88	-----> bind --preset $argv \e\x7f backward-kill-word
58	58	-----> bind --preset $argv \e\b backward-kill-word
41	41	-----> bind --preset $argv \eb backward-word
52	52	-----> bind --preset $argv \ef forward-word
56	56	-----> bind --preset $argv \e\[1\;5C forward-word
62	62	-----> bind --preset $argv \e\[1\;5D backward-word
41	41	-----> bind --preset $argv \e\< beginning-of-buffer
51	51	-----> bind --preset $argv \e\> end-of-buffer
47	47	-----> bind --preset $argv \ed kill-word
21	65	-----> switch "$TERM"
        case 'rxvt*'
            bind --preset $argv \e\[8~ end-of-line
            bind --preset $argv \eOc forward-word
            bind --preset $argv \eOd backward-word
        case 'xterm-256color'
            # Microsoft's conemu uses xterm-256color plus
            # the following to tell a console to paste:
            bind --preset $argv \e\x20ep fish_clipboard_paste
    ...
44	44	------> bind --preset $argv \e\x20ep fish_clipboard_paste
9	2533	---> if functions --query fish_user_key_bindings >/dev/null
            fish_user_key_bindings 2>/dev/null
        ...
77	77	----> functions --query fish_user_key_bindings >/dev/null
76	2447	----> fish_user_key_bindings 2>/dev/null
55	55	-----> test -f $OMF_CONFIG/theme
66	66	-----> read -l theme < $OMF_CONFIG/theme
39	39	-----> test -e $OMF_CONFIG/key_bindings.fish
763	763	-----> set -l key_bindings {$OMF_CONFIG,$OMF_PATH}/pkg/*/key_bindings.fish \
                      {$OMF_CONFIG,$OMF_PATH}/themes*/$theme/key_bindings.fish
14	14	-----> for file in $key_bindings
    source $file
  ...
45	45	-----> functions -q __original_fish_user_key_bindings
36	1389	-----> __original_fish_user_key_bindings
173	1353	------> fzf_key_bindings
656	664	-------> source /Users/tkg/.config/fish/functions/fzf_key_bindings.fish
8	8	--------> function fzf_key_bindings

  # Store current token in $dir as root for the 'find' command
  function fzf-file-widget -d "List files and folders"
    set -l commandline (__fzf_parse_commandline)
    set -l dir $commandline[1]
    set -l fzf_query $commandline[2]

    # "-path \$dir'*/\\.*'" matches hidden files/folders inside $dir but not
    # $dir itself, even if hidden.
    test -n "$FZF_CTRL_T_COMMAND"; or set -l FZF_CTRL_T_COMMAND "
    command find -L \$dir -mindepth 1 \\( -path \$dir'*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \\) -prune \
    -o -type f -print \
    -o -type d -print \
    -o -type l -print 2> /dev/null | sed 's@^\./@@'"

    test -n "$FZF_TMUX_HEIGHT"; or set FZF_TMUX_HEIGHT 40%
    begin
      set -lx FZF_DEFAULT_OPTS "--height $FZF_TMUX_HEIGHT --reverse $FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS"
      eval "$FZF_CTRL_T_COMMAND | "(__fzfcmd)' -m --query "'$fzf_query'"' | while read -l r; set result $result $r; end
    end
    if [ -z "$result" ]
      commandline -f repaint
      return
    else
      # Remove last token from commandline.
      commandline -t ""
    end
    for i in $result
      commandline -it -- (string escape $i)
      commandline -it -- ' '
    end
    commandline -f repaint
  end

  function fzf-history-widget -d "Show command history"
    test -n "$FZF_TMUX_HEIGHT"; or set FZF_TMUX_HEIGHT 40%
    begin
      set -lx FZF_DEFAULT_OPTS "--height $FZF_TMUX_HEIGHT $FZF_DEFAULT_OPTS --tiebreak=index --bind=ctrl-r:toggle-sort $FZF_CTRL_R_OPTS +m"

      set -l FISH_MAJOR (echo $version | cut -f1 -d.)
      set -l FISH_MINOR (echo $version | cut -f2 -d.)

      # history's -z flag is needed for multi-line support.
      # history's -z flag was added in fish 2.4.0, so don't use it for versions
      # before 2.4.0.
      if [ "$FISH_MAJOR" -gt 2 -o \( "$FISH_MAJOR" -eq 2 -a "$FISH_MINOR" -ge 4 \) ];
        history -z | eval (__fzfcmd) --read0 --print0 -q '(commandline)' | read -lz result
        and commandline -- $result
      else
        history | eval (__fzfcmd) -q '(commandline)' | read -l result
        and commandline -- $result
      end
    end
    commandline -f repaint
  end

  function fzf-cd-widget -d "Change directory"
    set -l commandline (__fzf_parse_commandline)
    set -l dir $commandline[1]
    set -l fzf_query $commandline[2]

    test -n "$FZF_ALT_C_COMMAND"; or set -l FZF_ALT_C_COMMAND "
    command find -L \$dir -mindepth 1 \\( -path \$dir'*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \\) -prune \
    -o -type d -print 2> /dev/null | sed 's@^\./@@'"
    test -n "$FZF_TMUX_HEIGHT"; or set FZF_TMUX_HEIGHT 40%
    begin
      set -lx FZF_DEFAULT_OPTS "--height $FZF_TMUX_HEIGHT --reverse $FZF_DEFAULT_OPTS $FZF_ALT_C_OPTS"
      eval "$FZF_ALT_C_COMMAND | "(__fzfcmd)' +m --query "'$fzf_query'"' | read -l result

      if [ -n "$result" ]
        cd $result

        # Remove last token from commandline.
        commandline -t ""
      end
    end

    commandline -f repaint
  end

  function __fzfcmd
    test -n "$FZF_TMUX"; or set FZF_TMUX 0
    test -n "$FZF_TMUX_HEIGHT"; or set FZF_TMUX_HEIGHT 40%
    if [ -n "$FZF_TMUX_OPTS" ]
      echo "fzf-tmux $FZF_TMUX_OPTS -- "
    else if [ $FZF_TMUX -eq 1 ]
      echo "fzf-tmux -d$FZF_TMUX_HEIGHT -- "
    else
      echo "fzf"
    end
  end

  bind \ct fzf-file-widget
  bind \cr fzf-history-widget
  bind \ec fzf-cd-widget

  if bind -M insert > /dev/null 2>&1
    bind -M insert \ct fzf-file-widget
    bind -M insert \cr fzf-history-widget
    bind -M insert \ec fzf-cd-widget
  end

  function __fzf_parse_commandline -d 'Parse the current command line token and return split of existing filepath and rest of token'
    # eval is used to do shell expansion on paths
    set -l commandline (eval "printf '%s' "(commandline -t))

    if [ -z $commandline ]
      # Default to current directory with no --query
      set dir '.'
      set fzf_query ''
    else
      set dir (__fzf_get_dir $commandline)

      if [ "$dir" = "." -a (string sub -l 1 $commandline) != '.' ]
        # if $dir is "." but commandline is not a relative path, this means no file path found
        set fzf_query $commandline
      else
        # Also remove trailing slash after dir, to "split" input properly
        set fzf_query (string replace -r "^$dir/?" '' "$commandline")
      end
    end

    echo $dir
    echo $fzf_query
  end

  function __fzf_get_dir -d 'Find the longest existing filepath from input string'
    set dir $argv

    # Strip all trailing slashes. Ignore if $dir is root dir (/)
    if [ (string length $dir) -gt 1 ]
      set dir (string replace -r '/*$' '' $dir)
    end

    # Iteratively check if dir exists and strip tail end of path
    while [ ! -d "$dir" ]
      # If path is absolute, this can keep going until ends up at /
      # If path is relative, this can keep going until entire input is consumed, dirname returns "."
      set dir (dirname "$dir")
    end

    echo $dir
  end

...
23	23	-------> function fzf-file-widget -d "List files and folders"
    set -l commandline (__fzf_parse_commandline)
    set -l dir $commandline[1]
    set -l fzf_query $commandline[2]

    # "-path \$dir'*/\\.*'" matches hidden files/folders inside $dir but not
    # $dir itself, even if hidden.
    test -n "$FZF_CTRL_T_COMMAND"; or set -l FZF_CTRL_T_COMMAND "
    command find -L \$dir -mindepth 1 \\( -path \$dir'*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \\) -prune \
    -o -type f -print \
    -o -type d -print \
    -o -type l -print 2> /dev/null | sed 's@^\./@@'"

    test -n "$FZF_TMUX_HEIGHT"; or set FZF_TMUX_HEIGHT 40%
    begin
      set -lx FZF_DEFAULT_OPTS "--height $FZF_TMUX_HEIGHT --reverse $FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS"
      eval "$FZF_CTRL_T_COMMAND | "(__fzfcmd)' -m --query "'$fzf_query'"' | while read -l r; set result $result $r; end
    end
    if [ -z "$result" ]
      commandline -f repaint
      return
    else
      # Remove last token from commandline.
      commandline -t ""
    end
    for i in $result
      commandline -it -- (string escape $i)
      commandline -it -- ' '
    end
    commandline -f repaint
  ...
10	10	-------> function fzf-history-widget -d "Show command history"
    test -n "$FZF_TMUX_HEIGHT"; or set FZF_TMUX_HEIGHT 40%
    begin
      set -lx FZF_DEFAULT_OPTS "--height $FZF_TMUX_HEIGHT $FZF_DEFAULT_OPTS --tiebreak=index --bind=ctrl-r:toggle-sort $FZF_CTRL_R_OPTS +m"

      set -l FISH_MAJOR (echo $version | cut -f1 -d.)
      set -l FISH_MINOR (echo $version | cut -f2 -d.)

      # history's -z flag is needed for multi-line support.
      # history's -z flag was added in fish 2.4.0, so don't use it for versions
      # before 2.4.0.
      if [ "$FISH_MAJOR" -gt 2 -o \( "$FISH_MAJOR" -eq 2 -a "$FISH_MINOR" -ge 4 \) ];
        history -z | eval (__fzfcmd) --read0 --print0 -q '(commandline)' | read -lz result
        and commandline -- $result
      else
        history | eval (__fzfcmd) -q '(commandline)' | read -l result
        and commandline -- $result
      end
    end
    commandline -f repaint
  ...
7	7	-------> function fzf-cd-widget -d "Change directory"
    set -l commandline (__fzf_parse_commandline)
    set -l dir $commandline[1]
    set -l fzf_query $commandline[2]

    test -n "$FZF_ALT_C_COMMAND"; or set -l FZF_ALT_C_COMMAND "
    command find -L \$dir -mindepth 1 \\( -path \$dir'*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \\) -prune \
    -o -type d -print 2> /dev/null | sed 's@^\./@@'"
    test -n "$FZF_TMUX_HEIGHT"; or set FZF_TMUX_HEIGHT 40%
    begin
      set -lx FZF_DEFAULT_OPTS "--height $FZF_TMUX_HEIGHT --reverse $FZF_DEFAULT_OPTS $FZF_ALT_C_OPTS"
      eval "$FZF_ALT_C_COMMAND | "(__fzfcmd)' +m --query "'$fzf_query'"' | read -l result

      if [ -n "$result" ]
        cd $result

        # Remove last token from commandline.
        commandline -t ""
      end
    end

    commandline -f repaint
  ...
4	4	-------> function __fzfcmd
    test -n "$FZF_TMUX"; or set FZF_TMUX 0
    test -n "$FZF_TMUX_HEIGHT"; or set FZF_TMUX_HEIGHT 40%
    if [ -n "$FZF_TMUX_OPTS" ]
      echo "fzf-tmux $FZF_TMUX_OPTS -- "
    else if [ $FZF_TMUX -eq 1 ]
      echo "fzf-tmux -d$FZF_TMUX_HEIGHT -- "
    else
      echo "fzf"
    end
  ...
58	58	-------> bind \ct fzf-file-widget
37	37	-------> bind \cr fzf-history-widget
34	34	-------> bind \ec fzf-cd-widget
16	299	-------> if bind -M insert > /dev/null 2>&1
    bind -M insert \ct fzf-file-widget
    bind -M insert \cr fzf-history-widget
    bind -M insert \ec fzf-cd-widget
  ...
169	169	--------> bind -M insert > /dev/null 2>&1
41	41	--------> bind -M insert \ct fzf-file-widget
36	36	--------> bind -M insert \cr fzf-history-widget
37	37	--------> bind -M insert \ec fzf-cd-widget
31	31	-------> function __fzf_parse_commandline -d 'Parse the current command line token and return split of existing filepath and rest of token'
    # eval is used to do shell expansion on paths
    set -l commandline (eval "printf '%s' "(commandline -t))

    if [ -z $commandline ]
      # Default to current directory with no --query
      set dir '.'
      set fzf_query ''
    else
      set dir (__fzf_get_dir $commandline)

      if [ "$dir" = "." -a (string sub -l 1 $commandline) != '.' ]
        # if $dir is "." but commandline is not a relative path, this means no file path found
        set fzf_query $commandline
      else
        # Also remove trailing slash after dir, to "split" input properly
        set fzf_query (string replace -r "^$dir/?" '' "$commandline")
      end
    end

    echo $dir
    echo $fzf_query
  ...
13	13	-------> function __fzf_get_dir -d 'Find the longest existing filepath from input string'
    set dir $argv

    # Strip all trailing slashes. Ignore if $dir is root dir (/)
    if [ (string length $dir) -gt 1 ]
      set dir (string replace -r '/*$' '' $dir)
    end

    # Iteratively check if dir exists and strip tail end of path
    while [ ! -d "$dir" ]
      # If path is absolute, this can keep going until ends up at /
      # If path is relative, this can keep going until entire input is consumed, dirname returns "."
      set dir (dirname "$dir")
    end

    echo $dir
  ...
12	322	--> if not set -q FISH_UNIT_TESTS_RUNNING
        # Enable bracketed paste before every prompt (see __fish_shared_bindings for the bindings).
        # Disable it for unit tests so we don't have to add the sequences to bind.expect
        function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        end

        # Disable BP before every command because that might not support it.
        function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        end

        # Tell the terminal we support BP. Since we are in __f_c_i, the first fish_prompt
        # has already fired.
        __fish_enable_bracketed_paste
    ...
69	69	---> not set -q FISH_UNIT_TESTS_RUNNING
9	9	---> function __fish_enable_bracketed_paste --on-event fish_prompt
            printf "\e[?2004h"
        ...
9	9	---> function __fish_disable_bracketed_paste --on-event fish_preexec --on-event fish_exit
            printf "\e[?2004l"
        ...
33	223	---> __fish_enable_bracketed_paste
190	190	----> printf "\e[?2004h"
5	45	--> if set -q TMUX
        and not set -q FISH_UNIT_TESTS_RUNNING
        function __fish_enable_focus --on-event fish_postexec
            echo -n \e\[\?1004h
        end
        function __fish_disable_focus --on-event fish_preexec
            echo -n \e\[\?1004l
        end
        # Note: Don't call this initially because, even though we're in a fish_prompt event,
        # tmux reacts sooo quickly that we'll still get a sequence before we're prepared for it.
        # So this means that we won't get focus events until you've run at least one command, but that's preferable
        # to always seeing `^[[I` when starting fish.
        # __fish_enable_focus
    ...
40	40	---> set -q TMUX
17	17	--> function __fish_winch_handler --on-signal WINCH -d "Repaint screen when window changes size"
        commandline -f repaint >/dev/null 2>/dev/null
    ...
4	176	--> if test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
        function __update_cwd_osc --on-variable PWD --description 'Notify capable terminals when $PWD changes'
            if status --is-command-substitution || set -q INSIDE_EMACS
                return
            end
            printf \e\]7\;file://%s%s\a $hostname (string escape --style=url $PWD)
        end
        __update_cwd_osc # Run once because we might have already inherited a PWD from an old tab
    ...
108	172	---> test 0"$VTE_VERSION" -ge 3405 -o "$TERM_PROGRAM" = "Apple_Terminal" -a (string match -r '\d+' 0"$TERM_PROGRAM_VERSION") -ge 309
64	64	----> string match -r '\d+' 0"$TERM_PROGRAM_VERSION"
19	5775	--> if not type -q __fish_command_not_found_handler
        # Read the OS/Distro from /etc/os-release.
        # This has a "ID=" line that defines the exact distribution,
        # and an "ID_LIKE=" line that defines what it is derived from or otherwise like.
        # For our purposes, we use both.
        set -l os
        if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        end

        # First check if we are on OpenSUSE since SUSE's handler has no options
        # but the same name and path as Ubuntu's.
        if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        end
    ...
366	2673	---> not type -q __fish_command_not_found_handler
794	812	----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/type.fish
18	18	-----> function type --description 'Print the type of a command'
    # For legacy reasons, no argument simply causes an unsuccessful return.
    set -q argv[1]
    or return 1

    set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
    argparse -n type -x t,p,P $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help type
        return 0
    end

    set -l res 1
    set -l mode normal
    set -l multi no
    set -l selection all
    set -l short no

    # Technically all four of these flags are mutually exclusive. However, we allow -q to be used
    # with the other three because old versions of this function explicitly allowed it by making
    # --quiet have precedence.
    if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    end

    set -q _flag_all
    and set multi yes

    set -q _flag_short
    and set short yes

    set -q _flag_no_functions
    and set selection files

    # Check all possible types for the remaining arguments.
    for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    end

    return $res
...
57	57	----> set -q argv[1]
87	87	----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
82	82	----> argparse -n type -x t,p,P $options -- $argv
3	30	----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	-----> set -q _flag_help
53	53	----> set -l res 1
39	39	----> set -l mode normal
56	56	----> set -l multi no
32	32	----> set -l selection all
27	27	----> set -l short no
27	76	----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	-----> set -q _flag_quiet
26	26	-----> set mode quiet
42	42	----> set -q _flag_all
24	24	----> set -q _flag_short
22	22	----> set -q _flag_no_functions
28	842	----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	-----> set -l found 0
6	442	-----> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	------> test $selection != files
4	192	------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
188	188	-------> functions -q -- $i
4	214	------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
161	210	-------> contains -- $i (builtin -n)
49	49	--------> builtin -n
29	29	-----> set -l paths
6	243	-----> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	------> test $multi != yes
74	209	------> set paths (command -s -- $i)
135	135	-------> command -s -- $i
10	10	-----> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
5	61	-----> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	------> test $found = 0
28	28	------> test $mode != quiet
26	26	----> return $res
26	26	---> set -l os
3	39	---> if test -r /etc/os-release
            set os (string match -r '^ID(?:_LIKE)?\s*=.*' < /etc/os-release | \
            string replace -r '^ID(?:_LIKE)?\s*=(.*)' '$1' | string trim -c '\'"' | string split " ")
        ...
36	36	----> test -r /etc/os-release
20	3018	---> if contains -- suse $os || contains -- sles $os && type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/bin/command-not-found $argv[1]
            end
            # Check for Fedora's handler
        else if test -f /usr/libexec/pk-command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/libexec/pk-command-not-found $argv[1]
            end
            # Check in /usr/lib, this is where modern Ubuntus place this command
        else if test -f /usr/lib/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /usr/lib/command-not-found -- $argv[1]
            end
            # Check for NixOS handler
        else if test -f /run/current-system/sw/bin/command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                /run/current-system/sw/bin/command-not-found $argv
            end
            # Ubuntu Feisty places this command in the regular path instead
        else if type -q command-not-found
            function __fish_command_not_found_handler --on-event fish_command_not_found
                command-not-found -- $argv[1]
            end
            # pkgfile is an optional, but official, package on Arch Linux
            # it ships with example handlers for bash and zsh, so we'll follow that format
        else if type -p -q pkgfile
            function __fish_command_not_found_handler --on-event fish_command_not_found
                set -l __packages (pkgfile --binaries --verbose -- $argv[1] 2>/dev/null)
                if test $status -eq 0
                    printf "%s may be found in the following packages:\n" "$argv[1]"
                    printf "  %s\n" $__packages
                else
                    __fish_default_command_not_found_handler $argv[1]
                end
            end
            # Use standard fish command not found handler otherwise
        else
            function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            end
        ...
38	38	----> contains -- suse $os
33	33	----> contains -- sles $os
27	27	----> test -f /usr/libexec/pk-command-not-found
25	25	----> test -f /usr/lib/command-not-found
25	25	----> test -f /run/current-system/sw/bin/command-not-found
76	1378	----> type -q command-not-found
25	25	-----> set -q argv[1]
43	43	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
60	60	-----> argparse -n type -x t,p,P $options -- $argv
3	28	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	------> set -q _flag_help
31	31	-----> set -l res 1
28	28	-----> set -l mode normal
25	25	-----> set -l multi no
26	26	-----> set -l selection all
24	24	-----> set -l short no
6	54	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	------> set -q _flag_quiet
25	25	------> set mode quiet
23	23	-----> set -q _flag_all
22	22	-----> set -q _flag_short
22	22	-----> set -q _flag_no_functions
30	864	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
26	26	------> set -l found 0
9	443	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
28	28	-------> test $selection != files
3	160	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
157	157	--------> functions -q -- $i
3	246	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
178	243	--------> contains -- $i (builtin -n)
65	65	---------> builtin -n
33	33	------> set -l paths
7	256	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	-------> test $multi != yes
89	220	-------> set paths (command -s -- $i)
131	131	--------> command -s -- $i
12	12	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
6	64	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	-------> test $found = 0
28	28	-------> test $mode != quiet
27	27	-----> return $res
82	1462	----> type -p -q pkgfile
25	25	-----> set -q argv[1]
44	44	-----> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
68	68	-----> argparse -n type -x t,p,P $options -- $argv
3	29	-----> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	------> set -q _flag_help
26	26	-----> set -l res 1
26	26	-----> set -l mode normal
26	26	-----> set -l multi no
26	26	-----> set -l selection all
26	26	-----> set -l short no
7	55	-----> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	------> set -q _flag_quiet
25	25	------> set mode quiet
25	25	-----> set -q _flag_all
22	22	-----> set -q _flag_short
23	23	-----> set -q _flag_no_functions
28	931	-----> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	------> set -l found 0
14	448	------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	-------> test $selection != files
4	182	-------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
178	178	--------> functions -q -- $i
3	222	-------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
169	219	--------> contains -- $i (builtin -n)
50	50	---------> builtin -n
30	30	------> set -l paths
8	318	------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	-------> test $multi != yes
92	282	-------> set paths (command -s -- $i)
190	190	--------> command -s -- $i
13	13	------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
6	66	------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	-------> test $found = 0
28	28	-------> test $mode != quiet
28	28	-----> return $res
10	10	----> function __fish_command_not_found_handler --on-event fish_command_not_found
                __fish_default_command_not_found_handler $argv[1]
            ...
46	46	--> set __fish_initialized 3100
39	39	-> functions -e __fish_on_interactive
112	123	> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_mode_prompt.fish
11	11	-> function fish_mode_prompt --description "Displays the current mode"
    # To reuse the mode indicator use this function instead
    fish_default_mode_prompt
...
42	567	> fish_mode_prompt
245	525	-> fish_default_mode_prompt
187	198	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_default_mode_prompt.fish
11	11	---> function fish_default_mode_prompt --description "Display the default mode for the prompt"
    # Do nothing if not in vi mode
    if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    end
...
8	82	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
91	15335	> fish_prompt
41	41	-> set -l __last_command_exit_status $status
14	100	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
27	27	--> set -g __fish_robbyrussell_functions_defined
6	6	--> function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        ...
3	3	--> function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        ...
3	3	--> function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        ...
3	3	--> function _hg_branch_name
            echo (hg branch 2>/dev/null)
        ...
3	3	--> function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        ...
4	4	--> function _is_hg_repo
            fish_print_hg_root >/dev/null
        ...
3	3	--> function _repo_branch_name
            _$argv[1]_branch_name
        ...
3	3	--> function _is_repo_dirty
            _is_$argv[1]_dirty
        ...
4	4	--> function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        ...
114	308	-> set -l cyan (set_color -o cyan)
194	194	--> set_color -o cyan
108	160	-> set -l yellow (set_color -o yellow)
52	52	--> set_color -o yellow
91	134	-> set -l red (set_color -o red)
43	43	--> set_color -o red
100	153	-> set -l green (set_color -o green)
53	53	--> set_color -o green
99	148	-> set -l blue (set_color -o blue)
49	49	--> set_color -o blue
86	128	-> set -l normal (set_color normal)
42	42	--> set_color normal
33	33	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
46	46	-> set -l arrow "$arrow_color➜ "
4	34	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
30	30	--> test "$USER" = 'root'
117	2755	-> set -l cwd $cyan(basename (prompt_pwd))
1563	2638	--> basename (prompt_pwd)
312	1075	---> prompt_pwd
222	235	----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/prompt_pwd.fish
13	13	-----> function prompt_pwd --description "Print the current working directory, shortened to fit the prompt"
    set -l options 'h/help'
    argparse -n prompt_pwd --max-args=0 $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    end

    # This allows overriding fish_prompt_pwd_dir_length from the outside (global or universal) without leaking it
    set -q fish_prompt_pwd_dir_length
    or set -l fish_prompt_pwd_dir_length 1

    # Replace $HOME with "~"
    set realhome ~
    set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)

    if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    end
...
49	49	----> set -l options 'h/help'
54	54	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	32	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
28	28	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
44	44	----> set realhome ~
125	197	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
72	72	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	96	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
53	53	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	11108	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
107	11104	--> set -l repo_type (_repo_type)
33	10997	---> _repo_type
5	10917	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
27	677	-----> _is_hg_repo
309	650	------> fish_print_hg_root >/dev/null
174	180	-------> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/fish_print_hg_root.fish
6	6	--------> function fish_print_hg_root
    # If hg isn't installed, there's nothing we can do
    if not command -sq hg
        return 1
    end

    # Find an hg directory above $PWD
    # without calling `hg root` because that's too slow
    set -l root
    set -l dir (pwd -P 2>/dev/null)
    or return 1

    while test $dir != "/"
        if test -f $dir'/.hg/dirstate'
            echo $dir/.hg
            return 0
        end
        # Go up one directory
        set dir (string replace -r '[^/]*/?$' '' $dir)
    end

    return 1
...
10	161	-------> if not command -sq hg
        return 1
    ...
123	123	--------> not command -sq hg
28	28	--------> return 1
44	10235	-----> _is_git_repo
83	1531	------> type -q git
27	27	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
65	65	-------> argparse -n type -x t,p,P $options -- $argv
9	35	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
27	27	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
23	23	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
26	948	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
8	456	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
29	29	---------> test $selection != files
4	150	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
146	146	----------> functions -q -- $i
5	269	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
215	264	----------> contains -- $i (builtin -n)
49	49	-----------> builtin -n
30	30	--------> set -l paths
8	238	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
96	201	---------> set paths (command -s -- $i)
105	105	----------> command -s -- $i
21	141	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
9	9	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	57	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
23	23	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
72	72	-------> return $res
8660	8660	------> git rev-parse --git-dir >/dev/null 2>&1
47	47	----> return 1
62	62	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
57	1936	> fish_right_prompt
93	93	-> set_color $fish_color_autosuggestion 2> /dev/null
1728	1728	-> date "+%H:%M:%S"
58	58	-> set_color normal
37	337	> fish_title
9	300	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
154	261	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
41	76	---> __fish_pwd
35	35	----> pwd
361	2740	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/cat.fish
42	2379	-> if cat --version 2>/dev/null >/dev/null # GNU
    complete -c cat -s A -l show-all -d "Escape all unprintables"
    complete -c cat -s b -l number-nonblank -d "Number non-blank lines"
    complete -c cat -s e -d "Escape unprintables except \\t"
    complete -c cat -s E -l show-ends -d "Display \$ at line end"
    complete -c cat -s n -l number -d "Enumerate lines"
    complete -c cat -s s -l squeeze-blank -d "Never >1 blank line"
    complete -c cat -s t -d "Escape unprintables except \\n"
    complete -c cat -s T -l show-tabs -d "Escape tab"
    complete -c cat -s v -d "Escape unprintables except '\\n' and \\t"
    complete -c cat -l help -d "Display help and exit"
    complete -c cat -l version -d "Display version and exit"
else # OS X
    complete -c cat -s b -d "Specify # of non-blank lines"
    complete -c cat -s e -d "Show unprintables, end lines with \$"
    complete -c cat -s n -d "Enumerate lines"
    complete -c cat -s s -d "Squeeze away >1 blank lines"
    complete -c cat -s t -d "Show unprintables; tab as '^I'"
    complete -c cat -s u -d "Disable output buffering"
    complete -c cat -s v -d "Escape non-printing chars"
...
2007	2007	--> cat --version 2>/dev/null >/dev/null
80	80	--> complete -c cat -s b -d "Specify # of non-blank lines"
46	46	--> complete -c cat -s e -d "Show unprintables, end lines with \$"
42	42	--> complete -c cat -s n -d "Enumerate lines"
42	42	--> complete -c cat -s s -d "Squeeze away >1 blank lines"
40	40	--> complete -c cat -s t -d "Show unprintables; tab as '^I'"
40	40	--> complete -c cat -s u -d "Disable output buffering"
40	40	--> complete -c cat -s v -d "Escape non-printing chars"
80	158	> __fish_disable_bracketed_paste 'cat profile.txt '
78	78	-> printf "\e[?2004l"
99	698	> fish_title cat\ profile.txt\ 
17	599	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
45	45	--> not set -q INSIDE_EMACS
322	537	--> echo (status current-command) (__fish_pwd)
81	81	---> status current-command
77	134	---> __fish_pwd
57	57	----> pwd
56995	56995	> cat profile.txt
43	103	> __fish_enable_bracketed_paste
60	60	-> printf "\e[?2004h"
41	211	> fish_mode_prompt
49	170	-> fish_default_mode_prompt
10	121	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
69	69	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
122	14215	> fish_prompt
43	43	-> set -l __last_command_exit_status $status
3	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
114	169	-> set -l cyan (set_color -o cyan)
55	55	--> set_color -o cyan
161	211	-> set -l yellow (set_color -o yellow)
50	50	--> set_color -o yellow
108	167	-> set -l red (set_color -o red)
59	59	--> set_color -o red
95	140	-> set -l green (set_color -o green)
45	45	--> set_color -o green
90	134	-> set -l blue (set_color -o blue)
44	44	--> set_color -o blue
120	161	-> set -l normal (set_color normal)
41	41	--> set_color normal
43	43	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
35	35	-> set -l arrow "$arrow_color➜ "
3	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
123	2092	-> set -l cwd $cyan(basename (prompt_pwd))
1446	1969	--> basename (prompt_pwd)
69	523	---> prompt_pwd
35	35	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	28	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
97	172	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
75	75	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
7	95	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
56	56	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	10727	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
109	10723	--> set -l repo_type (_repo_type)
70	10614	---> _repo_type
9	10491	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
33	269	-----> _is_hg_repo
76	236	------> fish_print_hg_root >/dev/null
10	160	-------> if not command -sq hg
        return 1
    ...
123	123	--------> not command -sq hg
27	27	--------> return 1
46	10213	-----> _is_git_repo
91	1361	------> type -q git
26	26	-------> set -q argv[1]
44	44	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
64	64	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
8	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
30	822	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
19	327	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	53	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
49	49	----------> functions -q -- $i
5	225	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
170	220	----------> contains -- $i (builtin -n)
50	50	-----------> builtin -n
30	30	--------> set -l paths
8	235	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
96	198	---------> set paths (command -s -- $i)
102	102	----------> command -s -- $i
21	141	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	56	---------> if test $multi != yes
                continue
            ...
27	27	----------> test $multi != yes
22	22	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
8806	8806	------> git rev-parse --git-dir >/dev/null 2>&1
53	53	----> return 1
70	70	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
60	1789	> fish_right_prompt
84	84	-> set_color $fish_color_autosuggestion 2> /dev/null
1584	1584	-> date "+%H:%M:%S"
61	61	-> set_color normal
40	408	> fish_title
10	368	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
200	329	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
57	98	---> __fish_pwd
41	41	----> pwd
89	467	> __fish_winch_handler SIGWINCH
378	378	-> commandline -f repaint >/dev/null 2>/dev/null
61	664	> fish_mode_prompt
59	603	-> fish_default_mode_prompt
277	544	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-24	211	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
86	235	----> __fish_winch_handler SIGWINCH
149	149	-----> commandline -f repaint >/dev/null 2>/dev/null
56	56	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
232	18268	> fish_prompt
109	109	-> set -l __last_command_exit_status $status
10	75	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
65	65	--> not set -q -g __fish_robbyrussell_functions_defined
244	326	-> set -l cyan (set_color -o cyan)
82	82	--> set_color -o cyan
165	227	-> set -l yellow (set_color -o yellow)
62	62	--> set_color -o yellow
198	277	-> set -l red (set_color -o red)
79	79	--> set_color -o red
181	276	-> set -l green (set_color -o green)
95	95	--> set_color -o green
223	326	-> set -l blue (set_color -o blue)
103	103	--> set_color -o blue
277	446	-> set -l normal (set_color normal)
169	169	--> set_color normal
210	210	-> set -l arrow_color "$green"
8	99	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
91	91	--> test $__last_command_exit_status != 0
55	55	-> set -l arrow "$arrow_color➜ "
5	45	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
40	40	--> test "$USER" = 'root'
187	2630	-> set -l cwd $cyan(basename (prompt_pwd))
1763	2443	--> basename (prompt_pwd)
82	680	---> prompt_pwd
43	43	----> set -l options 'h/help'
50	50	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	37	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
32	32	-----> set -q _flag_help
31	31	----> set -q fish_prompt_pwd_dir_length
35	35	----> set -l fish_prompt_pwd_dir_length 1
42	42	----> set realhome ~
142	231	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
89	89	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	129	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
44	44	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
74	74	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	12868	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
137	12863	--> set -l repo_type (_repo_type)
41	12726	---> _repo_type
9	12636	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
45	301	-----> _is_hg_repo
79	256	------> fish_print_hg_root >/dev/null
10	177	-------> if not command -sq hg
        return 1
    ...
137	137	--------> not command -sq hg
30	30	--------> return 1
47	12326	-----> _is_git_repo
96	1637	------> type -q git
29	29	-------> set -q argv[1]
51	51	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
71	71	-------> argparse -n type -x t,p,P $options -- $argv
5	33	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
28	28	--------> set -q _flag_help
29	29	-------> set -l res 1
29	29	-------> set -l mode normal
30	30	-------> set -l multi no
29	29	-------> set -l selection all
29	29	-------> set -l short no
9	64	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
29	29	--------> set mode quiet
27	27	-------> set -q _flag_all
26	26	-------> set -q _flag_short
25	25	-------> set -q _flag_no_functions
45	1038	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
30	30	--------> set -l found 0
15	400	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
33	33	---------> test $selection != files
4	61	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
57	57	----------> functions -q -- $i
7	291	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
230	284	----------> contains -- $i (builtin -n)
54	54	-----------> builtin -n
37	37	--------> set -l paths
13	322	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
34	34	---------> test $multi != yes
148	275	---------> set paths (command -s -- $i)
127	127	----------> command -s -- $i
26	168	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
34	34	---------> set res 0
30	30	---------> set found 1
12	12	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	66	---------> if test $multi != yes
                continue
            ...
32	32	----------> test $multi != yes
25	25	----------> continue
5	36	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	---------> test $found = 0
31	31	-------> return $res
10642	10642	------> git rev-parse --git-dir >/dev/null 2>&1
49	49	----> return 1
67	67	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
62	2025	> fish_right_prompt
84	84	-> set_color $fish_color_autosuggestion 2> /dev/null
1811	1811	-> date "+%H:%M:%S"
68	68	-> set_color normal
40	460	> fish_title
11	420	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
249	380	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
58	99	---> __fish_pwd
41	41	----> pwd
62	178	> __fish_winch_handler SIGWINCH
116	116	-> commandline -f repaint >/dev/null 2>/dev/null
38	335	> fish_mode_prompt
40	297	-> fish_default_mode_prompt
179	257	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-113	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
65	156	----> __fish_winch_handler SIGWINCH
91	91	-----> commandline -f repaint >/dev/null 2>/dev/null
35	35	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
144	15366	> fish_prompt
40	40	-> set -l __last_command_exit_status $status
4	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
26	26	--> not set -q -g __fish_robbyrussell_functions_defined
174	272	-> set -l cyan (set_color -o cyan)
98	98	--> set_color -o cyan
117	170	-> set -l yellow (set_color -o yellow)
53	53	--> set_color -o yellow
90	136	-> set -l red (set_color -o red)
46	46	--> set_color -o red
89	133	-> set -l green (set_color -o green)
44	44	--> set_color -o green
91	135	-> set -l blue (set_color -o blue)
44	44	--> set_color -o blue
94	136	-> set -l normal (set_color normal)
42	42	--> set_color normal
33	33	-> set -l arrow_color "$green"
3	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
4	33	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
29	29	--> test "$USER" = 'root'
147	2244	-> set -l cwd $cyan(basename (prompt_pwd))
1570	2097	--> basename (prompt_pwd)
72	527	---> prompt_pwd
36	36	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
28	28	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
99	169	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
70	70	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	93	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
54	54	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	11729	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
137	11724	--> set -l repo_type (_repo_type)
34	11587	---> _repo_type
8	11503	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
25	259	-----> _is_hg_repo
73	234	------> fish_print_hg_root >/dev/null
10	161	-------> if not command -sq hg
        return 1
    ...
124	124	--------> not command -sq hg
27	27	--------> return 1
44	11236	-----> _is_git_repo
96	1621	------> type -q git
30	30	-------> set -q argv[1]
51	51	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
65	65	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
27	27	-------> set -l selection all
26	26	-------> set -l short no
8	58	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
26	26	--------> set mode quiet
25	25	-------> set -q _flag_all
27	27	-------> set -q _flag_short
30	30	-------> set -q _flag_no_functions
53	1047	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
13	367	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
3	65	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
62	62	----------> functions -q -- $i
5	257	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
200	252	----------> contains -- $i (builtin -n)
52	52	-----------> builtin -n
31	31	--------> set -l paths
11	327	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
164	287	---------> set paths (command -s -- $i)
123	123	----------> command -s -- $i
35	205	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
61	61	---------> set res 0
31	31	---------> set found 1
13	13	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	65	---------> if test $multi != yes
                continue
            ...
32	32	----------> test $multi != yes
25	25	----------> continue
5	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
29	29	-------> return $res
9571	9571	------> git rev-parse --git-dir >/dev/null 2>&1
50	50	----> return 1
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
74	2724	> fish_right_prompt
90	90	-> set_color $fish_color_autosuggestion 2> /dev/null
2487	2487	-> date "+%H:%M:%S"
73	73	-> set_color normal
43	496	> fish_title
10	453	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
243	413	--> echo (status current-command) (__fish_pwd)
66	66	---> status current-command
66	104	---> __fish_pwd
38	38	----> pwd
102	486	> __fish_disable_bracketed_paste clear
384	384	-> printf "\e[?2004l"
72	1024	> fish_title clear
16	952	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
43	43	--> not set -q INSIDE_EMACS
422	893	--> echo (status current-command) (__fish_pwd)
50	50	---> status current-command
214	421	---> __fish_pwd
207	207	----> pwd
4660	4660	> clear
51	114	> __fish_enable_bracketed_paste
63	63	-> printf "\e[?2004h"
63	453	> fish_mode_prompt
290	390	-> fish_default_mode_prompt
10	100	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
52	52	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
111	29277	> fish_prompt
47	47	-> set -l __last_command_exit_status $status
5	36	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
129	320	-> set -l cyan (set_color -o cyan)
191	191	--> set_color -o cyan
116	176	-> set -l yellow (set_color -o yellow)
60	60	--> set_color -o yellow
110	164	-> set -l red (set_color -o red)
54	54	--> set_color -o red
106	164	-> set -l green (set_color -o green)
58	58	--> set_color -o green
107	157	-> set -l blue (set_color -o blue)
50	50	--> set_color -o blue
106	156	-> set -l normal (set_color normal)
50	50	--> set_color normal
39	39	-> set -l arrow_color "$green"
4	37	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
33	33	--> test $__last_command_exit_status != 0
36	36	-> set -l arrow "$arrow_color➜ "
4	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
166	3428	-> set -l cwd $cyan(basename (prompt_pwd))
2247	3262	--> basename (prompt_pwd)
240	1015	---> prompt_pwd
42	42	----> set -l options 'h/help'
44	44	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	33	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
27	27	----> set -q fish_prompt_pwd_dir_length
88	88	----> set -l fish_prompt_pwd_dir_length 1
67	67	----> set realhome ~
125	359	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
234	234	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	115	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
38	38	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
66	66	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	24300	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
155	24295	--> set -l repo_type (_repo_type)
59	24140	---> _repo_type
7	24027	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
69	567	-----> _is_hg_repo
277	498	------> fish_print_hg_root >/dev/null
12	221	-------> if not command -sq hg
        return 1
    ...
177	177	--------> not command -sq hg
32	32	--------> return 1
71	23453	-----> _is_git_repo
206	2053	------> type -q git
27	27	-------> set -q argv[1]
46	46	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
61	61	-------> argparse -n type -x t,p,P $options -- $argv
4	51	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
47	47	--------> set -q _flag_help
84	84	-------> set -l res 1
65	65	-------> set -l mode normal
29	29	-------> set -l multi no
27	27	-------> set -l selection all
25	25	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
29	1277	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
20	734	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
29	29	---------> test $selection != files
4	261	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
257	257	----------> functions -q -- $i
6	424	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
349	418	----------> contains -- $i (builtin -n)
69	69	-----------> builtin -n
32	32	--------> set -l paths
9	241	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
98	203	---------> set paths (command -s -- $i)
105	105	----------> command -s -- $i
22	183	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
26	95	---------> if test $multi != yes
                continue
            ...
31	31	----------> test $multi != yes
38	38	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
21329	21329	------> git rev-parse --git-dir >/dev/null 2>&1
54	54	----> return 1
66	66	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
75	2160	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
1913	1913	-> date "+%H:%M:%S"
81	81	-> set_color normal
76	458	> fish_title
13	382	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
57	57	--> not set -q INSIDE_EMACS
190	312	--> echo (status current-command) (__fish_pwd)
40	40	---> status current-command
46	82	---> __fish_pwd
36	36	----> pwd
59	136	> __fish_disable_bracketed_paste clear
77	77	-> printf "\e[?2004l"
63	622	> fish_title clear
15	559	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
43	43	--> not set -q INSIDE_EMACS
327	501	--> echo (status current-command) (__fish_pwd)
52	52	---> status current-command
68	122	---> __fish_pwd
54	54	----> pwd
3559	3559	> clear
73	145	> __fish_enable_bracketed_paste
72	72	-> printf "\e[?2004h"
67	279	> fish_mode_prompt
72	212	-> fish_default_mode_prompt
11	140	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
85	85	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
44	44	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
171	17190	> fish_prompt
96	96	-> set -l __last_command_exit_status $status
7	83	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
76	76	--> not set -q -g __fish_robbyrussell_functions_defined
204	298	-> set -l cyan (set_color -o cyan)
94	94	--> set_color -o cyan
141	202	-> set -l yellow (set_color -o yellow)
61	61	--> set_color -o yellow
119	179	-> set -l red (set_color -o red)
60	60	--> set_color -o red
172	314	-> set -l green (set_color -o green)
142	142	--> set_color -o green
140	201	-> set -l blue (set_color -o blue)
61	61	--> set_color -o blue
226	290	-> set -l normal (set_color normal)
64	64	--> set_color normal
77	77	-> set -l arrow_color "$green"
5	50	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
45	45	--> test $__last_command_exit_status != 0
49	49	-> set -l arrow "$arrow_color➜ "
5	49	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
44	44	--> test "$USER" = 'root'
197	2959	-> set -l cwd $cyan(basename (prompt_pwd))
1706	2762	--> basename (prompt_pwd)
123	1056	---> prompt_pwd
86	86	----> set -l options 'h/help'
84	84	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	42	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
36	36	-----> set -q _flag_help
34	34	----> set -q fish_prompt_pwd_dir_length
57	57	----> set -l fish_prompt_pwd_dir_length 1
105	105	----> set realhome ~
273	403	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
130	130	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	122	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
41	41	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
69	69	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	12105	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
113	12100	--> set -l repo_type (_repo_type)
37	11987	---> _repo_type
7	11901	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
32	333	-----> _is_hg_repo
95	301	------> fish_print_hg_root >/dev/null
12	206	-------> if not command -sq hg
        return 1
    ...
133	133	--------> not command -sq hg
61	61	--------> return 1
98	11561	-----> _is_git_repo
130	1858	------> type -q git
31	31	-------> set -q argv[1]
56	56	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
76	76	-------> argparse -n type -x t,p,P $options -- $argv
4	34	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
30	30	--------> set -q _flag_help
29	29	-------> set -l res 1
29	29	-------> set -l mode normal
30	30	-------> set -l multi no
29	29	-------> set -l selection all
42	42	-------> set -l short no
14	174	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
34	34	--------> set -q _flag_quiet
126	126	--------> set mode quiet
52	52	-------> set -q _flag_all
61	61	-------> set -q _flag_short
34	34	-------> set -q _flag_no_functions
62	1020	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
34	34	--------> set -l found 0
22	395	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
35	35	---------> test $selection != files
4	58	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
54	54	----------> functions -q -- $i
5	280	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
216	275	----------> contains -- $i (builtin -n)
59	59	-----------> builtin -n
33	33	--------> set -l paths
10	302	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
40	40	---------> test $multi != yes
121	252	---------> set paths (command -s -- $i)
131	131	----------> command -s -- $i
23	160	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
30	30	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	64	---------> if test $multi != yes
                continue
            ...
31	31	----------> test $multi != yes
25	25	----------> continue
5	34	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
29	29	---------> test $found = 0
31	31	-------> return $res
9605	9605	------> git rev-parse --git-dir >/dev/null 2>&1
49	49	----> return 1
67	67	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
64	1994	> fish_right_prompt
85	85	-> set_color $fish_color_autosuggestion 2> /dev/null
1780	1780	-> date "+%H:%M:%S"
65	65	-> set_color normal
39	393	> fish_title
9	354	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
192	316	--> echo (status current-command) (__fish_pwd)
41	41	---> status current-command
46	83	---> __fish_pwd
37	37	----> pwd
59	133	> __fish_disable_bracketed_paste ls
74	74	-> printf "\e[?2004l"
61	620	> fish_title ls
16	559	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
42	42	--> not set -q INSIDE_EMACS
317	501	--> echo (status current-command) (__fish_pwd)
48	48	---> status current-command
79	136	---> __fish_pwd
57	57	----> pwd
212	18399	> ls
1013	8808	-> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/ls.fish
45	7795	--> for opt in --color=auto -G --color -F
    if command ls $opt / >/dev/null 2>/dev/null

        function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        end

        if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        end

        break
    end
...
20	4845	---> if command ls $opt / >/dev/null 2>/dev/null

        function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        end

        if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        end

        break
    ...
4825	4825	----> command ls $opt / >/dev/null 2>/dev/null
36	2905	---> if command ls $opt / >/dev/null 2>/dev/null

        function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        end

        if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        end

        break
    ...
2746	2746	----> command ls $opt / >/dev/null 2>/dev/null
32	32	----> function ls --description "List contents of directory" -V opt
            isatty stdout
            and set -a opt -F
            command ls $opt $argv
        ...
7	62	----> if [ $opt = --color=auto ] && ! set -qx LS_COLORS && set -l cmd (command -s {g,}dircolors)[1]
            set -l colorfile
            for file in ~/.dir_colors ~/.dircolors /etc/DIR_COLORS
                if test -f $file
                    set colorfile $file
                    break
                end
            end
            # Here we rely on the legacy behavior of `dircolors -c` producing output
            # suitable for csh in order to extract just the data we're interested in.
            set -gx LS_COLORS ($cmd -c $colorfile | string split ' ')[3]
            # The value should always be quoted but be conservative and check first.
            if string match -qr '^([\'"]).*\1$' -- $LS_COLORS
                set LS_COLORS (string match -r '^.(.*).$' $LS_COLORS)[2]
            end
        ...
55	55	-----> [ $opt = --color=auto ]
29	29	----> break
360	6409	-> isatty stdout
700	714	--> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/isatty.fish
14	14	---> function isatty -d "Tests if a file descriptor is a tty"
    set -l options 'h/help'
    argparse -n isatty $options -- $argv
    or return

    if set -q _flag_help
        __fish_print_help isatty
        return 0
    end

    if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    end

    set -l fd
    switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    end

    # Use `command test` because `builtin test` doesn't open the regular fd's.
    # See https://github.com/fish-shell/fish-shell/issues/1228
    # Too often `command test` is some bogus Go binary, I don't know why. Use [ because
    # it's less likely to be something surprising. See #5665
    command [ -t "$fd" ]
...
80	80	--> set -l options 'h/help'
62	62	--> argparse -n isatty $options -- $argv
7	38	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
31	31	---> set -q _flag_help
6	34	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
28	28	---> set -q argv[2]
29	29	--> set -l fd
19	48	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
29	29	---> set fd 1
5044	5044	--> command [ -t "$fd" ]
56	56	-> set -a opt -F
2914	2914	-> command ls $opt $argv
40	171	> __fish_enable_bracketed_paste
131	131	-> printf "\e[?2004h"
47	176	> fish_mode_prompt
47	129	-> fish_default_mode_prompt
8	82	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
95	14846	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
113	166	-> set -l cyan (set_color -o cyan)
53	53	--> set_color -o cyan
112	166	-> set -l yellow (set_color -o yellow)
54	54	--> set_color -o yellow
99	144	-> set -l red (set_color -o red)
45	45	--> set_color -o red
96	139	-> set -l green (set_color -o green)
43	43	--> set_color -o green
88	130	-> set -l blue (set_color -o blue)
42	42	--> set_color -o blue
86	126	-> set -l normal (set_color normal)
40	40	--> set_color normal
33	33	-> set -l arrow_color "$green"
4	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
29	29	--> test $__last_command_exit_status != 0
32	32	-> set -l arrow "$arrow_color➜ "
3	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
154	2040	-> set -l cwd $cyan(basename (prompt_pwd))
1361	1886	--> basename (prompt_pwd)
63	525	---> prompt_pwd
33	33	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	28	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
24	24	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
105	178	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
73	73	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	100	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
60	60	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	11569	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
111	11565	--> set -l repo_type (_repo_type)
40	11454	---> _repo_type
5	11366	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	269	-----> _is_hg_repo
76	243	------> fish_print_hg_root >/dev/null
10	167	-------> if not command -sq hg
        return 1
    ...
127	127	--------> not command -sq hg
30	30	--------> return 1
51	11092	-----> _is_git_repo
92	1574	------> type -q git
26	26	-------> set -q argv[1]
67	67	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
69	69	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
27	27	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
12	112	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
67	67	--------> set -q _flag_quiet
33	33	--------> set mode quiet
28	28	-------> set -q _flag_all
24	24	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
42	946	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
18	383	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
31	31	---------> test $selection != files
3	52	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
49	49	----------> functions -q -- $i
4	282	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
220	278	----------> contains -- $i (builtin -n)
58	58	-----------> builtin -n
31	31	--------> set -l paths
10	274	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
122	235	---------> set paths (command -s -- $i)
113	113	----------> command -s -- $i
27	155	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
10	61	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
22	22	----------> continue
3	33	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	---------> test $found = 0
28	28	-------> return $res
9467	9467	------> git rev-parse --git-dir >/dev/null 2>&1
48	48	----> return 1
71	71	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
59	1882	> fish_right_prompt
84	84	-> set_color $fish_color_autosuggestion 2> /dev/null
1674	1674	-> date "+%H:%M:%S"
65	65	-> set_color normal
41	342	> fish_title
8	301	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
152	263	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
43	79	---> __fish_pwd
36	36	----> pwd
702	7668	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/rm.fish
69	6966	-> if rm --version >/dev/null 2>/dev/null # GNU
    complete -c rm -s d -l directory -d "Unlink directories"
    complete -c rm -s f -l force -d "Never prompt for removal"
    complete -c rm -s i -l interactive -d "Prompt for removal"
    complete -c rm -s I -d "Prompt to remove >3 files"
    complete -c rm -s r -l recursive -d "Recursively remove subdirs"
    complete -c rm -s R -d "Recursively remove subdirs"
    complete -c rm -s v -l verbose -d "Explain what is done"
    complete -c rm -s h -l help -d "Display help"
    complete -c rm -l version -d "Display rm version"
else
    set -l uname (uname -s)
    # solaris:   rm [-fi        ] file ...
    # openbsd:   rm [-fidPRrv   ] file ...
    # macos:     rm [-fidPRrvW  ] file ...
    # netbsd:    rm [-fidPRrvWx ] file ...
    # freebsd:   rm [-fidPRrvWxI] file ...
    # dragonfly: rm [-fidPRrvWxI] file ... 

    complete -c rm -s f -d "Never prompt for removal"
    complete -c rm -s i -d "Prompt for removal"
    test "$uname" = SunOS
    and exit 0
    complete -c rm -s d -d "Remove directories as well"
    complete -c rm -s P -d "Overwrite before removal"
    complete -c rm -s R -s r -d "Recursively remove subdirs"
    complete -c rm -s v -d "Explain what is done"
    test "$uname" = OpenBSD
    and exit 0
    complete -c rm -s W -d "Undelete given filenames"
    test "$uname" = Darwin
    and exit 0
    complete -c rm -s x -d "Don't traverse mount points"
    test "$uname" = NetBSD
    and exit 0
    complete -c rm -s I -d "Prompt to remove >=3 files"
...
3294	3294	--> rm --version >/dev/null 2>/dev/null
201	2722	--> set -l uname (uname -s)
2521	2521	---> uname -s
203	203	--> complete -c rm -s f -d "Never prompt for removal"
50	50	--> complete -c rm -s i -d "Prompt for removal"
36	36	--> test "$uname" = SunOS
48	48	--> complete -c rm -s d -d "Remove directories as well"
41	41	--> complete -c rm -s P -d "Overwrite before removal"
66	66	--> complete -c rm -s R -s r -d "Recursively remove subdirs"
42	42	--> complete -c rm -s v -d "Explain what is done"
33	33	--> test "$uname" = OpenBSD
40	40	--> complete -c rm -s W -d "Undelete given filenames"
32	32	--> test "$uname" = Darwin
290	290	--> exit 0
115	304	> __fish_disable_bracketed_paste 'rm -rf profile.txt '
189	189	-> printf "\e[?2004l"
168	1166	> fish_title rm\ -rf\ profile.txt\ 
27	998	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
138	138	--> not set -q INSIDE_EMACS
465	833	--> echo (status current-command) (__fish_pwd)
118	118	---> status current-command
170	250	---> __fish_pwd
80	80	----> pwd
4738	4738	> rm -rf profile.txt
119	200	> __fish_enable_bracketed_paste
81	81	-> printf "\e[?2004h"
66	236	> fish_mode_prompt
63	170	-> fish_default_mode_prompt
12	107	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
54	54	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
41	41	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
187	18451	> fish_prompt
122	122	-> set -l __last_command_exit_status $status
9	118	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
109	109	--> not set -q -g __fish_robbyrussell_functions_defined
168	262	-> set -l cyan (set_color -o cyan)
94	94	--> set_color -o cyan
265	329	-> set -l yellow (set_color -o yellow)
64	64	--> set_color -o yellow
183	344	-> set -l red (set_color -o red)
161	161	--> set_color -o red
237	456	-> set -l green (set_color -o green)
219	219	--> set_color -o green
239	324	-> set -l blue (set_color -o blue)
85	85	--> set_color -o blue
220	365	-> set -l normal (set_color normal)
145	145	--> set_color normal
47	47	-> set -l arrow_color "$green"
5	44	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
39	39	--> test $__last_command_exit_status != 0
48	48	-> set -l arrow "$arrow_color➜ "
5	46	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
41	41	--> test "$USER" = 'root'
146	2609	-> set -l cwd $cyan(basename (prompt_pwd))
1542	2463	--> basename (prompt_pwd)
98	921	---> prompt_pwd
48	48	----> set -l options 'h/help'
52	52	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	37	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
32	32	-----> set -q _flag_help
31	31	----> set -q fish_prompt_pwd_dir_length
35	35	----> set -l fish_prompt_pwd_dir_length 1
106	106	----> set realhome ~
233	382	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
149	149	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	132	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
49	49	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
71	71	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	13082	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
136	13078	--> set -l repo_type (_repo_type)
38	12942	---> _repo_type
20	12853	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
30	305	-----> _is_hg_repo
82	275	------> fish_print_hg_root >/dev/null
11	193	-------> if not command -sq hg
        return 1
    ...
152	152	--------> not command -sq hg
30	30	--------> return 1
61	12528	-----> _is_git_repo
96	1564	------> type -q git
30	30	-------> set -q argv[1]
55	55	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
77	77	-------> argparse -n type -x t,p,P $options -- $argv
5	34	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
29	29	--------> set -q _flag_help
29	29	-------> set -l res 1
28	28	-------> set -l mode normal
29	29	-------> set -l multi no
29	29	-------> set -l selection all
29	29	-------> set -l short no
9	63	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
28	28	--------> set mode quiet
26	26	-------> set -q _flag_all
26	26	-------> set -q _flag_short
26	26	-------> set -q _flag_no_functions
32	956	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
30	30	--------> set -l found 0
20	393	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
33	33	---------> test $selection != files
5	61	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
56	56	----------> functions -q -- $i
4	279	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
211	275	----------> contains -- $i (builtin -n)
64	64	-----------> builtin -n
33	33	--------> set -l paths
10	276	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
33	33	---------> test $multi != yes
118	233	---------> set paths (command -s -- $i)
115	115	----------> command -s -- $i
22	158	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
29	29	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	64	---------> if test $multi != yes
                continue
            ...
31	31	----------> test $multi != yes
25	25	----------> continue
5	34	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
29	29	---------> test $found = 0
31	31	-------> return $res
10903	10903	------> git rev-parse --git-dir >/dev/null 2>&1
51	51	----> return 1
68	68	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
64	2008	> fish_right_prompt
86	86	-> set_color $fish_color_autosuggestion 2> /dev/null
1792	1792	-> date "+%H:%M:%S"
66	66	-> set_color normal
48	449	> fish_title
11	401	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
228	357	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
52	96	---> __fish_pwd
44	44	----> pwd
72	142	> __fish_disable_bracketed_paste clear
70	70	-> printf "\e[?2004l"
57	481	> fish_title clear
12	424	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
39	39	--> not set -q INSIDE_EMACS
224	373	--> echo (status current-command) (__fish_pwd)
43	43	---> status current-command
59	106	---> __fish_pwd
47	47	----> pwd
3471	3471	> clear
79	145	> __fish_enable_bracketed_paste
66	66	-> printf "\e[?2004h"
91	245	> fish_mode_prompt
57	154	-> fish_default_mode_prompt
10	97	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
49	49	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
123	15303	> fish_prompt
41	41	-> set -l __last_command_exit_status $status
4	36	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
32	32	--> not set -q -g __fish_robbyrussell_functions_defined
137	201	-> set -l cyan (set_color -o cyan)
64	64	--> set_color -o cyan
132	186	-> set -l yellow (set_color -o yellow)
54	54	--> set_color -o yellow
125	182	-> set -l red (set_color -o red)
57	57	--> set_color -o red
129	181	-> set -l green (set_color -o green)
52	52	--> set_color -o green
117	174	-> set -l blue (set_color -o blue)
57	57	--> set_color -o blue
106	155	-> set -l normal (set_color normal)
49	49	--> set_color normal
37	37	-> set -l arrow_color "$green"
4	37	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
33	33	--> test $__last_command_exit_status != 0
37	37	-> set -l arrow "$arrow_color➜ "
4	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
159	2502	-> set -l cwd $cyan(basename (prompt_pwd))
1706	2343	--> basename (prompt_pwd)
74	637	---> prompt_pwd
40	40	----> set -l options 'h/help'
45	45	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	33	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
28	28	-----> set -q _flag_help
27	27	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
36	36	----> set realhome ~
145	230	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
85	85	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	122	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
40	40	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
70	70	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
6	11236	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
136	11230	--> set -l repo_type (_repo_type)
50	11094	---> _repo_type
9	10971	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	267	-----> _is_hg_repo
76	241	------> fish_print_hg_root >/dev/null
10	165	-------> if not command -sq hg
        return 1
    ...
128	128	--------> not command -sq hg
27	27	--------> return 1
50	10695	-----> _is_git_repo
91	1420	------> type -q git
26	26	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
67	67	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
7	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
26	26	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
29	879	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
17	367	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	52	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
48	48	----------> functions -q -- $i
4	268	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
184	264	----------> contains -- $i (builtin -n)
80	80	-----------> builtin -n
32	32	--------> set -l paths
8	250	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
103	212	---------> set paths (command -s -- $i)
109	109	----------> command -s -- $i
23	144	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	57	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
23	23	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
9225	9225	------> git rev-parse --git-dir >/dev/null 2>&1
73	73	----> return 1
135	135	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
135	2185	> fish_right_prompt
128	128	-> set_color $fish_color_autosuggestion 2> /dev/null
1854	1854	-> date "+%H:%M:%S"
68	68	-> set_color normal
39	341	> fish_title
8	302	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
151	264	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
46	82	---> __fish_pwd
36	36	----> pwd
118	605	> __fish_disable_bracketed_paste 'source ~/.config/fish/config.fish'
487	487	-> printf "\e[?2004l"
99	1385	> fish_title source\ ~/.config/fish/config.fish
17	1286	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
57	57	--> not set -q INSIDE_EMACS
581	1212	--> echo (status current-command) (__fish_pwd)
67	67	---> status current-command
352	564	---> __fish_pwd
212	212	----> pwd
1270	8760	> source ~/.config/fish/config.fish
315	2795	-> export PATH="/Users/tkg/.deno/bin:$PATH"
12	100	--> if not set -q argv[1]
        set -x
        return 0
    ...
88	88	---> not set -q argv[1]
42	2380	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
203	480	---> set -l v (string split -m 1 "=" -- $arg)
277	277	----> string split -m 1 "=" -- $arg
107	1858	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
480	480	----> count $v
46	1271	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
310	310	-----> contains -- $v[1] PATH CDPATH MANPATH
164	538	-----> set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
257	374	------> string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2]
117	117	-------> string join ":" -- $$v[1]
266	377	-----> set -gx $v[1] (string split ":" -- $colonized_path)
111	111	------> string split ":" -- $colonized_path
94	1549	-> export PATH="$HOME/.cargo/bin:$PATH"
7	48	--> if not set -q argv[1]
        set -x
        return 0
    ...
41	41	---> not set -q argv[1]
31	1407	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
138	220	---> set -l v (string split -m 1 "=" -- $arg)
82	82	----> string split -m 1 "=" -- $arg
67	1156	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
67	67	----> count $v
24	1022	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
58	58	-----> contains -- $v[1] PATH CDPATH MANPATH
203	611	-----> set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
290	408	------> string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2]
118	118	-------> string join ":" -- $$v[1]
237	329	-----> set -gx $v[1] (string split ":" -- $colonized_path)
92	92	------> string split ":" -- $colonized_path
84	1291	-> export PATH="$PATH:$GOPATH/bin"
7	45	--> if not set -q argv[1]
        set -x
        return 0
    ...
38	38	---> not set -q argv[1]
25	1162	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
134	214	---> set -l v (string split -m 1 "=" -- $arg)
80	80	----> string split -m 1 "=" -- $arg
66	923	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
61	61	----> count $v
20	796	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
54	54	-----> contains -- $v[1] PATH CDPATH MANPATH
144	443	-----> set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
197	299	------> string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2]
102	102	-------> string join ":" -- $$v[1]
188	279	-----> set -gx $v[1] (string split ":" -- $colonized_path)
91	91	------> string split ":" -- $colonized_path
54	716	-> export VISUAL=nvim
6	40	--> if not set -q argv[1]
        set -x
        return 0
    ...
34	34	---> not set -q argv[1]
25	622	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
96	162	---> set -l v (string split -m 1 "=" -- $arg)
66	66	----> string split -m 1 "=" -- $arg
59	435	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
55	55	----> count $v
16	321	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
53	53	-----> contains -- $v[1] PATH CDPATH MANPATH
201	201	-----> true
51	51	-----> set -gx $v[1] $v[2]
58	537	-> export EDITOR="$VISUAL"
5	39	--> if not set -q argv[1]
        set -x
        return 0
    ...
34	34	---> not set -q argv[1]
23	440	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
94	153	---> set -l v (string split -m 1 "=" -- $arg)
59	59	----> string split -m 1 "=" -- $arg
56	264	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
54	54	----> count $v
15	154	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
53	53	-----> contains -- $v[1] PATH CDPATH MANPATH
40	40	-----> true
46	46	-----> set -gx $v[1] $v[2]
56	602	-> export FZF_DEFAULT_COMMAND='fd --type f'
5	39	--> if not set -q argv[1]
        set -x
        return 0
    ...
34	34	---> not set -q argv[1]
23	507	--> for arg in $argv
        set -l v (string split -m 1 "=" -- $arg)
        switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        end
    ...
95	159	---> set -l v (string split -m 1 "=" -- $arg)
64	64	----> string split -m 1 "=" -- $arg
67	325	---> switch (count $v)
            case 1
                set -gx $v $$v
            case 2
                if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                end
        ...
94	94	----> count $v
18	164	----> if contains -- $v[1] PATH CDPATH MANPATH
                    set -l colonized_path (string replace -- "$$v[1]" (string join ":" -- $$v[1]) $v[2])
                    set -gx $v[1] (string split ":" -- $colonized_path)
                else
                    # status is 1 from the contains check, and `set` does not change the status on success: reset it.
                    true
                    set -gx $v[1] $v[2]
                ...
59	59	-----> contains -- $v[1] PATH CDPATH MANPATH
40	40	-----> true
47	47	-----> set -gx $v[1] $v[2]
36	91	> __fish_enable_bracketed_paste
55	55	-> printf "\e[?2004h"
50	313	> fish_mode_prompt
174	263	-> fish_default_mode_prompt
9	89	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
44	44	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
36	36	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
96	16430	> fish_prompt
41	41	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
114	296	-> set -l cyan (set_color -o cyan)
182	182	--> set_color -o cyan
106	157	-> set -l yellow (set_color -o yellow)
51	51	--> set_color -o yellow
102	151	-> set -l red (set_color -o red)
49	49	--> set_color -o red
98	148	-> set -l green (set_color -o green)
50	50	--> set_color -o green
96	144	-> set -l blue (set_color -o blue)
48	48	--> set_color -o blue
98	145	-> set -l normal (set_color normal)
47	47	--> set_color normal
37	37	-> set -l arrow_color "$green"
5	38	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
33	33	--> test $__last_command_exit_status != 0
36	36	-> set -l arrow "$arrow_color➜ "
3	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
133	2580	-> set -l cwd $cyan(basename (prompt_pwd))
1765	2447	--> basename (prompt_pwd)
192	682	---> prompt_pwd
39	39	----> set -l options 'h/help'
44	44	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	32	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
28	28	-----> set -q _flag_help
27	27	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
36	36	----> set realhome ~
104	179	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
75	75	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	103	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
59	59	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	12428	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
118	12423	--> set -l repo_type (_repo_type)
38	12305	---> _repo_type
5	12222	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
30	468	-----> _is_hg_repo
226	438	------> fish_print_hg_root >/dev/null
35	212	-------> if not command -sq hg
        return 1
    ...
144	144	--------> not command -sq hg
33	33	--------> return 1
53	11749	-----> _is_git_repo
270	2733	------> type -q git
31	31	-------> set -q argv[1]
56	56	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
86	86	-------> argparse -n type -x t,p,P $options -- $argv
6	42	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
36	36	--------> set -q _flag_help
66	66	-------> set -l res 1
67	67	-------> set -l mode normal
52	52	-------> set -l multi no
199	199	-------> set -l selection all
52	52	-------> set -l short no
18	111	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
43	43	--------> set -q _flag_quiet
50	50	--------> set mode quiet
48	48	-------> set -q _flag_all
56	56	-------> set -q _flag_short
26	26	-------> set -q _flag_no_functions
53	1541	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
44	44	--------> set -l found 0
21	722	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
55	55	---------> test $selection != files
6	394	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
388	388	----------> functions -q -- $i
5	252	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
194	247	----------> contains -- $i (builtin -n)
53	53	-----------> builtin -n
34	34	--------> set -l paths
56	495	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
67	67	---------> test $multi != yes
167	372	---------> set paths (command -s -- $i)
205	205	----------> command -s -- $i
30	161	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
27	27	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	61	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
23	23	----------> continue
4	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
30	30	-------> return $res
8963	8963	------> git rev-parse --git-dir >/dev/null 2>&1
45	45	----> return 1
64	64	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
59	1903	> fish_right_prompt
85	85	-> set_color $fish_color_autosuggestion 2> /dev/null
1702	1702	-> date "+%H:%M:%S"
57	57	-> set_color normal
39	341	> fish_title
9	302	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
28	28	--> not set -q INSIDE_EMACS
155	265	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
43	79	---> __fish_pwd
36	36	----> pwd
57	125	> __fish_disable_bracketed_paste clear
68	68	-> printf "\e[?2004l"
75	515	> fish_title clear
12	440	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
40	40	--> not set -q INSIDE_EMACS
233	388	--> echo (status current-command) (__fish_pwd)
42	42	---> status current-command
64	113	---> __fish_pwd
49	49	----> pwd
3011	3011	> clear
73	254	> __fish_enable_bracketed_paste
181	181	-> printf "\e[?2004h"
59	221	> fish_mode_prompt
63	162	-> fish_default_mode_prompt
9	99	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
50	50	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
40	40	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
109	16110	> fish_prompt
41	41	-> set -l __last_command_exit_status $status
4	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
113	180	-> set -l cyan (set_color -o cyan)
67	67	--> set_color -o cyan
103	155	-> set -l yellow (set_color -o yellow)
52	52	--> set_color -o yellow
106	163	-> set -l red (set_color -o red)
57	57	--> set_color -o red
99	152	-> set -l green (set_color -o green)
53	53	--> set_color -o green
96	145	-> set -l blue (set_color -o blue)
49	49	--> set_color -o blue
172	219	-> set -l normal (set_color normal)
47	47	--> set_color normal
56	56	-> set -l arrow_color "$green"
6	70	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
64	64	--> test $__last_command_exit_status != 0
46	46	-> set -l arrow "$arrow_color➜ "
4	42	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
38	38	--> test "$USER" = 'root'
123	2611	-> set -l cwd $cyan(basename (prompt_pwd))
1845	2488	--> basename (prompt_pwd)
74	643	---> prompt_pwd
44	44	----> set -l options 'h/help'
45	45	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	32	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
28	28	-----> set -q _flag_help
28	28	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
37	37	----> set realhome ~
149	230	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
81	81	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	123	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
39	39	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
73	73	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	12016	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
172	12011	--> set -l repo_type (_repo_type)
57	11839	---> _repo_type
7	11731	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
29	321	-----> _is_hg_repo
80	292	------> fish_print_hg_root >/dev/null
11	212	-------> if not command -sq hg
        return 1
    ...
166	166	--------> not command -sq hg
35	35	--------> return 1
51	11403	-----> _is_git_repo
107	1524	------> type -q git
27	27	-------> set -q argv[1]
46	46	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
66	66	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
32	32	-------> set -l mode normal
27	27	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
55	55	-------> set -q _flag_all
31	31	-------> set -q _flag_short
26	26	-------> set -q _flag_no_functions
39	915	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
21	343	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
3	52	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
49	49	----------> functions -q -- $i
4	238	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
181	234	----------> contains -- $i (builtin -n)
53	53	-----------> builtin -n
29	29	--------> set -l paths
9	258	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	---------> test $multi != yes
102	221	---------> set paths (command -s -- $i)
119	119	----------> command -s -- $i
26	183	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
27	27	---------> set res 0
28	28	---------> set found 1
26	26	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
10	76	---------> if test $multi != yes
                continue
            ...
42	42	----------> test $multi != yes
24	24	----------> continue
4	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
28	28	-------> return $res
9828	9828	------> git rev-parse --git-dir >/dev/null 2>&1
51	51	----> return 1
70	70	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
69	2403	> fish_right_prompt
120	120	-> set_color $fish_color_autosuggestion 2> /dev/null
2141	2141	-> date "+%H:%M:%S"
73	73	-> set_color normal
76	398	> fish_title
9	322	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
34	34	--> not set -q INSIDE_EMACS
164	279	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
45	81	---> __fish_pwd
36	36	----> pwd
56	130	> __fish_disable_bracketed_paste ls
74	74	-> printf "\e[?2004l"
97	581	> fish_title ls
12	484	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
40	40	--> not set -q INSIDE_EMACS
225	432	--> echo (status current-command) (__fish_pwd)
95	95	---> status current-command
63	112	---> __fish_pwd
49	49	----> pwd
302	8118	> ls
279	4082	-> isatty stdout
66	66	--> set -l options 'h/help'
92	92	--> argparse -n isatty $options -- $argv
11	64	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
53	53	---> set -q _flag_help
6	43	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
37	37	---> set -q argv[2]
36	36	--> set -l fd
23	59	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
36	36	---> set fd 1
3443	3443	--> command [ -t "$fd" ]
55	55	-> set -a opt -F
3679	3679	-> command ls $opt $argv
44	117	> __fish_enable_bracketed_paste
73	73	-> printf "\e[?2004h"
67	360	> fish_mode_prompt
101	293	-> fish_default_mode_prompt
13	192	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
126	126	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
53	53	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
147	17657	> fish_prompt
48	48	-> set -l __last_command_exit_status $status
5	38	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
33	33	--> not set -q -g __fish_robbyrussell_functions_defined
164	269	-> set -l cyan (set_color -o cyan)
105	105	--> set_color -o cyan
179	237	-> set -l yellow (set_color -o yellow)
58	58	--> set_color -o yellow
120	206	-> set -l red (set_color -o red)
86	86	--> set_color -o red
147	211	-> set -l green (set_color -o green)
64	64	--> set_color -o green
180	258	-> set -l blue (set_color -o blue)
78	78	--> set_color -o blue
199	267	-> set -l normal (set_color normal)
68	68	--> set_color normal
42	42	-> set -l arrow_color "$green"
26	56	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
119	119	-> set -l arrow "$arrow_color➜ "
4	55	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
51	51	--> test "$USER" = 'root'
198	2689	-> set -l cwd $cyan(basename (prompt_pwd))
1622	2491	--> basename (prompt_pwd)
100	869	---> prompt_pwd
39	39	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
66	66	----> set -q fish_prompt_pwd_dir_length
31	31	----> set -l fish_prompt_pwd_dir_length 1
41	41	----> set realhome ~
265	401	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
136	136	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	123	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
46	46	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
67	67	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	12950	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
145	12946	--> set -l repo_type (_repo_type)
55	12801	---> _repo_type
24	12692	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
25	488	-----> _is_hg_repo
71	463	------> fish_print_hg_root >/dev/null
12	392	-------> if not command -sq hg
        return 1
    ...
343	343	--------> not command -sq hg
37	37	--------> return 1
53	12180	-----> _is_git_repo
97	1588	------> type -q git
27	27	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
64	64	-------> argparse -n type -x t,p,P $options -- $argv
3	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
25	25	-------> set -l selection all
24	24	-------> set -l short no
6	54	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
42	42	-------> set -q _flag_no_functions
41	1031	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
42	42	--------> set -l found 0
17	419	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
29	29	---------> test $selection != files
3	51	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
48	48	----------> functions -q -- $i
4	322	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
257	318	----------> contains -- $i (builtin -n)
61	61	-----------> builtin -n
29	29	--------> set -l paths
9	321	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	---------> test $multi != yes
162	284	---------> set paths (command -s -- $i)
122	122	----------> command -s -- $i
27	149	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
5	55	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
22	22	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
26	26	-------> return $res
10539	10539	------> git rev-parse --git-dir >/dev/null 2>&1
54	54	----> return 1
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
81	2345	> fish_right_prompt
95	95	-> set_color $fish_color_autosuggestion 2> /dev/null
2084	2084	-> date "+%H:%M:%S"
85	85	-> set_color normal
83	507	> fish_title
10	424	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
55	55	--> not set -q INSIDE_EMACS
235	359	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
52	91	---> __fish_pwd
39	39	----> pwd
82	367	> __fish_disable_bracketed_paste 'more profile.txt'
285	285	-> printf "\e[?2004l"
84	1046	> fish_title more\ profile.txt
14	962	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
48	48	--> not set -q INSIDE_EMACS
414	900	--> echo (status current-command) (__fish_pwd)
52	52	---> status current-command
230	434	---> __fish_pwd
204	204	----> pwd
10047	10047	> more profile.txt
50	111	> __fish_enable_bracketed_paste
61	61	-> printf "\e[?2004h"
50	317	> fish_mode_prompt
173	267	-> fish_default_mode_prompt
10	94	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
47	47	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
37	37	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
101	26592	> fish_prompt
42	42	-> set -l __last_command_exit_status $status
4	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
112	294	-> set -l cyan (set_color -o cyan)
182	182	--> set_color -o cyan
101	152	-> set -l yellow (set_color -o yellow)
51	51	--> set_color -o yellow
164	353	-> set -l red (set_color -o red)
189	189	--> set_color -o red
117	178	-> set -l green (set_color -o green)
61	61	--> set_color -o green
121	172	-> set -l blue (set_color -o blue)
51	51	--> set_color -o blue
117	173	-> set -l normal (set_color normal)
56	56	--> set_color normal
39	39	-> set -l arrow_color "$green"
8	77	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
33	33	--> test $__last_command_exit_status != 0
36	36	--> set arrow_color "$red"
38	38	-> set -l arrow "$arrow_color➜ "
4	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
142	2559	-> set -l cwd $cyan(basename (prompt_pwd))
1523	2417	--> basename (prompt_pwd)
226	894	---> prompt_pwd
45	45	----> set -l options 'h/help'
46	46	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	50	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
46	46	-----> set -q _flag_help
44	44	----> set -q fish_prompt_pwd_dir_length
40	40	----> set -l fish_prompt_pwd_dir_length 1
48	48	----> set realhome ~
104	295	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
191	191	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	100	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	22273	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
121	22268	--> set -l repo_type (_repo_type)
39	22147	---> _repo_type
8	22052	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
27	413	-----> _is_hg_repo
211	386	------> fish_print_hg_root >/dev/null
10	175	-------> if not command -sq hg
        return 1
    ...
131	131	--------> not command -sq hg
34	34	--------> return 1
48	21631	-----> _is_git_repo
239	2526	------> type -q git
29	29	-------> set -q argv[1]
46	46	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
63	63	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
25	25	-------> set -l multi no
25	25	-------> set -l selection all
27	27	-------> set -l short no
10	87	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
53	53	--------> set mode quiet
47	47	-------> set -q _flag_all
25	25	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
46	1778	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
24	947	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
29	29	---------> test $selection != files
6	344	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
338	338	----------> functions -q -- $i
7	550	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
458	543	----------> contains -- $i (builtin -n)
85	85	-----------> builtin -n
37	37	--------> set -l paths
14	496	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
35	35	---------> test $multi != yes
273	447	---------> set paths (command -s -- $i)
174	174	----------> command -s -- $i
30	187	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
50	50	---------> set res 0
29	29	---------> set found 1
12	12	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	66	---------> if test $multi != yes
                continue
            ...
33	33	----------> test $multi != yes
25	25	----------> continue
5	37	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
31	31	-------> return $res
19057	19057	------> git rev-parse --git-dir >/dev/null 2>&1
56	56	----> return 1
66	66	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
78	2304	> fish_right_prompt
120	120	-> set_color $fish_color_autosuggestion 2> /dev/null
2023	2023	-> date "+%H:%M:%S"
83	83	-> set_color normal
42	460	> fish_title
11	418	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
211	375	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
75	132	---> __fish_pwd
57	57	----> pwd
383	14300	> __fish_cancel_commandline
1211	1221	-> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_cancel_commandline.fish
10	10	--> function __fish_cancel_commandline
    # Close the pager if it's open (#4298)
    commandline -f cancel

    set -l cmd (commandline)
    if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    end
    # Repaint even if we haven't cancelled anything,
    # so the prompt refreshes and the terminal scrolls to it.
    commandline -f repaint
...
213	213	-> commandline -f cancel
100	149	-> set -l cmd (commandline)
49	49	--> commandline
39	12293	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
39	39	--> test -n "$cmd"
53	53	--> commandline -C 1000000
12	742	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
33	33	---> set -q fish_color_cancel
366	697	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
226	226	----> set_color $fish_color_cancel
105	105	----> set_color normal
18	5392	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
146	146	---> command -sq tput
232	5228	---> echo -n (tput el; or tput ce)
4996	4996	----> tput el
167	5693	--> for i in (seq (commandline -L))
            echo ""
        ...
4359	5454	---> seq (commandline -L)
780	978	----> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/seq.fish
10	198	-----> if not command -sq seq
    if command -sq gseq
        # No seq provided by the OS, but GNU coreutils was apparently installed, fantastic
        function seq --description "Print sequences of numbers (gseq)"
            gseq $argv
        end
        exit
    else
        # No seq command
        function seq --description "Print sequences of numbers"
            __fish_fallback_seq $argv
        end
    end

    function __fish_fallback_seq --description "Fallback implementation of the seq command"
        set -l from 1
        set -l step 1
        set -l to 1

        # Remove a "--" argument if it happens first.
        if test "x$argv[1]" = "x--"
            set -e argv[1]
        end

        switch (count $argv)
            case 1
                set to $argv[1]
            case 2
                set from $argv[1]
                set to $argv[2]
            case 3
                set from $argv[1]
                set step $argv[2]
                set to $argv[3]
            case '*'
                printf (_ "%s: Expected 1, 2 or 3 arguments, got %d\n") seq (count $argv)
                return 1
        end

        for i in $from $step $to
            if not string match -rq -- '^-?[0-9]*([0-9]*|\.[0-9]+)$' $i
                printf (_ "%s: '%s' is not a number\n") seq $i
                return 1
            end
        end

        if test $step -ge 0
            set -l i $from
            while test $i -le $to
                echo $i
                set i (math -- $i + $step)
            end
        else
            set -l i $from
            while test $i -ge $to
                echo $i
                set i (math -- $i + $step)
            end
        end
    end
...
188	188	------> not command -sq seq
117	117	----> commandline -L
72	72	---> echo ""
151	151	--> commandline ""
184	184	--> emit fish_cancel
41	41	-> commandline -f repaint
77	380	> fish_mode_prompt
212	303	-> fish_default_mode_prompt
10	91	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
48	48	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
160	16973	> fish_prompt
51	51	-> set -l __last_command_exit_status $status
4	38	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
34	34	--> not set -q -g __fish_robbyrussell_functions_defined
171	237	-> set -l cyan (set_color -o cyan)
66	66	--> set_color -o cyan
187	249	-> set -l yellow (set_color -o yellow)
62	62	--> set_color -o yellow
156	214	-> set -l red (set_color -o red)
58	58	--> set_color -o red
163	231	-> set -l green (set_color -o green)
68	68	--> set_color -o green
104	154	-> set -l blue (set_color -o blue)
50	50	--> set_color -o blue
93	135	-> set -l normal (set_color normal)
42	42	--> set_color normal
34	34	-> set -l arrow_color "$green"
8	69	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
29	29	--> test $__last_command_exit_status != 0
32	32	--> set arrow_color "$red"
36	36	-> set -l arrow "$arrow_color➜ "
2	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
114	2423	-> set -l cwd $cyan(basename (prompt_pwd))
1522	2309	--> basename (prompt_pwd)
183	787	---> prompt_pwd
41	41	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
108	287	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
179	179	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	123	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
48	48	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
66	66	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	12841	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
120	12836	--> set -l repo_type (_repo_type)
40	12716	---> _repo_type
9	12623	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
30	402	-----> _is_hg_repo
201	372	------> fish_print_hg_root >/dev/null
9	171	-------> if not command -sq hg
        return 1
    ...
122	122	--------> not command -sq hg
40	40	--------> return 1
50	12212	-----> _is_git_repo
198	1832	------> type -q git
29	29	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
72	72	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
29	29	-------> set -l selection all
26	26	-------> set -l short no
7	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
26	26	--------> set mode quiet
24	24	-------> set -q _flag_all
25	25	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
31	1170	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
15	628	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
5	250	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
245	245	----------> functions -q -- $i
5	331	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
275	326	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
30	30	--------> set -l paths
10	273	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	---------> test $multi != yes
128	235	---------> set paths (command -s -- $i)
107	107	----------> command -s -- $i
23	148	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	58	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
22	22	----------> continue
5	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
26	26	-------> return $res
10330	10330	------> git rev-parse --git-dir >/dev/null 2>&1
53	53	----> return 1
66	66	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
171	2241	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
1910	1910	-> date "+%H:%M:%S"
69	69	-> set_color normal
43	569	> fish_title
9	526	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
157	486	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
153	296	---> __fish_pwd
143	143	----> pwd
63	346	> __fish_disable_bracketed_paste clear
283	283	-> printf "\e[?2004l"
62	619	> fish_title clear
16	557	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
44	44	--> not set -q INSIDE_EMACS
308	497	--> echo (status current-command) (__fish_pwd)
50	50	---> status current-command
81	139	---> __fish_pwd
58	58	----> pwd
4971	4971	> clear
60	147	> __fish_enable_bracketed_paste
87	87	-> printf "\e[?2004h"
54	216	> fish_mode_prompt
57	162	-> fish_default_mode_prompt
10	105	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
53	53	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
42	42	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
158	18022	> fish_prompt
59	59	-> set -l __last_command_exit_status $status
11	85	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
74	74	--> not set -q -g __fish_robbyrussell_functions_defined
200	441	-> set -l cyan (set_color -o cyan)
241	241	--> set_color -o cyan
244	334	-> set -l yellow (set_color -o yellow)
90	90	--> set_color -o yellow
222	316	-> set -l red (set_color -o red)
94	94	--> set_color -o red
228	305	-> set -l green (set_color -o green)
77	77	--> set_color -o green
142	213	-> set -l blue (set_color -o blue)
71	71	--> set_color -o blue
166	242	-> set -l normal (set_color normal)
76	76	--> set_color normal
73	73	-> set -l arrow_color "$green"
5	48	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
43	43	--> test $__last_command_exit_status != 0
47	47	-> set -l arrow "$arrow_color➜ "
4	47	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
43	43	--> test "$USER" = 'root'
163	2749	-> set -l cwd $cyan(basename (prompt_pwd))
1616	2586	--> basename (prompt_pwd)
97	970	---> prompt_pwd
46	46	----> set -l options 'h/help'
54	54	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
7	41	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
34	34	-----> set -q _flag_help
34	34	----> set -q fish_prompt_pwd_dir_length
37	37	----> set -l fish_prompt_pwd_dir_length 1
141	141	----> set realhome ~
223	333	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
110	110	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
15	187	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
87	87	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
85	85	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
6	12836	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
149	12830	--> set -l repo_type (_repo_type)
41	12681	---> _repo_type
9	12584	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
78	440	-----> _is_hg_repo
89	362	------> fish_print_hg_root >/dev/null
14	273	-------> if not command -sq hg
        return 1
    ...
213	213	--------> not command -sq hg
46	46	--------> return 1
73	12135	-----> _is_git_repo
108	1680	------> type -q git
32	32	-------> set -q argv[1]
62	62	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
79	79	-------> argparse -n type -x t,p,P $options -- $argv
5	34	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
29	29	--------> set -q _flag_help
29	29	-------> set -l res 1
69	69	-------> set -l mode normal
43	43	-------> set -l multi no
32	32	-------> set -l selection all
30	30	-------> set -l short no
10	67	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
27	27	--------> set -q _flag_quiet
30	30	--------> set mode quiet
27	27	-------> set -q _flag_all
26	26	-------> set -q _flag_short
26	26	-------> set -q _flag_no_functions
40	972	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
23	392	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
34	34	---------> test $selection != files
4	59	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
55	55	----------> functions -q -- $i
5	276	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
210	271	----------> contains -- $i (builtin -n)
61	61	-----------> builtin -n
34	34	--------> set -l paths
10	282	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
32	32	---------> test $multi != yes
105	240	---------> set paths (command -s -- $i)
135	135	----------> command -s -- $i
23	159	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
29	29	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	64	---------> if test $multi != yes
                continue
            ...
31	31	----------> test $multi != yes
25	25	----------> continue
4	34	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	---------> test $found = 0
44	44	-------> return $res
10382	10382	------> git rev-parse --git-dir >/dev/null 2>&1
56	56	----> return 1
69	69	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
73	1991	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
1747	1747	-> date "+%H:%M:%S"
83	83	-> set_color normal
56	430	> fish_title
13	374	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
204	329	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
53	92	---> __fish_pwd
39	39	----> pwd
410	12335	> __fish_cancel_commandline
255	255	-> commandline -f cancel
177	364	-> set -l cmd (commandline)
187	187	--> commandline
36	11262	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
73	73	--> test -n "$cmd"
68	68	--> commandline -C 1000000
15	730	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
44	44	---> set -q fish_color_cancel
384	671	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
222	222	----> set_color $fish_color_cancel
65	65	----> set_color normal
19	5678	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
150	150	---> command -sq tput
236	5509	---> echo -n (tput el; or tput ce)
5273	5273	----> tput el
163	4430	--> for i in (seq (commandline -L))
            echo ""
        ...
4103	4186	---> seq (commandline -L)
83	83	----> commandline -L
81	81	---> echo ""
63	63	--> commandline ""
184	184	--> emit fish_cancel
44	44	-> commandline -f repaint
62	342	> fish_mode_prompt
184	280	-> fish_default_mode_prompt
9	96	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
49	49	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
151	28370	> fish_prompt
50	50	-> set -l __last_command_exit_status $status
4	36	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
32	32	--> not set -q -g __fish_robbyrussell_functions_defined
118	184	-> set -l cyan (set_color -o cyan)
66	66	--> set_color -o cyan
134	196	-> set -l yellow (set_color -o yellow)
62	62	--> set_color -o yellow
146	215	-> set -l red (set_color -o red)
69	69	--> set_color -o red
111	171	-> set -l green (set_color -o green)
60	60	--> set_color -o green
116	208	-> set -l blue (set_color -o blue)
92	92	--> set_color -o blue
109	166	-> set -l normal (set_color normal)
57	57	--> set_color normal
39	39	-> set -l arrow_color "$green"
5	39	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
34	34	--> test $__last_command_exit_status != 0
37	37	-> set -l arrow "$arrow_color➜ "
3	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
37	37	--> test "$USER" = 'root'
116	2597	-> set -l cwd $cyan(basename (prompt_pwd))
1661	2481	--> basename (prompt_pwd)
196	820	---> prompt_pwd
44	44	----> set -l options 'h/help'
44	44	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	33	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
27	27	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
37	37	----> set realhome ~
108	304	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
196	196	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	105	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
35	35	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
60	60	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	24166	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
115	24161	--> set -l repo_type (_repo_type)
80	24046	---> _repo_type
16	23903	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
46	411	-----> _is_hg_repo
204	365	------> fish_print_hg_root >/dev/null
9	161	-------> if not command -sq hg
        return 1
    ...
125	125	--------> not command -sq hg
27	27	--------> return 1
56	23476	-----> _is_git_repo
209	1822	------> type -q git
28	28	-------> set -q argv[1]
49	49	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
64	64	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
30	1158	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
17	644	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
4	255	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
251	251	----------> functions -q -- $i
5	340	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
282	335	----------> contains -- $i (builtin -n)
53	53	-----------> builtin -n
30	30	--------> set -l paths
9	255	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
97	217	---------> set paths (command -s -- $i)
120	120	----------> command -s -- $i
23	142	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
27	27	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	56	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
22	22	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
27	27	-------> return $res
21598	21598	------> git rev-parse --git-dir >/dev/null 2>&1
63	63	----> return 1
75	75	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
164	2060	> fish_right_prompt
86	86	-> set_color $fish_color_autosuggestion 2> /dev/null
1754	1754	-> date "+%H:%M:%S"
56	56	-> set_color normal
41	563	> fish_title
9	522	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
155	484	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
159	297	---> __fish_pwd
138	138	----> pwd
508	10028	> __fish_cancel_commandline
236	236	-> commandline -f cancel
185	250	-> set -l cmd (commandline)
65	65	--> commandline
86	8942	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
47	47	--> test -n "$cmd"
66	66	--> commandline -C 1000000
15	797	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
39	39	---> set -q fish_color_cancel
420	743	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
239	239	----> set_color $fish_color_cancel
84	84	----> set_color normal
25	4197	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
188	188	---> command -sq tput
312	3984	---> echo -n (tput el; or tput ce)
3672	3672	----> tput el
249	3480	--> for i in (seq (commandline -L))
            echo ""
        ...
3012	3134	---> seq (commandline -L)
122	122	----> commandline -L
97	97	---> echo ""
68	68	--> commandline ""
201	201	--> emit fish_cancel
92	92	-> commandline -f repaint
57	328	> fish_mode_prompt
173	271	-> fish_default_mode_prompt
10	98	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
51	51	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
37	37	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
136	19714	> fish_prompt
42	42	-> set -l __last_command_exit_status $status
4	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
130	192	-> set -l cyan (set_color -o cyan)
62	62	--> set_color -o cyan
146	201	-> set -l yellow (set_color -o yellow)
55	55	--> set_color -o yellow
141	200	-> set -l red (set_color -o red)
59	59	--> set_color -o red
141	199	-> set -l green (set_color -o green)
58	58	--> set_color -o green
134	187	-> set -l blue (set_color -o blue)
53	53	--> set_color -o blue
134	196	-> set -l normal (set_color normal)
62	62	--> set_color normal
40	40	-> set -l arrow_color "$green"
5	39	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
34	34	--> test $__last_command_exit_status != 0
37	37	-> set -l arrow "$arrow_color➜ "
4	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
144	3290	-> set -l cwd $cyan(basename (prompt_pwd))
1888	3146	--> basename (prompt_pwd)
251	1258	---> prompt_pwd
58	58	----> set -l options 'h/help'
88	88	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	74	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
68	68	-----> set -q _flag_help
61	61	----> set -q fish_prompt_pwd_dir_length
45	45	----> set -l fish_prompt_pwd_dir_length 1
96	96	----> set realhome ~
172	464	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
292	292	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	121	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
42	42	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
69	69	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
6	14811	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
205	14805	--> set -l repo_type (_repo_type)
58	14600	---> _repo_type
6	14483	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
29	455	-----> _is_hg_repo
225	426	------> fish_print_hg_root >/dev/null
11	201	-------> if not command -sq hg
        return 1
    ...
163	163	--------> not command -sq hg
27	27	--------> return 1
55	14022	-----> _is_git_repo
205	2282	------> type -q git
27	27	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
69	69	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
31	31	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
54	1538	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
23	833	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
35	35	---------> test $selection != files
4	251	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
247	247	----------> functions -q -- $i
9	524	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
417	515	----------> contains -- $i (builtin -n)
98	98	-----------> builtin -n
76	76	--------> set -l paths
10	341	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
33	33	---------> test $multi != yes
158	298	---------> set paths (command -s -- $i)
140	140	----------> command -s -- $i
28	160	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
31	31	---------> set res 0
30	30	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	60	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
22	22	----------> continue
6	47	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
41	41	---------> test $found = 0
107	107	-------> return $res
11685	11685	------> git rev-parse --git-dir >/dev/null 2>&1
59	59	----> return 1
69	69	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
178	2492	> fish_right_prompt
93	93	-> set_color $fish_color_autosuggestion 2> /dev/null
2155	2155	-> date "+%H:%M:%S"
66	66	-> set_color normal
43	600	> fish_title
11	557	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
187	516	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
159	297	---> __fish_pwd
138	138	----> pwd
684	8070	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/which.fish
27	7332	-> if which -v >/dev/null 2>/dev/null # GNU
    complete -c which -s a -l all -d "Print all matching executables in PATH, not just the first"
    complete -c which -s i -l read-alias -d "Read aliases from stdin, reporting matching ones on stdout"
    complete -c which -l skip-alias -d "Ignore option '--read-alias'"
    complete -c which -l read-functions -d "Read shell function definitions from stdin, reporting matching ones on stdout"
    complete -c which -l skip-functions -d "Ignore option '--read-functions'"
    complete -c which -l skip-dot -d "Skip directories in PATH that start with a dot"
    complete -c which -l skip-tilde -d "Skip directories in PATH that start with a tilde and executables which reside in the HOME directory"
    complete -c which -l show-dot -d "If a directory in PATH starts with a dot and a matching executable was found for that path, then print './programname'"
    complete -c which -l show-tilde -d "Output a tilde when a directory matches the HOME directory"
    complete -c which -l tty-only -d "Stop processing options on the right if not on tty"
    complete -c which -s v -s V -l version -d "Display version and exit"
    complete -c which -l help -d "Display help and exit"
else # OSX
    complete -c which -s a -d "Print all matching executables in PATH, not just the first"
    complete -c which -s s -d "Print no output, only return 0 if found"
...
7044	7044	--> which -v >/dev/null 2>/dev/null
215	215	--> complete -c which -s a -d "Print all matching executables in PATH, not just the first"
46	46	--> complete -c which -s s -d "Print no output, only return 0 if found"
54	54	-> complete -c which -a "(__fish_complete_external_command)" -x
125	465	> __fish_disable_bracketed_paste 'which brew'
340	340	-> printf "\e[?2004l"
108	1175	> fish_title which\ brew
15	1067	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
73	73	--> not set -q INSIDE_EMACS
453	979	--> echo (status current-command) (__fish_pwd)
69	69	---> status current-command
270	457	---> __fish_pwd
187	187	----> pwd
3829	3829	> which brew
55	116	> __fish_enable_bracketed_paste
61	61	-> printf "\e[?2004h"
49	441	> fish_mode_prompt
287	392	-> fish_default_mode_prompt
12	105	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
55	55	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
105	30331	> fish_prompt
42	42	-> set -l __last_command_exit_status $status
5	36	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
140	330	-> set -l cyan (set_color -o cyan)
190	190	--> set_color -o cyan
120	172	-> set -l yellow (set_color -o yellow)
52	52	--> set_color -o yellow
115	164	-> set -l red (set_color -o red)
49	49	--> set_color -o red
113	162	-> set -l green (set_color -o green)
49	49	--> set_color -o green
110	162	-> set -l blue (set_color -o blue)
52	52	--> set_color -o blue
128	175	-> set -l normal (set_color normal)
47	47	--> set_color normal
42	42	-> set -l arrow_color "$green"
4	38	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
34	34	--> test $__last_command_exit_status != 0
37	37	-> set -l arrow "$arrow_color➜ "
4	66	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
62	62	--> test "$USER" = 'root'
164	3032	-> set -l cwd $cyan(basename (prompt_pwd))
1868	2868	--> basename (prompt_pwd)
229	1000	---> prompt_pwd
63	63	----> set -l options 'h/help'
47	47	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
32	32	-----> set -q _flag_help
29	29	----> set -q fish_prompt_pwd_dir_length
33	33	----> set -l fish_prompt_pwd_dir_length 1
38	38	----> set realhome ~
156	398	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
242	242	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	127	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
45	45	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
70	70	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	25701	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
119	25697	--> set -l repo_type (_repo_type)
42	25578	---> _repo_type
7	25482	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
41	460	-----> _is_hg_repo
240	419	------> fish_print_hg_root >/dev/null
10	179	-------> if not command -sq hg
        return 1
    ...
142	142	--------> not command -sq hg
27	27	--------> return 1
48	25015	-----> _is_git_repo
224	3043	------> type -q git
29	29	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
92	92	-------> argparse -n type -x t,p,P $options -- $argv
4	34	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
30	30	--------> set -q _flag_help
29	29	-------> set -l res 1
29	29	-------> set -l mode normal
31	31	-------> set -l multi no
42	42	-------> set -l selection all
43	43	-------> set -l short no
12	97	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
46	46	--------> set -q _flag_quiet
39	39	--------> set mode quiet
41	41	-------> set -q _flag_all
30	30	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
43	2221	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
37	1611	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
31	31	---------> test $selection != files
6	577	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
571	571	----------> functions -q -- $i
7	966	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
850	959	----------> contains -- $i (builtin -n)
109	109	-----------> builtin -n
36	36	--------> set -l paths
11	321	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
31	31	---------> test $multi != yes
131	279	---------> set paths (command -s -- $i)
148	148	----------> command -s -- $i
25	150	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	58	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
22	22	----------> continue
5	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
30	30	-------> return $res
21924	21924	------> git rev-parse --git-dir >/dev/null 2>&1
54	54	----> return 1
67	67	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
59	2089	> fish_right_prompt
87	87	-> set_color $fish_color_autosuggestion 2> /dev/null
1882	1882	-> date "+%H:%M:%S"
61	61	-> set_color normal
40	341	> fish_title
7	301	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
154	264	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
43	79	---> __fish_pwd
36	36	----> pwd
61	553	> __fish_disable_bracketed_paste clear
492	492	-> printf "\e[?2004l"
80	1016	> fish_title clear
14	936	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
39	39	--> not set -q INSIDE_EMACS
428	883	--> echo (status current-command) (__fish_pwd)
43	43	---> status current-command
239	412	---> __fish_pwd
173	173	----> pwd
4340	4340	> clear
48	109	> __fish_enable_bracketed_paste
61	61	-> printf "\e[?2004h"
45	302	> fish_mode_prompt
171	257	-> fish_default_mode_prompt
9	86	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
44	44	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
97	16862	> fish_prompt
37	37	-> set -l __last_command_exit_status $status
4	32	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
118	292	-> set -l cyan (set_color -o cyan)
174	174	--> set_color -o cyan
106	161	-> set -l yellow (set_color -o yellow)
55	55	--> set_color -o yellow
109	156	-> set -l red (set_color -o red)
47	47	--> set_color -o red
108	155	-> set -l green (set_color -o green)
47	47	--> set_color -o green
88	134	-> set -l blue (set_color -o blue)
46	46	--> set_color -o blue
88	132	-> set -l normal (set_color normal)
44	44	--> set_color normal
34	34	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
141	2702	-> set -l cwd $cyan(basename (prompt_pwd))
1750	2561	--> basename (prompt_pwd)
201	811	---> prompt_pwd
42	42	----> set -l options 'h/help'
57	57	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
118	302	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
184	184	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	96	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
56	56	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	12757	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
107	12752	--> set -l repo_type (_repo_type)
38	12645	---> _repo_type
7	12558	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	384	-----> _is_hg_repo
199	358	------> fish_print_hg_root >/dev/null
9	159	-------> if not command -sq hg
        return 1
    ...
123	123	--------> not command -sq hg
27	27	--------> return 1
45	12167	-----> _is_git_repo
197	1938	------> type -q git
27	27	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
67	67	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
25	25	-------> set -l res 1
25	25	-------> set -l mode normal
28	28	-------> set -l multi no
27	27	-------> set -l selection all
26	26	-------> set -l short no
8	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
35	1284	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
18	675	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
29	29	---------> test $selection != files
5	262	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
257	257	----------> functions -q -- $i
5	366	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
308	361	----------> contains -- $i (builtin -n)
53	53	-----------> builtin -n
32	32	--------> set -l paths
11	276	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
118	236	---------> set paths (command -s -- $i)
118	118	----------> command -s -- $i
26	202	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
54	54	---------> set res 0
30	30	---------> set found 1
12	12	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
10	80	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
41	41	----------> continue
5	37	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
30	30	-------> return $res
10184	10184	------> git rev-parse --git-dir >/dev/null 2>&1
49	49	----> return 1
70	70	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
77	2283	> fish_right_prompt
100	100	-> set_color $fish_color_autosuggestion 2> /dev/null
2031	2031	-> date "+%H:%M:%S"
75	75	-> set_color normal
40	352	> fish_title
9	312	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
154	273	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
48	88	---> __fish_pwd
40	40	----> pwd
898	6455	> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/grep.fish
56	5557	-> if echo | command grep --color=auto "" >/dev/null 2>&1
    function grep
        command grep --color=auto $argv
    end
...
5490	5490	--> echo | command grep --color=auto "" >/dev/null 2>&1
11	11	--> function grep
        command grep --color=auto $argv
    ...
1330	3968	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/grep.fish
280	280	-> complete -c grep -s A -l after-context -d "Print NUM lines of trailing context" -x
57	57	-> complete -c grep -s a -l text -d "Process binary file as text"
52	52	-> complete -c grep -s B -l before-context -d "Print NUM lines of leading context" -x
51	51	-> complete -c grep -s C -l context -d "Print NUM lines of context" -x
50	50	-> complete -c grep -s b -l byte-offset -d "Print byte offset of matches"
63	63	-> complete -c grep -l binary-files -d "Assume data type for binary files" -x -a "binary\tBinary\ format text\tText\ format"
66	66	-> complete -c grep -l colour -f -d "Colour output" -a "never always auto"
57	57	-> complete -c grep -l color -f -d "Color output" -a "never always auto"
50	50	-> complete -c grep -s c -l count -d "Only print number of matches"
61	61	-> complete -c grep -s D -l devices -x -a "read skip" -d "Action for devices"
59	59	-> complete -c grep -s d -l directories -x -a "read skip recurse" -d "Action for directories"
49	49	-> complete -c grep -s E -l extended-regexp -d "Pattern is extended regexp"
48	48	-> complete -xc grep -s e -l regexp -d "Specify a pattern"
54	54	-> complete -rc grep -l exclude-from -d "Read pattern list from file. Skip files whose base name matches list"
49	49	-> complete -rc grep -l exclude-dir -d "Exclude matching directories from recursive searches"
47	47	-> complete -c grep -s F -l fixed-strings -d "Pattern is a fixed string"
47	47	-> complete -rc grep -s f -l file -d "Use patterns from a file"
48	48	-> complete -c grep -s G -l basic-regexp -d "Pattern is basic regex"
52	52	-> complete -c grep -s H -l with-filename -d "Print filename"
47	47	-> complete -c grep -s h -l no-filename -d "Suppress printing filename"
45	45	-> complete -c grep -l help -d "Display help and exit"
45	45	-> complete -c grep -s I -d "Skip binary files"
47	47	-> complete -c grep -s i -l ignore-case -d "Ignore case"
52	52	-> complete -c grep -s L -l files-without-match -d "Print first non-matching file"
48	48	-> complete -c grep -s l -l files-with-match -d "Print first matching file"
48	48	-> complete -c grep -s m -l max-count -d "Stop reading after NUM matches"
68	68	-> complete -c grep -l mmap -d "Use the mmap system call to read input"
41	41	-> complete -c grep -s n -l line-number -d "Print line number"
46	46	-> complete -c grep -s o -l only-matching -d "Show only matching part"
41	41	-> complete -c grep -l label -d "Rename stdin" -x
40	40	-> complete -c grep -l line-buffered -d "Use line buffering"
42	42	-> complete -c grep -s P -l perl-regexp -d "Pattern is a Perl regexp (PCRE) string"
42	42	-> complete -c grep -s q -l quiet -d "Do not write anything"
40	40	-> complete -c grep -l silent -d "Do not write anything"
45	45	-> complete -c grep -s R -l recursive -d "Read files under each directory, recursively"
40	40	-> complete -c grep -s r -d "Read files under each directory, recursively"
41	41	-> complete -c grep -l include -d "Search only files matching PATTERN" -r
40	40	-> complete -c grep -l exclude -d "Skip files matching PATTERN" -r
51	51	-> complete -c grep -s s -l no-messages -d "Suppress error messages"
47	47	-> complete -c grep -s T -l initial-tab -d "Ensure first character of actual line content lies on a tab stop"
41	41	-> complete -c grep -s U -l binary -d "Treat files as binary"
42	42	-> complete -c grep -s u -l unix-byte-offsets -d "Report Unix-style byte offsets"
42	42	-> complete -c grep -s V -l version -d "Display version and exit"
70	70	-> complete -c grep -s v -l invert-match -d "Invert the sense of matching"
66	66	-> complete -c grep -s w -l word-regexp -d "Only whole matching words"
50	50	-> complete -c grep -s x -l line-regexp -d "Only whole matching lines"
47	47	-> complete -c grep -s y -d "Ignore case (deprecated: use -i instead)"
43	43	-> complete -c grep -s z -l null-data -d "Treat input as a set of zero-terminated lines"
41	41	-> complete -c grep -s Z -l null -d "Output a zero byte after filename"
131	672	> __fish_disable_bracketed_paste 'ls | grep node'
541	541	-> printf "\e[?2004l"
161	1536	> fish_title ls\ \|\ grep\ node
18	1375	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
54	54	--> not set -q INSIDE_EMACS
419	1303	--> echo (status current-command) (__fish_pwd)
55	55	---> status current-command
342	829	---> __fish_pwd
487	487	----> pwd
638	15529	> ls | grep node
477	5876	-> isatty stdout
83	83	--> set -l options 'h/help'
115	115	--> argparse -n isatty $options -- $argv
13	80	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
67	67	---> set -q _flag_help
8	51	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
43	43	---> set -q argv[2]
41	41	--> set -l fd
27	77	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
50	50	---> set fd 1
4952	4952	--> command [ -t "$fd" ]
6123	6123	-> command ls $opt $argv
2892	2892	-> command grep --color=auto $argv
80	203	> __fish_enable_bracketed_paste
123	123	-> printf "\e[?2004h"
77	559	> fish_mode_prompt
233	482	-> fish_default_mode_prompt
28	249	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
103	103	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
118	118	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
269	31461	> fish_prompt
52	52	-> set -l __last_command_exit_status $status
6	39	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
33	33	--> not set -q -g __fish_robbyrussell_functions_defined
139	379	-> set -l cyan (set_color -o cyan)
240	240	--> set_color -o cyan
121	175	-> set -l yellow (set_color -o yellow)
54	54	--> set_color -o yellow
105	157	-> set -l red (set_color -o red)
52	52	--> set_color -o red
105	282	-> set -l green (set_color -o green)
177	177	--> set_color -o green
117	167	-> set -l blue (set_color -o blue)
50	50	--> set_color -o blue
144	191	-> set -l normal (set_color normal)
47	47	--> set_color normal
43	43	-> set -l arrow_color "$green"
10	91	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
35	35	--> test $__last_command_exit_status != 0
46	46	--> set arrow_color "$red"
110	110	-> set -l arrow "$arrow_color➜ "
5	70	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
65	65	--> test "$USER" = 'root'
165	4725	-> set -l cwd $cyan(basename (prompt_pwd))
3413	4560	--> basename (prompt_pwd)
327	1147	---> prompt_pwd
75	75	----> set -l options 'h/help'
49	49	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	34	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
30	30	-----> set -q _flag_help
28	28	----> set -q fish_prompt_pwd_dir_length
33	33	----> set -l fish_prompt_pwd_dir_length 1
72	72	----> set realhome ~
135	418	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
283	283	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	111	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
68	68	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
9	24629	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
126	24620	--> set -l repo_type (_repo_type)
52	24494	---> _repo_type
8	24386	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	413	-----> _is_hg_repo
216	387	------> fish_print_hg_root >/dev/null
9	171	-------> if not command -sq hg
        return 1
    ...
135	135	--------> not command -sq hg
27	27	--------> return 1
55	23965	-----> _is_git_repo
211	2041	------> type -q git
34	34	-------> set -q argv[1]
67	67	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
75	75	-------> argparse -n type -x t,p,P $options -- $argv
4	37	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
33	33	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
8	67	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
33	33	--------> set -q _flag_quiet
26	26	--------> set mode quiet
31	31	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
46	1314	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
46	747	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
39	39	---------> test $selection != files
4	266	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
262	262	----------> functions -q -- $i
5	396	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
337	391	----------> contains -- $i (builtin -n)
54	54	-----------> builtin -n
33	33	--------> set -l paths
9	265	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
31	31	---------> test $multi != yes
110	225	---------> set paths (command -s -- $i)
115	115	----------> command -s -- $i
21	160	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
26	26	---------> set found 1
19	19	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	65	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
28	28	----------> continue
9	36	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
21869	21869	------> git rev-parse --git-dir >/dev/null 2>&1
56	56	----> return 1
82	82	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
109	3570	> fish_right_prompt
106	106	-> set_color $fish_color_autosuggestion 2> /dev/null
3281	3281	-> date "+%H:%M:%S"
74	74	-> set_color normal
41	415	> fish_title
11	374	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
204	333	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
54	94	---> __fish_pwd
40	40	----> pwd
70	382	> __fish_disable_bracketed_paste 'rg '
312	312	-> printf "\e[?2004l"
78	1021	> fish_title rg\ 
14	943	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
42	42	--> not set -q INSIDE_EMACS
429	887	--> echo (status current-command) (__fish_pwd)
55	55	---> status current-command
228	403	---> __fish_pwd
175	175	----> pwd
109715	109715	> rg
178	259	> __fish_enable_bracketed_paste
81	81	-> printf "\e[?2004h"
149	585	> fish_mode_prompt
334	436	-> fish_default_mode_prompt
9	102	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
58	58	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
35	35	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
153	29424	> fish_prompt
84	84	-> set -l __last_command_exit_status $status
5	70	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
65	65	--> not set -q -g __fish_robbyrussell_functions_defined
227	519	-> set -l cyan (set_color -o cyan)
292	292	--> set_color -o cyan
227	289	-> set -l yellow (set_color -o yellow)
62	62	--> set_color -o yellow
174	230	-> set -l red (set_color -o red)
56	56	--> set_color -o red
105	166	-> set -l green (set_color -o green)
61	61	--> set_color -o green
105	151	-> set -l blue (set_color -o blue)
46	46	--> set_color -o blue
110	159	-> set -l normal (set_color normal)
49	49	--> set_color normal
36	36	-> set -l arrow_color "$green"
9	93	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
54	54	--> set arrow_color "$red"
45	45	-> set -l arrow "$arrow_color➜ "
4	39	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
35	35	--> test "$USER" = 'root'
132	3353	-> set -l cwd $cyan(basename (prompt_pwd))
2415	3221	--> basename (prompt_pwd)
187	806	---> prompt_pwd
39	39	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
101	282	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
181	181	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	145	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
68	68	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
66	66	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	23970	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
115	23965	--> set -l repo_type (_repo_type)
39	23850	---> _repo_type
7	23763	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
31	493	-----> _is_hg_repo
291	462	------> fish_print_hg_root >/dev/null
10	171	-------> if not command -sq hg
        return 1
    ...
133	133	--------> not command -sq hg
28	28	--------> return 1
47	23263	-----> _is_git_repo
279	2287	------> type -q git
40	40	-------> set -q argv[1]
95	95	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
78	78	-------> argparse -n type -x t,p,P $options -- $argv
5	33	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
28	28	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
26	26	-------> set -l selection all
64	64	-------> set -l short no
13	99	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
52	52	--------> set -q _flag_quiet
34	34	--------> set mode quiet
27	27	-------> set -q _flag_all
24	24	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
40	1388	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
22	825	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
31	31	---------> test $selection != files
6	366	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
360	360	----------> functions -q -- $i
6	406	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
331	400	----------> contains -- $i (builtin -n)
69	69	-----------> builtin -n
32	32	--------> set -l paths
10	271	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
116	231	---------> set paths (command -s -- $i)
115	115	----------> command -s -- $i
25	154	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
27	27	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	59	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
22	22	----------> continue
6	37	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	---------> test $found = 0
31	31	-------> return $res
20929	20929	------> git rev-parse --git-dir >/dev/null 2>&1
48	48	----> return 1
67	67	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
71	3523	> fish_right_prompt
84	84	-> set_color $fish_color_autosuggestion 2> /dev/null
3268	3268	-> date "+%H:%M:%S"
100	100	-> set_color normal
46	507	> fish_title
12	461	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
237	419	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
55	147	---> __fish_pwd
92	92	----> pwd
402	15022	> __fish_cancel_commandline
307	307	-> commandline -f cancel
242	312	-> set -l cmd (commandline)
70	70	--> commandline
62	13949	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
53	53	--> test -n "$cmd"
115	115	--> commandline -C 1000000
22	706	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
67	67	---> set -q fish_color_cancel
436	617	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
111	111	----> set_color $fish_color_cancel
70	70	----> set_color normal
45	7213	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
993	993	---> command -sq tput
304	6175	---> echo -n (tput el; or tput ce)
5871	5871	----> tput el
200	5436	--> for i in (seq (commandline -L))
            echo ""
        ...
5041	5156	---> seq (commandline -L)
115	115	----> commandline -L
80	80	---> echo ""
98	98	--> commandline ""
266	266	--> emit fish_cancel
52	52	-> commandline -f repaint
69	216	> fish_mode_prompt
62	147	-> fish_default_mode_prompt
8	85	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
44	44	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
104	15743	> fish_prompt
42	42	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
127	181	-> set -l cyan (set_color -o cyan)
54	54	--> set_color -o cyan
116	167	-> set -l yellow (set_color -o yellow)
51	51	--> set_color -o yellow
93	139	-> set -l red (set_color -o red)
46	46	--> set_color -o red
89	133	-> set -l green (set_color -o green)
44	44	--> set_color -o green
122	176	-> set -l blue (set_color -o blue)
54	54	--> set_color -o blue
92	138	-> set -l normal (set_color normal)
46	46	--> set_color normal
35	35	-> set -l arrow_color "$green"
7	69	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
32	32	--> set arrow_color "$red"
33	33	-> set -l arrow "$arrow_color➜ "
3	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
135	2008	-> set -l cwd $cyan(basename (prompt_pwd))
1342	1873	--> basename (prompt_pwd)
69	531	---> prompt_pwd
40	40	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	28	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
32	32	----> set realhome ~
99	178	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
79	79	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	94	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
55	55	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	12382	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
135	12377	--> set -l repo_type (_repo_type)
36	12242	---> _repo_type
5	12156	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
28	266	-----> _is_hg_repo
72	238	------> fish_print_hg_root >/dev/null
9	166	-------> if not command -sq hg
        return 1
    ...
129	129	--------> not command -sq hg
28	28	--------> return 1
44	11885	-----> _is_git_repo
103	1816	------> type -q git
26	26	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
70	70	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
23	23	-------> set -q _flag_all
53	53	-------> set -q _flag_short
54	54	-------> set -q _flag_no_functions
47	1198	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
33	33	--------> set -l found 0
22	443	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
63	63	---------> test $selection != files
12	76	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
64	64	----------> functions -q -- $i
5	282	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
223	277	----------> contains -- $i (builtin -n)
54	54	-----------> builtin -n
38	38	--------> set -l paths
13	433	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
63	63	---------> test $multi != yes
152	357	---------> set paths (command -s -- $i)
205	205	----------> command -s -- $i
26	173	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
38	38	---------> set found 1
14	14	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	63	---------> if test $multi != yes
                continue
            ...
32	32	----------> test $multi != yes
22	22	----------> continue
3	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
27	27	-------> return $res
10025	10025	------> git rev-parse --git-dir >/dev/null 2>&1
50	50	----> return 1
67	67	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
76	1914	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
1690	1690	-> date "+%H:%M:%S"
57	57	-> set_color normal
48	373	> fish_title
11	325	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
162	282	--> echo (status current-command) (__fish_pwd)
36	36	---> status current-command
45	84	---> __fish_pwd
39	39	----> pwd
2774	9580	> source /usr/local/share/fish/vendor_completions.d/rg.fish
265	265	-> complete -c rg -n "__fish_use_subcommand" -s A -l after-context -d 'Show NUM lines after each match.'
58	58	-> complete -c rg -n "__fish_use_subcommand" -s B -l before-context -d 'Show NUM lines before each match.'
63	63	-> complete -c rg -n "__fish_use_subcommand" -l color -d 'Controls when to use color.' -r -f -a "never auto always ansi"
53	53	-> complete -c rg -n "__fish_use_subcommand" -l colors -d 'Configure color settings and styles.'
51	51	-> complete -c rg -n "__fish_use_subcommand" -s C -l context -d 'Show NUM lines before and after each match.'
52	52	-> complete -c rg -n "__fish_use_subcommand" -l context-separator -d 'Set the context separator string.'
54	54	-> complete -c rg -n "__fish_use_subcommand" -l dfa-size-limit -d 'The upper size limit of the regex DFA.'
51	51	-> complete -c rg -n "__fish_use_subcommand" -s E -l encoding -d 'Specify the text encoding of files to search.'
65	65	-> complete -c rg -n "__fish_use_subcommand" -l engine -d 'Specify which regexp engine to use.' -r -f -a "default pcre2 auto"
54	54	-> complete -c rg -n "__fish_use_subcommand" -s f -l file -d 'Search for patterns from the given file.'
159	159	-> complete -c rg -n "__fish_use_subcommand" -s g -l glob -d 'Include or exclude files.'
64	64	-> complete -c rg -n "__fish_use_subcommand" -l iglob -d 'Include or exclude files case insensitively.'
52	52	-> complete -c rg -n "__fish_use_subcommand" -l ignore-file -d 'Specify additional ignore files.'
52	52	-> complete -c rg -n "__fish_use_subcommand" -s M -l max-columns -d 'Don\'t print lines longer than this limit.'
52	52	-> complete -c rg -n "__fish_use_subcommand" -s m -l max-count -d 'Limit the number of matches.'
50	50	-> complete -c rg -n "__fish_use_subcommand" -l max-depth -d 'Descend at most NUM directories.'
57	57	-> complete -c rg -n "__fish_use_subcommand" -l max-filesize -d 'Ignore files larger than NUM in size.'
50	50	-> complete -c rg -n "__fish_use_subcommand" -l path-separator -d 'Set the path separator.'
49	49	-> complete -c rg -n "__fish_use_subcommand" -l pre -d 'search outputs of COMMAND FILE for each FILE'
50	50	-> complete -c rg -n "__fish_use_subcommand" -l pre-glob -d 'Include or exclude files from a preprocessing command.'
49	49	-> complete -c rg -n "__fish_use_subcommand" -l regex-size-limit -d 'The upper size limit of the compiled regex.'
53	53	-> complete -c rg -n "__fish_use_subcommand" -s e -l regexp -d 'A pattern to search for.'
50	50	-> complete -c rg -n "__fish_use_subcommand" -s r -l replace -d 'Replace matches with the given text.'
61	61	-> complete -c rg -n "__fish_use_subcommand" -l sort -d 'Sort results in ascending order. Implies --threads=1.' -r -f -a "path modified accessed created none"
64	64	-> complete -c rg -n "__fish_use_subcommand" -l sortr -d 'Sort results in descending order. Implies --threads=1.' -r -f -a "path modified accessed created none"
51	51	-> complete -c rg -n "__fish_use_subcommand" -s j -l threads -d 'The approximate number of threads to use.'
49	49	-> complete -c rg -n "__fish_use_subcommand" -s t -l type -d 'Only search files matching TYPE.'
48	48	-> complete -c rg -n "__fish_use_subcommand" -l type-add -d 'Add a new glob for a file type.'
51	51	-> complete -c rg -n "__fish_use_subcommand" -l type-clear -d 'Clear globs for a file type.'
50	50	-> complete -c rg -n "__fish_use_subcommand" -s T -l type-not -d 'Do not search files matching TYPE.'
48	48	-> complete -c rg -n "__fish_use_subcommand" -l auto-hybrid-regex -d 'Dynamically use PCRE2 if necessary.'
46	46	-> complete -c rg -n "__fish_use_subcommand" -l no-auto-hybrid-regex
47	47	-> complete -c rg -n "__fish_use_subcommand" -l binary -d 'Search binary files.'
48	48	-> complete -c rg -n "__fish_use_subcommand" -l no-binary
48	48	-> complete -c rg -n "__fish_use_subcommand" -l block-buffered -d 'Force block buffering.'
45	45	-> complete -c rg -n "__fish_use_subcommand" -l no-block-buffered
50	50	-> complete -c rg -n "__fish_use_subcommand" -s b -l byte-offset -d 'Print the 0-based byte offset for each matching line.'
50	50	-> complete -c rg -n "__fish_use_subcommand" -s s -l case-sensitive -d 'Search case sensitively (default).'
51	51	-> complete -c rg -n "__fish_use_subcommand" -l column -d 'Show column numbers.'
45	45	-> complete -c rg -n "__fish_use_subcommand" -l no-column
45	45	-> complete -c rg -n "__fish_use_subcommand" -l no-context-separator
50	50	-> complete -c rg -n "__fish_use_subcommand" -s c -l count -d 'Only show the count of matching lines for each file.'
52	52	-> complete -c rg -n "__fish_use_subcommand" -l count-matches -d 'Only show the count of individual matches for each file.'
52	52	-> complete -c rg -n "__fish_use_subcommand" -l crlf -d 'Support CRLF line terminators (useful on Windows).'
45	45	-> complete -c rg -n "__fish_use_subcommand" -l no-crlf
47	47	-> complete -c rg -n "__fish_use_subcommand" -l debug -d 'Show debug messages.'
45	45	-> complete -c rg -n "__fish_use_subcommand" -l trace
45	45	-> complete -c rg -n "__fish_use_subcommand" -l no-encoding
52	52	-> complete -c rg -n "__fish_use_subcommand" -l files -d 'Print each file that would be searched.'
51	51	-> complete -c rg -n "__fish_use_subcommand" -s l -l files-with-matches -d 'Only print the paths with at least one match.'
48	48	-> complete -c rg -n "__fish_use_subcommand" -l files-without-match -d 'Only print the paths that contain zero matches.'
49	49	-> complete -c rg -n "__fish_use_subcommand" -s F -l fixed-strings -d 'Treat the pattern as a literal string.'
49	49	-> complete -c rg -n "__fish_use_subcommand" -l no-fixed-strings
50	50	-> complete -c rg -n "__fish_use_subcommand" -s L -l follow -d 'Follow symbolic links.'
45	45	-> complete -c rg -n "__fish_use_subcommand" -l no-follow
47	47	-> complete -c rg -n "__fish_use_subcommand" -l glob-case-insensitive -d 'Process all glob patterns case insensitively.'
45	45	-> complete -c rg -n "__fish_use_subcommand" -l no-glob-case-insensitive
51	51	-> complete -c rg -n "__fish_use_subcommand" -l heading -d 'Print matches grouped by each file.'
48	48	-> complete -c rg -n "__fish_use_subcommand" -l no-heading -d 'Don\'t group matches by each file.'
48	48	-> complete -c rg -n "__fish_use_subcommand" -l hidden -d 'Search hidden files and directories.'
46	46	-> complete -c rg -n "__fish_use_subcommand" -l no-hidden
50	50	-> complete -c rg -n "__fish_use_subcommand" -s i -l ignore-case -d 'Case insensitive search.'
52	52	-> complete -c rg -n "__fish_use_subcommand" -l ignore-file-case-insensitive -d 'Process ignore files case insensitively.'
46	46	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore-file-case-insensitive
48	48	-> complete -c rg -n "__fish_use_subcommand" -l include-zero -d 'Include files with zero matches in summary'
49	49	-> complete -c rg -n "__fish_use_subcommand" -s v -l invert-match -d 'Invert matching.'
51	51	-> complete -c rg -n "__fish_use_subcommand" -l json -d 'Show search results in a JSON Lines format.'
51	51	-> complete -c rg -n "__fish_use_subcommand" -l no-json
63	63	-> complete -c rg -n "__fish_use_subcommand" -l line-buffered -d 'Force line buffering.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l no-line-buffered
43	43	-> complete -c rg -n "__fish_use_subcommand" -s n -l line-number -d 'Show line numbers.'
47	47	-> complete -c rg -n "__fish_use_subcommand" -s N -l no-line-number -d 'Suppress line numbers.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -s x -l line-regexp -d 'Only show matches surrounded by line boundaries.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l max-columns-preview -d 'Print a preview for lines exceeding the limit.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l no-max-columns-preview
45	45	-> complete -c rg -n "__fish_use_subcommand" -l mmap -d 'Search using memory maps when possible.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-mmap -d 'Never use memory maps.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -s U -l multiline -d 'Enable matching across multiple lines.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l no-multiline
46	46	-> complete -c rg -n "__fish_use_subcommand" -l multiline-dotall -d 'Make \'.\' match new lines when multiline is enabled.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l no-multiline-dotall
42	42	-> complete -c rg -n "__fish_use_subcommand" -l no-config -d 'Never read configuration files.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore -d 'Don\'t respect ignore files.'
40	40	-> complete -c rg -n "__fish_use_subcommand" -l ignore
42	42	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore-dot -d 'Don\'t respect .ignore files.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l ignore-dot
42	42	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore-exclude -d 'Don\'t respect local exclusion files.'
40	40	-> complete -c rg -n "__fish_use_subcommand" -l ignore-exclude
83	83	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore-files -d 'Don\'t respect --ignore-file arguments.'
42	42	-> complete -c rg -n "__fish_use_subcommand" -l ignore-files
47	47	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore-global -d 'Don\'t respect global ignore files.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l ignore-global
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore-messages -d 'Suppress gitignore parse error messages.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l ignore-messages
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore-parent -d 'Don\'t respect ignore files in parent directories.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -l ignore-parent
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-ignore-vcs -d 'Don\'t respect VCS ignore files.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l ignore-vcs
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-messages -d 'Suppress some error messages.'
40	40	-> complete -c rg -n "__fish_use_subcommand" -l messages
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-pcre2-unicode -d 'Disable Unicode mode for PCRE2 matching.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -l pcre2-unicode
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-require-git -d 'Do not require a git repository to use gitignores.'
40	40	-> complete -c rg -n "__fish_use_subcommand" -l require-git
42	42	-> complete -c rg -n "__fish_use_subcommand" -l no-unicode -d 'Disable Unicode mode.'
40	40	-> complete -c rg -n "__fish_use_subcommand" -l unicode
54	54	-> complete -c rg -n "__fish_use_subcommand" -s 0 -l null -d 'Print a NUL byte after file paths.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l null-data -d 'Use NUL as a line terminator instead of \\n.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l one-file-system -d 'Do not descend into directories on other file systems.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l no-one-file-system
48	48	-> complete -c rg -n "__fish_use_subcommand" -s o -l only-matching -d 'Print only matched parts of a line.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l passthru -d 'Print both matching and non-matching lines.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -s P -l pcre2 -d 'Enable PCRE2 matching.'
40	40	-> complete -c rg -n "__fish_use_subcommand" -l no-pcre2
43	43	-> complete -c rg -n "__fish_use_subcommand" -l pcre2-version -d 'Print the version of PCRE2 that ripgrep uses.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-pre
44	44	-> complete -c rg -n "__fish_use_subcommand" -s p -l pretty -d 'Alias for --color always --heading --line-number.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -s q -l quiet -d 'Do not print anything to stdout.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -s z -l search-zip -d 'Search in compressed files.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -l no-search-zip
44	44	-> complete -c rg -n "__fish_use_subcommand" -s S -l smart-case -d 'Smart case search.'
42	42	-> complete -c rg -n "__fish_use_subcommand" -l sort-files -d 'DEPRECATED'
39	39	-> complete -c rg -n "__fish_use_subcommand" -l no-sort-files
42	42	-> complete -c rg -n "__fish_use_subcommand" -l stats -d 'Print statistics about this ripgrep search.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l no-stats
44	44	-> complete -c rg -n "__fish_use_subcommand" -s a -l text -d 'Search binary files as if they were text.'
41	41	-> complete -c rg -n "__fish_use_subcommand" -l no-text
42	42	-> complete -c rg -n "__fish_use_subcommand" -l trim -d 'Trim prefixed whitespace from matches.'
39	39	-> complete -c rg -n "__fish_use_subcommand" -l no-trim
45	45	-> complete -c rg -n "__fish_use_subcommand" -l type-list -d 'Show all supported file types.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -s u -l unrestricted -d 'Reduce the level of "smart" searching.'
43	43	-> complete -c rg -n "__fish_use_subcommand" -l vimgrep -d 'Show results in vim compatible format.'
45	45	-> complete -c rg -n "__fish_use_subcommand" -s H -l with-filename -d 'Print the file path with the matched lines.'
48	48	-> complete -c rg -n "__fish_use_subcommand" -s I -l no-filename -d 'Never print the file path with the matched lines.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -s w -l word-regexp -d 'Only show matches surrounded by word boundaries.'
44	44	-> complete -c rg -n "__fish_use_subcommand" -s h -l help -d 'Prints help information. Use --help for more details.'
62	62	-> complete -c rg -n "__fish_use_subcommand" -s V -l version -d 'Prints version information'
88	166	> __fish_disable_bracketed_paste 'rg --help'
78	78	-> printf "\e[?2004l"
71	480	> fish_title rg\ --help
11	409	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
41	41	--> not set -q INSIDE_EMACS
215	357	--> echo (status current-command) (__fish_pwd)
42	42	---> status current-command
55	100	---> __fish_pwd
45	45	----> pwd
15200	15200	> rg --help
62	119	> __fish_enable_bracketed_paste
57	57	-> printf "\e[?2004h"
42	168	> fish_mode_prompt
43	126	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
92	17952	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	32	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
101	155	-> set -l cyan (set_color -o cyan)
54	54	--> set_color -o cyan
91	135	-> set -l yellow (set_color -o yellow)
44	44	--> set_color -o yellow
89	132	-> set -l red (set_color -o red)
43	43	--> set_color -o red
88	130	-> set -l green (set_color -o green)
42	42	--> set_color -o green
85	127	-> set -l blue (set_color -o blue)
42	42	--> set_color -o blue
87	127	-> set -l normal (set_color normal)
40	40	--> set_color normal
33	33	-> set -l arrow_color "$green"
3	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
35	35	-> set -l arrow "$arrow_color➜ "
4	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
31	31	--> test "$USER" = 'root'
126	2001	-> set -l cwd $cyan(basename (prompt_pwd))
1356	1875	--> basename (prompt_pwd)
65	519	---> prompt_pwd
37	37	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
95	166	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
71	71	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	97	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
6	14739	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
130	14733	--> set -l repo_type (_repo_type)
48	14603	---> _repo_type
8	14494	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
35	280	-----> _is_hg_repo
74	245	------> fish_print_hg_root >/dev/null
9	171	-------> if not command -sq hg
        return 1
    ...
134	134	--------> not command -sq hg
28	28	--------> return 1
57	14206	-----> _is_git_repo
90	1469	------> type -q git
27	27	-------> set -q argv[1]
51	51	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
64	64	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
8	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
30	925	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
18	412	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	51	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
47	47	----------> functions -q -- $i
5	313	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
200	308	----------> contains -- $i (builtin -n)
108	108	-----------> builtin -n
31	31	--------> set -l paths
9	248	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
96	210	---------> set paths (command -s -- $i)
114	114	----------> command -s -- $i
22	147	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
27	27	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	62	---------> if test $multi != yes
                continue
            ...
33	33	----------> test $multi != yes
22	22	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
12680	12680	------> git rev-parse --git-dir >/dev/null 2>&1
61	61	----> return 1
110	110	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
114	2393	> fish_right_prompt
101	101	-> set_color $fish_color_autosuggestion 2> /dev/null
2093	2093	-> date "+%H:%M:%S"
85	85	-> set_color normal
46	529	> fish_title
11	483	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
40	40	--> not set -q INSIDE_EMACS
247	432	--> echo (status current-command) (__fish_pwd)
38	38	---> status current-command
68	147	---> __fish_pwd
79	79	----> pwd
3521	4641	> up-or-search
698	718	-> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/up-or-search.fish
20	20	--> function up-or-search -d "Depending on cursor position and current mode, either search backward or move up one line"
    # If we are already in search mode, continue
    if commandline --search-mode
        commandline -f history-search-backward
        return
    end

    # If we are navigating the pager, then up always navigates
    if commandline --paging-mode
        commandline -f up-line
        return
    end

    # We are not already in search mode.
    # If we are on the top line, start search mode,
    # otherwise move up
    set lineno (commandline -L)

    switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    end
...
7	62	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
55	55	--> commandline --search-mode
6	48	-> if commandline --paging-mode
        commandline -f up-line
        return
    ...
42	42	--> commandline --paging-mode
164	219	-> set lineno (commandline -L)
55	55	--> commandline -L
17	73	-> switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    ...
56	56	--> commandline -f history-search-backward
113	6235	> __fish_cancel_commandline
51	51	-> commandline -f cancel
112	159	-> set -l cmd (commandline)
47	47	--> commandline
35	5875	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
36	36	--> test -n "$cmd"
78	78	--> commandline -C 1000000
11	370	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
32	32	---> set -q fish_color_cancel
202	327	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
60	60	----> set_color $fish_color_cancel
65	65	----> set_color normal
16	2992	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
110	110	---> command -sq tput
236	2866	---> echo -n (tput el; or tput ce)
2630	2630	----> tput el
129	2272	--> for i in (seq (commandline -L))
            echo ""
        ...
2022	2074	---> seq (commandline -L)
52	52	----> commandline -L
69	69	---> echo ""
53	53	--> commandline ""
39	39	--> emit fish_cancel
37	37	-> commandline -f repaint
54	348	> fish_mode_prompt
64	294	-> fish_default_mode_prompt
17	230	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
134	134	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
79	79	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
106	14896	> fish_prompt
39	39	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
130	187	-> set -l cyan (set_color -o cyan)
57	57	--> set_color -o cyan
104	162	-> set -l yellow (set_color -o yellow)
58	58	--> set_color -o yellow
90	137	-> set -l red (set_color -o red)
47	47	--> set_color -o red
87	130	-> set -l green (set_color -o green)
43	43	--> set_color -o green
122	164	-> set -l blue (set_color -o blue)
42	42	--> set_color -o blue
105	160	-> set -l normal (set_color normal)
55	55	--> set_color normal
35	35	-> set -l arrow_color "$green"
3	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
116	2016	-> set -l cwd $cyan(basename (prompt_pwd))
1372	1900	--> basename (prompt_pwd)
71	528	---> prompt_pwd
40	40	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
97	170	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
73	73	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	94	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
55	55	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
7	11546	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
122	11539	--> set -l repo_type (_repo_type)
40	11417	---> _repo_type
6	11324	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
28	277	-----> _is_hg_repo
75	249	------> fish_print_hg_root >/dev/null
9	174	-------> if not command -sq hg
        return 1
    ...
138	138	--------> not command -sq hg
27	27	--------> return 1
50	11041	-----> _is_git_repo
90	1585	------> type -q git
27	27	-------> set -q argv[1]
44	44	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
63	63	-------> argparse -n type -x t,p,P $options -- $argv
3	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
7	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
26	26	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
39	1047	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
16	336	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
33	33	---------> test $selection != files
4	51	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
47	47	----------> functions -q -- $i
5	236	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
180	231	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
67	67	--------> set -l paths
12	355	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
65	65	---------> test $multi != yes
140	278	---------> set paths (command -s -- $i)
138	138	----------> command -s -- $i
45	189	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
28	28	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
10	74	---------> if test $multi != yes
                continue
            ...
41	41	----------> test $multi != yes
23	23	----------> continue
5	33	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
28	28	-------> return $res
9406	9406	------> git rev-parse --git-dir >/dev/null 2>&1
53	53	----> return 1
80	80	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
77	2167	> fish_right_prompt
92	92	-> set_color $fish_color_autosuggestion 2> /dev/null
1927	1927	-> date "+%H:%M:%S"
71	71	-> set_color normal
41	360	> fish_title
10	319	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
158	279	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
46	86	---> __fish_pwd
40	40	----> pwd
48	102	> __fish_disable_bracketed_paste clear
54	54	-> printf "\e[?2004l"
42	439	> fish_title clear
10	397	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
233	358	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
53	93	---> __fish_pwd
40	40	----> pwd
4053	4053	> clear
44	98	> __fish_enable_bracketed_paste
54	54	-> printf "\e[?2004h"
51	177	> fish_mode_prompt
43	126	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
43	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
108	16636	> fish_prompt
37	37	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
130	184	-> set -l cyan (set_color -o cyan)
54	54	--> set_color -o cyan
159	209	-> set -l yellow (set_color -o yellow)
50	50	--> set_color -o yellow
123	189	-> set -l red (set_color -o red)
66	66	--> set_color -o red
113	162	-> set -l green (set_color -o green)
49	49	--> set_color -o green
105	150	-> set -l blue (set_color -o blue)
45	45	--> set_color -o blue
108	156	-> set -l normal (set_color normal)
48	48	--> set_color normal
35	35	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
143	2127	-> set -l cwd $cyan(basename (prompt_pwd))
1424	1984	--> basename (prompt_pwd)
69	560	---> prompt_pwd
48	48	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
114	190	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
76	76	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	97	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
56	56	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
79	13052	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
162	12973	--> set -l repo_type (_repo_type)
78	12811	---> _repo_type
7	12599	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
27	273	-----> _is_hg_repo
72	246	------> fish_print_hg_root >/dev/null
9	174	-------> if not command -sq hg
        return 1
    ...
137	137	--------> not command -sq hg
28	28	--------> return 1
53	12319	-----> _is_git_repo
93	1559	------> type -q git
27	27	-------> set -q argv[1]
51	51	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
73	73	-------> argparse -n type -x t,p,P $options -- $argv
3	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
27	27	-------> set -l selection all
26	26	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
33	1000	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
15	331	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	52	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
48	48	----------> functions -q -- $i
5	234	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
175	229	----------> contains -- $i (builtin -n)
54	54	-----------> builtin -n
29	29	--------> set -l paths
9	375	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
204	337	---------> set paths (command -s -- $i)
133	133	----------> command -s -- $i
30	173	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
43	43	---------> set res 0
30	30	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	59	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
23	23	----------> continue
5	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
10707	10707	------> git rev-parse --git-dir >/dev/null 2>&1
134	134	----> return 1
94	94	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
85	2878	> fish_right_prompt
189	189	-> set_color $fish_color_autosuggestion 2> /dev/null
2529	2529	-> date "+%H:%M:%S"
75	75	-> set_color normal
45	419	> fish_title
10	374	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
218	334	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
46	82	---> __fish_pwd
36	36	----> pwd
89	391	> __fish_disable_bracketed_paste 'rg dupa'
302	302	-> printf "\e[?2004l"
79	1258	> fish_title rg\ dupa
17	1179	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
48	48	--> not set -q INSIDE_EMACS
556	1114	--> echo (status current-command) (__fish_pwd)
71	71	---> status current-command
270	487	---> __fish_pwd
217	217	----> pwd
3501925	3501925	> rg dupa
78	1016	> fish_mode_prompt
839	938	-> fish_default_mode_prompt
11	99	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
54	54	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
34	34	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
98	53990	> fish_prompt
38	38	-> set -l __last_command_exit_status $status
4	32	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
100	365	-> set -l cyan (set_color -o cyan)
265	265	--> set_color -o cyan
97	143	-> set -l yellow (set_color -o yellow)
46	46	--> set_color -o yellow
130	173	-> set -l red (set_color -o red)
43	43	--> set_color -o red
114	167	-> set -l green (set_color -o green)
53	53	--> set_color -o green
109	156	-> set -l blue (set_color -o blue)
47	47	--> set_color -o blue
119	182	-> set -l normal (set_color normal)
63	63	--> set_color normal
49	49	-> set -l arrow_color "$green"
11	103	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
45	45	--> test $__last_command_exit_status != 0
47	47	--> set arrow_color "$red"
48	48	-> set -l arrow "$arrow_color➜ "
5	53	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
48	48	--> test "$USER" = 'root'
221	15490	-> set -l cwd $cyan(basename (prompt_pwd))
14238	15269	--> basename (prompt_pwd)
324	1031	---> prompt_pwd
46	46	----> set -l options 'h/help'
43	43	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
28	28	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
108	400	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
292	292	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	101	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
59	59	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	36829	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
199	36825	--> set -l repo_type (_repo_type)
40	36626	---> _repo_type
7	36522	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
28	6485	-----> _is_hg_repo
346	6457	------> fish_print_hg_root >/dev/null
17	6111	-------> if not command -sq hg
        return 1
    ...
6038	6038	--------> not command -sq hg
56	56	--------> return 1
63	30030	-----> _is_git_repo
340	2380	------> type -q git
30	30	-------> set -q argv[1]
51	51	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
70	70	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
27	27	-------> set -l short no
9	58	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
26	26	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
44	1571	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
27	929	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
35	35	---------> test $selection != files
5	441	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
436	436	----------> functions -q -- $i
5	426	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
367	421	----------> contains -- $i (builtin -n)
54	54	-----------> builtin -n
30	30	--------> set -l paths
10	353	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
147	314	---------> set paths (command -s -- $i)
167	167	----------> command -s -- $i
26	152	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	59	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
22	22	----------> continue
4	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
28	28	-------> return $res
27587	27587	------> git rev-parse --git-dir >/dev/null 2>&1
64	64	----> return 1
64	64	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
77	3986	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
3747	3747	-> date "+%H:%M:%S"
71	71	-> set_color normal
52	391	> fish_title
11	339	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
35	35	--> not set -q INSIDE_EMACS
170	293	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
53	90	---> __fish_pwd
37	37	----> pwd
1514	2326	> __fish_cancel_commandline
486	486	-> commandline -f cancel
161	221	-> set -l cmd (commandline)
60	60	--> commandline
7	52	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
45	45	--> test -n "$cmd"
53	53	-> commandline -f repaint
146	437	> fish_mode_prompt
169	291	-> fish_default_mode_prompt
12	122	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
59	59	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
51	51	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
135	18025	> fish_prompt
54	54	-> set -l __last_command_exit_status $status
5	45	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
40	40	--> not set -q -g __fish_robbyrussell_functions_defined
165	240	-> set -l cyan (set_color -o cyan)
75	75	--> set_color -o cyan
183	267	-> set -l yellow (set_color -o yellow)
84	84	--> set_color -o yellow
159	236	-> set -l red (set_color -o red)
77	77	--> set_color -o red
148	217	-> set -l green (set_color -o green)
69	69	--> set_color -o green
229	296	-> set -l blue (set_color -o blue)
67	67	--> set_color -o blue
121	180	-> set -l normal (set_color normal)
59	59	--> set_color normal
44	44	-> set -l arrow_color "$green"
10	90	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
39	39	--> test $__last_command_exit_status != 0
41	41	--> set arrow_color "$red"
43	43	-> set -l arrow "$arrow_color➜ "
4	42	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
38	38	--> test "$USER" = 'root'
177	2815	-> set -l cwd $cyan(basename (prompt_pwd))
1890	2638	--> basename (prompt_pwd)
80	748	---> prompt_pwd
44	44	----> set -l options 'h/help'
51	51	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	38	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
32	32	-----> set -q _flag_help
32	32	----> set -q fish_prompt_pwd_dir_length
34	34	----> set -l fish_prompt_pwd_dir_length 1
43	43	----> set realhome ~
199	290	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
91	91	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
13	136	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
48	48	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
75	75	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	13256	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
139	13252	--> set -l repo_type (_repo_type)
41	13113	---> _repo_type
9	13022	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
33	431	-----> _is_hg_repo
89	398	------> fish_print_hg_root >/dev/null
15	309	-------> if not command -sq hg
        return 1
    ...
244	244	--------> not command -sq hg
50	50	--------> return 1
102	12582	-----> _is_git_repo
225	1860	------> type -q git
47	47	-------> set -q argv[1]
61	61	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
89	89	-------> argparse -n type -x t,p,P $options -- $argv
5	39	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
34	34	--------> set -q _flag_help
33	33	-------> set -l res 1
32	32	-------> set -l mode normal
34	34	-------> set -l multi no
34	34	-------> set -l selection all
33	33	-------> set -l short no
9	72	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
30	30	--------> set -q _flag_quiet
33	33	--------> set mode quiet
31	31	-------> set -q _flag_all
28	28	-------> set -q _flag_short
28	28	-------> set -q _flag_no_functions
55	1044	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
35	35	--------> set -l found 0
20	443	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
38	38	---------> test $selection != files
4	63	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
59	59	----------> functions -q -- $i
5	322	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
248	317	----------> contains -- $i (builtin -n)
69	69	-----------> builtin -n
35	35	--------> set -l paths
9	285	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
33	33	---------> test $multi != yes
106	243	---------> set paths (command -s -- $i)
137	137	----------> command -s -- $i
22	157	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
31	31	---------> set res 0
29	29	---------> set found 1
12	12	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	63	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
24	24	----------> continue
5	34	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
29	29	---------> test $found = 0
30	30	-------> return $res
10620	10620	------> git rev-parse --git-dir >/dev/null 2>&1
50	50	----> return 1
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
60	2031	> fish_right_prompt
85	85	-> set_color $fish_color_autosuggestion 2> /dev/null
1815	1815	-> date "+%H:%M:%S"
71	71	-> set_color normal
49	369	> fish_title
9	320	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
163	278	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
44	83	---> __fish_pwd
39	39	----> pwd
62	139	> __fish_disable_bracketed_paste clear
77	77	-> printf "\e[?2004l"
127	877	> fish_title clear
15	750	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
54	54	--> not set -q INSIDE_EMACS
359	681	--> echo (status current-command) (__fish_pwd)
126	126	---> status current-command
130	196	---> __fish_pwd
66	66	----> pwd
6108	6108	> clear
49	117	> __fish_enable_bracketed_paste
68	68	-> printf "\e[?2004h"
61	214	> fish_mode_prompt
57	153	-> fish_default_mode_prompt
9	96	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
50	50	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
37	37	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
127	16255	> fish_prompt
42	42	-> set -l __last_command_exit_status $status
4	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
165	230	-> set -l cyan (set_color -o cyan)
65	65	--> set_color -o cyan
142	213	-> set -l yellow (set_color -o yellow)
71	71	--> set_color -o yellow
129	190	-> set -l red (set_color -o red)
61	61	--> set_color -o red
145	206	-> set -l green (set_color -o green)
61	61	--> set_color -o green
124	184	-> set -l blue (set_color -o blue)
60	60	--> set_color -o blue
133	192	-> set -l normal (set_color normal)
59	59	--> set_color normal
43	43	-> set -l arrow_color "$green"
5	40	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
35	35	--> test $__last_command_exit_status != 0
61	61	-> set -l arrow "$arrow_color➜ "
5	57	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
52	52	--> test "$USER" = 'root'
234	3004	-> set -l cwd $cyan(basename (prompt_pwd))
2056	2770	--> basename (prompt_pwd)
89	714	---> prompt_pwd
43	43	----> set -l options 'h/help'
59	59	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	36	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
32	32	-----> set -q _flag_help
31	31	----> set -q fish_prompt_pwd_dir_length
37	37	----> set -l fish_prompt_pwd_dir_length 1
39	39	----> set realhome ~
167	253	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
86	86	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	127	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
43	43	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
73	73	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
6	11566	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
135	11560	--> set -l repo_type (_repo_type)
52	11425	---> _repo_type
8	11326	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
32	418	-----> _is_hg_repo
156	386	------> fish_print_hg_root >/dev/null
13	230	-------> if not command -sq hg
        return 1
    ...
179	179	--------> not command -sq hg
38	38	--------> return 1
47	10900	-----> _is_git_repo
126	1677	------> type -q git
29	29	-------> set -q argv[1]
48	48	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
67	67	-------> argparse -n type -x t,p,P $options -- $argv
4	37	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
33	33	--------> set -q _flag_help
28	28	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
35	35	-------> set -l selection all
44	44	-------> set -l short no
14	92	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
39	39	--------> set -q _flag_quiet
39	39	--------> set mode quiet
45	45	-------> set -q _flag_all
43	43	-------> set -q _flag_short
38	38	-------> set -q _flag_no_functions
46	963	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
43	43	--------> set -l found 0
24	382	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
33	33	---------> test $selection != files
4	56	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
52	52	----------> functions -q -- $i
7	269	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
206	262	----------> contains -- $i (builtin -n)
56	56	-----------> builtin -n
33	33	--------> set -l paths
9	285	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
32	32	---------> test $multi != yes
110	244	---------> set paths (command -s -- $i)
134	134	----------> command -s -- $i
23	144	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	57	---------> if test $multi != yes
                continue
            ...
27	27	----------> test $multi != yes
22	22	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
29	29	-------> return $res
9176	9176	------> git rev-parse --git-dir >/dev/null 2>&1
47	47	----> return 1
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
65	2033	> fish_right_prompt
87	87	-> set_color $fish_color_autosuggestion 2> /dev/null
1806	1806	-> date "+%H:%M:%S"
75	75	-> set_color normal
48	463	> fish_title
14	415	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
244	370	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
51	91	---> __fish_pwd
40	40	----> pwd
186	2399776	> fzf-file-widget
174	1571	-> set -l commandline (__fzf_parse_commandline)
94	1397	--> __fzf_parse_commandline
210	1015	---> set -l commandline (eval "printf '%s' "(commandline -t))
654	805	----> eval "printf '%s' "(commandline -t)
85	85	-----> commandline -t
66	66	-----> printf '%s'
19	162	---> if [ -z $commandline ]
      # Default to current directory with no --query
      set dir '.'
      set fzf_query ''
    else
      set dir (__fzf_get_dir $commandline)

      if [ "$dir" = "." -a (string sub -l 1 $commandline) != '.' ]
        # if $dir is "." but commandline is not a relative path, this means no file path found
        set fzf_query $commandline
      else
        # Also remove trailing slash after dir, to "split" input properly
        set fzf_query (string replace -r "^$dir/?" '' "$commandline")
      end
    ...
50	50	----> [ -z $commandline ]
47	47	----> set dir '.'
46	46	----> set fzf_query ''
70	70	---> echo $dir
56	56	---> echo $fzf_query
47	47	-> set -l dir $commandline[1]
45	45	-> set -l fzf_query $commandline[2]
43	43	-> test -n "$FZF_CTRL_T_COMMAND"
57	57	-> set -l FZF_CTRL_T_COMMAND "
    command find -L \$dir -mindepth 1 \\( -path \$dir'*/\\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \\) -prune \
    -o -type f -print \
    -o -type d -print \
    -o -type l -print 2> /dev/null | sed 's@^\./@@'"
41	41	-> test -n "$FZF_TMUX_HEIGHT"
40	40	-> set FZF_TMUX_HEIGHT 40%
24	2397607	-> begin
      set -lx FZF_DEFAULT_OPTS "--height $FZF_TMUX_HEIGHT --reverse $FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS"
      eval "$FZF_CTRL_T_COMMAND | "(__fzfcmd)' -m --query "'$fzf_query'"' | while read -l r; set result $result $r; end
    ...
53	53	--> set -lx FZF_DEFAULT_OPTS "--height $FZF_TMUX_HEIGHT --reverse $FZF_DEFAULT_OPTS $FZF_CTRL_T_OPTS"
477	2397530	--> eval "$FZF_CTRL_T_COMMAND | "(__fzfcmd)' -m --query "'$fzf_query'"' | while read -l r; set result $result $r; end
83	461	---> __fzfcmd
44	44	----> test -n "$FZF_TMUX"
40	40	----> set FZF_TMUX 0
38	38	----> test -n "$FZF_TMUX_HEIGHT"
39	39	----> set FZF_TMUX_HEIGHT 40%
28	217	----> if [ -n "$FZF_TMUX_OPTS" ]
      echo "fzf-tmux $FZF_TMUX_OPTS -- "
    else if [ $FZF_TMUX -eq 1 ]
      echo "fzf-tmux -d$FZF_TMUX_HEIGHT -- "
    else
      echo "fzf"
    ...
39	39	-----> [ -n "$FZF_TMUX_OPTS" ]
42	42	-----> [ $FZF_TMUX -eq 1 ]
108	108	-----> echo "fzf"
2396523	2396523	---> command find -L $dir -mindepth 1 \( -path $dir'*/\.*' -o -fstype 'sysfs' -o -fstype 'devfs' -o -fstype 'devtmpfs' \) -prune     -o -type f -print     -o -type d -print     -o -type l -print 2> /dev/null | sed 's@^\./@@' | fzf -m --query ""
69	69	---> read -l r
13	139	-> if [ -z "$result" ]
      commandline -f repaint
      return
    else
      # Remove last token from commandline.
      commandline -t ""
    ...
51	51	--> [ -z "$result" ]
52	52	--> commandline -f repaint
23	23	--> return
41	165	> fish_mode_prompt
47	124	-> fish_default_mode_prompt
7	77	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
38	38	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
86	14586	> fish_prompt
37	37	-> set -l __last_command_exit_status $status
4	34	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
30	30	--> not set -q -g __fish_robbyrussell_functions_defined
98	161	-> set -l cyan (set_color -o cyan)
63	63	--> set_color -o cyan
91	136	-> set -l yellow (set_color -o yellow)
45	45	--> set_color -o yellow
87	132	-> set -l red (set_color -o red)
45	45	--> set_color -o red
89	133	-> set -l green (set_color -o green)
44	44	--> set_color -o green
156	225	-> set -l blue (set_color -o blue)
69	69	--> set_color -o blue
98	147	-> set -l normal (set_color normal)
49	49	--> set_color normal
35	35	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
4	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
113	2123	-> set -l cwd $cyan(basename (prompt_pwd))
1485	2010	--> basename (prompt_pwd)
73	525	---> prompt_pwd
36	36	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
94	168	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
74	74	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	95	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
55	55	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	11167	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
108	11163	--> set -l repo_type (_repo_type)
39	11055	---> _repo_type
7	10965	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
25	275	-----> _is_hg_repo
74	250	------> fish_print_hg_root >/dev/null
9	176	-------> if not command -sq hg
        return 1
    ...
139	139	--------> not command -sq hg
28	28	--------> return 1
44	10683	-----> _is_git_repo
89	1378	------> type -q git
27	27	-------> set -q argv[1]
44	44	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
63	63	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
8	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
43	843	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
15	331	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
4	50	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
46	46	----------> functions -q -- $i
5	234	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
173	229	----------> contains -- $i (builtin -n)
56	56	-----------> builtin -n
29	29	--------> set -l paths
8	240	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	---------> test $multi != yes
93	204	---------> set paths (command -s -- $i)
111	111	----------> command -s -- $i
20	142	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	56	---------> if test $multi != yes
                continue
            ...
27	27	----------> test $multi != yes
22	22	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
9261	9261	------> git rev-parse --git-dir >/dev/null 2>&1
51	51	----> return 1
66	66	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
68	1960	> fish_right_prompt
125	125	-> set_color $fish_color_autosuggestion 2> /dev/null
1702	1702	-> date "+%H:%M:%S"
65	65	-> set_color normal
80	449	> fish_title
11	369	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
52	52	--> not set -q INSIDE_EMACS
184	306	--> echo (status current-command) (__fish_pwd)
37	37	---> status current-command
48	85	---> __fish_pwd
37	37	----> pwd
819	835	> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/cd.fish
16	16	-> function cd --description "Change directory"
    set -l MAX_DIR_HIST 25

    if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    end

    # Skip history in subshells.
    if status --is-command-substitution
        builtin cd $argv
        return $status
    end

    # Avoid set completions.
    set -l previous $PWD

    if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    end

    # allow explicit "cd ." if the mount-point became stale in the meantime
    if test "$argv" = "."
        cd "$PWD"
        return $status
    end

    builtin cd $argv
    set -l cd_status $status

    if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    end

    return $cd_status
...
522	969	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/cd.fish
382	382	-> complete -c cd -a "(__fish_complete_cd)"
65	65	-> complete -c cd -s h -l help -d 'Display help and exit'
430	1483	> __fish_complete_cd
972	988	-> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/__fish_complete_cd.fish
16	16	--> function __fish_complete_cd -d "Completions for the cd command"
    set -q CDPATH[1]
    or return 0 # no CDPATH so rely solely on the core file name completions

    set -l token (commandline -ct)
    if string match -qr '^\.{0,2}/.*' -- $token
        # Absolute path or explicitly relative to the current directory. Rely on the builtin file
        # name completions since we no longer exclude them from the `cd` argument completion.
        return
    end

    # Relative path. Check $CDPATH and use that as the description for any possible matches.
    # We deliberately exclude the `.` path because the core file name completion logic will include
    # it when presenting possible matches.
    set -l cdpath (string match -v '.' -- $CDPATH)

    # Remove the CWD if it is in CDPATH since, again, the core file name completion logic will
    # handle it.
    set -l cdpath (string match -v -- $PWD $cdpath)
    set -q cdpath[1]
    or return 0

    # TODO: There's a subtlety regarding descriptions - if $cdpath[1]/foo and $cdpath[2]/foo
    # exist, we print both but want the first description to win - this currently works, but
    # is not guaranteed.
    for cdpath in $cdpath
        # Replace $HOME with "~".
        set -l desc (string replace -r -- "^$HOME" "~" "$cdpath")
        # This assumes the CDPATH component itself is cd-able.
        for d in $cdpath/$token*/
            # Remove the cdpath component again.
            test -x $d
            and printf "%s\tCDPATH %s\n" (string replace -r "^$cdpath/" "" -- $d) $desc
        end
    end
...
36	36	-> set -q CDPATH[1]
29	29	-> return 0
69	524	> __fish_disable_bracketed_paste 'cd ~/dotfiles/'
455	455	-> printf "\e[?2004l"
61	1677	> fish_title cd\ ~/dotfiles/
12	1616	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
37	37	--> not set -q INSIDE_EMACS
431	1567	--> echo (status current-command) (__fish_pwd)
42	42	---> status current-command
863	1094	---> __fish_pwd
231	231	----> pwd
101	1469	> cd ~/dotfiles/
41	41	-> set -l MAX_DIR_HIST 25
7	685	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
159	678	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
438	438	---> count $argv
43	43	---> test "$argv[1]" = "--"
38	38	---> echo 1
5	32	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
27	27	--> status --is-command-substitution
36	36	-> set -l previous $PWD
5	37	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
32	32	--> test "$argv" = "-"
6	38	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
32	32	--> test "$argv" = "."
123	123	-> builtin cd $argv
39	39	-> set -l cd_status $status
35	309	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
42	42	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
25	25	--> set -q dirprev
26	26	--> set -l dirprev
29	29	--> set -q dirprev[$MAX_DIR_HIST]
24	24	--> set -U -q dirprev
31	31	--> set -g -a dirprev $previous
23	23	--> set -U -q dirnext
23	23	--> set -e dirnext
24	24	--> set -U -q __fish_cd_direction
27	27	--> set -g __fish_cd_direction prev
28	28	-> return $cd_status
49	129	> __fish_enable_bracketed_paste
80	80	-> printf "\e[?2004h"
40	265	> fish_mode_prompt
147	225	-> fish_default_mode_prompt
8	78	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
38	38	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
91	60775	> fish_prompt
35	35	-> set -l __last_command_exit_status $status
4	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
26	26	--> not set -q -g __fish_robbyrussell_functions_defined
150	341	-> set -l cyan (set_color -o cyan)
191	191	--> set_color -o cyan
97	147	-> set -l yellow (set_color -o yellow)
50	50	--> set_color -o yellow
107	152	-> set -l red (set_color -o red)
45	45	--> set_color -o red
106	160	-> set -l green (set_color -o green)
54	54	--> set_color -o green
98	146	-> set -l blue (set_color -o blue)
48	48	--> set_color -o blue
99	177	-> set -l normal (set_color normal)
78	78	--> set_color normal
36	36	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
34	34	-> set -l arrow "$arrow_color➜ "
4	34	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
30	30	--> test "$USER" = 'root'
118	2765	-> set -l cwd $cyan(basename (prompt_pwd))
1605	2647	--> basename (prompt_pwd)
306	1042	---> prompt_pwd
40	40	----> set -l options 'h/help'
42	42	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
28	28	----> set -l fish_prompt_pwd_dir_length 1
75	75	----> set realhome ~
123	387	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
264	264	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	109	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
35	35	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
65	65	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
22	56530	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
124	20348	--> set -l repo_type (_repo_type)
30	20224	---> _repo_type
17	20194	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	406	-----> _is_hg_repo
203	380	------> fish_print_hg_root >/dev/null
9	177	-------> if not command -sq hg
        return 1
    ...
139	139	--------> not command -sq hg
29	29	--------> return 1
51	19662	-----> _is_git_repo
200	1926	------> type -q git
28	28	-------> set -q argv[1]
48	48	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
68	68	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
27	27	-------> set -l selection all
27	27	-------> set -l short no
8	62	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
28	28	--------> set mode quiet
25	25	-------> set -q _flag_all
24	24	-------> set -q _flag_short
25	25	-------> set -q _flag_no_functions
37	1252	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
13	681	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
5	294	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
289	289	----------> functions -q -- $i
4	342	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
284	338	----------> contains -- $i (builtin -n)
54	54	-----------> builtin -n
32	32	--------> set -l paths
11	283	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
123	242	---------> set paths (command -s -- $i)
119	119	----------> command -s -- $i
26	157	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
27	27	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	61	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
23	23	----------> continue
3	33	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	---------> test $found = 0
30	30	-------> return $res
17685	17685	------> git rev-parse --git-dir >/dev/null 2>&1
82	82	-----> echo 'git'
27	27	-----> return 0
108	14344	--> set -l repo_branch $red(_repo_branch_name $repo_type)
42	14236	---> _repo_branch_name $repo_type
38	14194	----> _$argv[1]_branch_name
148	13922	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
13774	13774	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	234	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
124	193	------> echo (string replace -r '^refs/heads/' '' $branch)
69	69	-------> string replace -r '^refs/heads/' '' $branch
42	42	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
4	21774	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
97	21770	---> [ (_is_repo_dirty $repo_type) ]
39	21673	----> _is_repo_dirty $repo_type
37	21634	-----> _is_$argv[1]_dirty
175	21597	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
21422	21422	-------> git status -s --ignore-submodules=dirty 2>/dev/null
62	62	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
68	2251	> fish_right_prompt
118	118	-> set_color $fish_color_autosuggestion 2> /dev/null
1998	1998	-> date "+%H:%M:%S"
67	67	-> set_color normal
42	373	> fish_title
12	331	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
178	290	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
44	81	---> __fish_pwd
37	37	----> pwd
95	426	> __fish_winch_handler SIGWINCH
331	331	-> commandline -f repaint >/dev/null 2>/dev/null
55	563	> fish_mode_prompt
174	508	-> fish_default_mode_prompt
222	334	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-110	68	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
55	178	----> __fish_winch_handler SIGWINCH
123	123	-----> commandline -f repaint >/dev/null 2>/dev/null
44	44	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
128	52445	> fish_prompt
43	43	-> set -l __last_command_exit_status $status
5	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
30	30	--> not set -q -g __fish_robbyrussell_functions_defined
116	306	-> set -l cyan (set_color -o cyan)
190	190	--> set_color -o cyan
104	156	-> set -l yellow (set_color -o yellow)
52	52	--> set_color -o yellow
98	148	-> set -l red (set_color -o red)
50	50	--> set_color -o red
96	146	-> set -l green (set_color -o green)
50	50	--> set_color -o green
96	144	-> set -l blue (set_color -o blue)
48	48	--> set_color -o blue
140	208	-> set -l normal (set_color normal)
68	68	--> set_color normal
43	43	-> set -l arrow_color "$green"
4	39	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
35	35	--> test $__last_command_exit_status != 0
39	39	-> set -l arrow "$arrow_color➜ "
4	38	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
34	34	--> test "$USER" = 'root'
195	3050	-> set -l cwd $cyan(basename (prompt_pwd))
1874	2855	--> basename (prompt_pwd)
217	981	---> prompt_pwd
39	39	----> set -l options 'h/help'
43	43	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	34	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
67	67	----> set -q fish_prompt_pwd_dir_length
35	35	----> set -l fish_prompt_pwd_dir_length 1
39	39	----> set realhome ~
162	383	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
221	221	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	124	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
44	44	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
69	69	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
26	47797	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
169	18037	--> set -l repo_type (_repo_type)
42	17868	---> _repo_type
38	17826	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
54	665	-----> _is_hg_repo
441	611	------> fish_print_hg_root >/dev/null
10	170	-------> if not command -sq hg
        return 1
    ...
132	132	--------> not command -sq hg
28	28	--------> return 1
86	16628	-----> _is_git_repo
379	3124	------> type -q git
43	43	-------> set -q argv[1]
50	50	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
106	106	-------> argparse -n type -x t,p,P $options -- $argv
4	51	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
47	47	--------> set -q _flag_help
53	53	-------> set -l res 1
27	27	-------> set -l mode normal
47	47	-------> set -l multi no
40	40	-------> set -l selection all
94	94	-------> set -l short no
15	156	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
104	104	--------> set -q _flag_quiet
37	37	--------> set mode quiet
39	39	-------> set -q _flag_all
58	58	-------> set -q _flag_short
132	132	-------> set -q _flag_no_functions
135	1820	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
145	145	--------> set -l found 0
19	923	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
37	37	---------> test $selection != files
4	400	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
396	396	----------> functions -q -- $i
6	467	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
406	461	----------> contains -- $i (builtin -n)
55	55	-----------> builtin -n
59	59	--------> set -l paths
11	374	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
31	31	---------> test $multi != yes
149	332	---------> set paths (command -s -- $i)
183	183	----------> command -s -- $i
25	153	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	61	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
23	23	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
29	29	-------> return $res
13418	13418	------> git rev-parse --git-dir >/dev/null 2>&1
453	453	-----> echo 'git'
42	42	-----> return 0
188	13621	--> set -l repo_branch $red(_repo_branch_name $repo_type)
79	13433	---> _repo_branch_name $repo_type
64	13354	----> _$argv[1]_branch_name
198	12851	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
12653	12653	------> git symbolic-ref --quiet HEAD 2>/dev/null
14	439	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
50	50	------> set -q branch[1]
287	375	------> echo (string replace -r '^refs/heads/' '' $branch)
88	88	-------> string replace -r '^refs/heads/' '' $branch
73	73	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
11	16040	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
332	16029	---> [ (_is_repo_dirty $repo_type) ]
48	15697	----> _is_repo_dirty $repo_type
47	15649	-----> _is_$argv[1]_dirty
301	15602	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
15301	15301	-------> git status -s --ignore-submodules=dirty 2>/dev/null
125	125	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
226	3443	> fish_right_prompt
125	125	-> set_color $fish_color_autosuggestion 2> /dev/null
2906	2906	-> date "+%H:%M:%S"
186	186	-> set_color normal
46	651	> fish_title
10	605	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
225	563	--> echo (status current-command) (__fish_pwd)
36	36	---> status current-command
167	302	---> __fish_pwd
135	135	----> pwd
66	186	> __fish_winch_handler SIGWINCH
120	120	-> commandline -f repaint >/dev/null 2>/dev/null
47	317	> fish_mode_prompt
38	270	-> fish_default_mode_prompt
150	232	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-76	46	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
30	122	----> __fish_winch_handler SIGWINCH
92	92	-----> commandline -f repaint >/dev/null 2>/dev/null
36	36	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
111	43405	> fish_prompt
37	37	-> set -l __last_command_exit_status $status
4	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
26	26	--> not set -q -g __fish_robbyrussell_functions_defined
147	202	-> set -l cyan (set_color -o cyan)
55	55	--> set_color -o cyan
141	238	-> set -l yellow (set_color -o yellow)
97	97	--> set_color -o yellow
98	149	-> set -l red (set_color -o red)
51	51	--> set_color -o red
94	141	-> set -l green (set_color -o green)
47	47	--> set_color -o green
117	168	-> set -l blue (set_color -o blue)
51	51	--> set_color -o blue
110	153	-> set -l normal (set_color normal)
43	43	--> set_color normal
34	34	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
36	36	-> set -l arrow "$arrow_color➜ "
3	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
116	2528	-> set -l cwd $cyan(basename (prompt_pwd))
1861	2412	--> basename (prompt_pwd)
73	551	---> prompt_pwd
38	38	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	31	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
27	27	-----> set -q _flag_help
34	34	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
35	35	----> set realhome ~
101	171	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
70	70	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	99	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
58	58	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
39	39409	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
113	12500	--> set -l repo_type (_repo_type)
31	12387	---> _repo_type
16	12356	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	263	-----> _is_hg_repo
67	237	------> fish_print_hg_root >/dev/null
10	170	-------> if not command -sq hg
        return 1
    ...
134	134	--------> not command -sq hg
26	26	--------> return 1
49	11972	-----> _is_git_repo
93	1493	------> type -q git
26	26	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
76	76	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
30	30	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
8	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
25	25	--------> set mode quiet
48	48	-------> set -q _flag_all
53	53	-------> set -q _flag_short
34	34	-------> set -q _flag_no_functions
32	869	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
8	337	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	54	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
50	50	----------> functions -q -- $i
6	245	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
192	239	----------> contains -- $i (builtin -n)
47	47	-----------> builtin -n
34	34	--------> set -l paths
10	262	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
98	223	---------> set paths (command -s -- $i)
125	125	----------> command -s -- $i
21	145	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	58	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
22	22	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
27	27	-------> return $res
10430	10430	------> git rev-parse --git-dir >/dev/null 2>&1
78	78	-----> echo 'git'
27	27	-----> return 0
222	12389	--> set -l repo_branch $red(_repo_branch_name $repo_type)
44	12167	---> _repo_branch_name $repo_type
54	12123	----> _$argv[1]_branch_name
274	11709	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11435	11435	------> git symbolic-ref --quiet HEAD 2>/dev/null
11	360	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
210	317	------> echo (string replace -r '^refs/heads/' '' $branch)
107	107	-------> string replace -r '^refs/heads/' '' $branch
71	71	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
8	14410	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
210	14402	---> [ (_is_repo_dirty $repo_type) ]
103	14192	----> _is_repo_dirty $repo_type
61	14089	-----> _is_$argv[1]_dirty
218	14028	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
13810	13810	-------> git status -s --ignore-submodules=dirty 2>/dev/null
99	99	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
116	2979	> fish_right_prompt
114	114	-> set_color $fish_color_autosuggestion 2> /dev/null
2611	2611	-> date "+%H:%M:%S"
138	138	-> set_color normal
58	468	> fish_title
10	410	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
36	36	--> not set -q INSIDE_EMACS
233	364	--> echo (status current-command) (__fish_pwd)
36	36	---> status current-command
55	95	---> __fish_pwd
40	40	----> pwd
77	216	> __fish_winch_handler SIGWINCH
139	139	-> commandline -f repaint >/dev/null 2>/dev/null
61	359	> fish_mode_prompt
53	298	-> fish_default_mode_prompt
151	245	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-71	52	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
30	123	----> __fish_winch_handler SIGWINCH
93	93	-----> commandline -f repaint >/dev/null 2>/dev/null
42	42	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
155	40820	> fish_prompt
122	122	-> set -l __last_command_exit_status $status
7	87	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
80	80	--> not set -q -g __fish_robbyrussell_functions_defined
167	256	-> set -l cyan (set_color -o cyan)
89	89	--> set_color -o cyan
207	319	-> set -l yellow (set_color -o yellow)
112	112	--> set_color -o yellow
186	277	-> set -l red (set_color -o red)
91	91	--> set_color -o red
177	317	-> set -l green (set_color -o green)
140	140	--> set_color -o green
126	185	-> set -l blue (set_color -o blue)
59	59	--> set_color -o blue
133	183	-> set -l normal (set_color normal)
50	50	--> set_color normal
42	42	-> set -l arrow_color "$green"
4	39	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
35	35	--> test $__last_command_exit_status != 0
38	38	-> set -l arrow "$arrow_color➜ "
6	92	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
86	86	--> test "$USER" = 'root'
215	2877	-> set -l cwd $cyan(basename (prompt_pwd))
1958	2662	--> basename (prompt_pwd)
92	704	---> prompt_pwd
43	43	----> set -l options 'h/help'
64	64	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	38	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
33	33	-----> set -q _flag_help
28	28	----> set -q fish_prompt_pwd_dir_length
32	32	----> set -l fish_prompt_pwd_dir_length 1
39	39	----> set realhome ~
159	243	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
84	84	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
13	125	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
41	41	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
71	71	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
25	35752	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
159	12668	--> set -l repo_type (_repo_type)
48	12509	---> _repo_type
21	12461	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
32	331	-----> _is_hg_repo
90	299	------> fish_print_hg_root >/dev/null
14	209	-------> if not command -sq hg
        return 1
    ...
161	161	--------> not command -sq hg
34	34	--------> return 1
48	11913	-----> _is_git_repo
157	2116	------> type -q git
30	30	-------> set -q argv[1]
52	52	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
80	80	-------> argparse -n type -x t,p,P $options -- $argv
8	114	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
106	106	--------> set -q _flag_help
48	48	-------> set -l res 1
41	41	-------> set -l mode normal
37	37	-------> set -l multi no
29	29	-------> set -l selection all
27	27	-------> set -l short no
9	61	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	--------> set -q _flag_quiet
27	27	--------> set mode quiet
27	27	-------> set -q _flag_all
24	24	-------> set -q _flag_short
45	45	-------> set -q _flag_no_functions
37	1316	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
45	45	--------> set -l found 0
18	457	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
33	33	---------> test $selection != files
6	113	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
107	107	----------> functions -q -- $i
6	293	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
227	287	----------> contains -- $i (builtin -n)
60	60	-----------> builtin -n
34	34	--------> set -l paths
11	481	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
64	64	---------> test $multi != yes
192	406	---------> set paths (command -s -- $i)
214	214	----------> command -s -- $i
28	216	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
49	49	---------> set res 0
42	42	---------> set found 1
15	15	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	82	---------> if test $multi != yes
                continue
            ...
43	43	----------> test $multi != yes
30	30	----------> continue
4	46	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
42	42	---------> test $found = 0
28	28	-------> return $res
9749	9749	------> git rev-parse --git-dir >/dev/null 2>&1
157	157	-----> echo 'git'
39	39	-----> return 0
109	10958	--> set -l repo_branch $red(_repo_branch_name $repo_type)
42	10849	---> _repo_branch_name $repo_type
38	10807	----> _$argv[1]_branch_name
146	10540	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10394	10394	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	229	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
122	188	------> echo (string replace -r '^refs/heads/' '' $branch)
66	66	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
15	12058	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
119	12043	---> [ (_is_repo_dirty $repo_type) ]
38	11924	----> _is_repo_dirty $repo_type
37	11886	-----> _is_$argv[1]_dirty
202	11849	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11647	11647	-------> git status -s --ignore-submodules=dirty 2>/dev/null
79	79	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
63	1942	> fish_right_prompt
95	95	-> set_color $fish_color_autosuggestion 2> /dev/null
1717	1717	-> date "+%H:%M:%S"
67	67	-> set_color normal
41	353	> fish_title
10	312	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
158	272	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
44	81	---> __fish_pwd
37	37	----> pwd
109	592	> __fish_disable_bracketed_paste clear
483	483	-> printf "\e[?2004l"
68	582	> fish_title clear
13	514	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
39	39	--> not set -q INSIDE_EMACS
295	462	--> echo (status current-command) (__fish_pwd)
59	59	---> status current-command
60	108	---> __fish_pwd
48	48	----> pwd
4359	4359	> clear
47	109	> __fish_enable_bracketed_paste
62	62	-> printf "\e[?2004h"
47	195	> fish_mode_prompt
56	148	-> fish_default_mode_prompt
8	92	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
47	47	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
37	37	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
151	42186	> fish_prompt
48	48	-> set -l __last_command_exit_status $status
5	38	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
33	33	--> not set -q -g __fish_robbyrussell_functions_defined
157	224	-> set -l cyan (set_color -o cyan)
67	67	--> set_color -o cyan
126	189	-> set -l yellow (set_color -o yellow)
63	63	--> set_color -o yellow
137	189	-> set -l red (set_color -o red)
52	52	--> set_color -o red
133	196	-> set -l green (set_color -o green)
63	63	--> set_color -o green
104	158	-> set -l blue (set_color -o blue)
54	54	--> set_color -o blue
111	163	-> set -l normal (set_color normal)
52	52	--> set_color normal
38	38	-> set -l arrow_color "$green"
5	37	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
32	32	--> test $__last_command_exit_status != 0
36	36	-> set -l arrow "$arrow_color➜ "
3	39	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
117	2365	-> set -l cwd $cyan(basename (prompt_pwd))
1634	2248	--> basename (prompt_pwd)
79	614	---> prompt_pwd
45	45	----> set -l options 'h/help'
44	44	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	33	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
27	27	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
37	37	----> set realhome ~
109	190	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
81	81	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	129	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
36	36	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
81	81	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
23	38224	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
139	12306	--> set -l repo_type (_repo_type)
36	12167	---> _repo_type
14	12131	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
30	405	-----> _is_hg_repo
127	375	------> fish_print_hg_root >/dev/null
21	248	-------> if not command -sq hg
        return 1
    ...
163	163	--------> not command -sq hg
64	64	--------> return 1
69	11614	-----> _is_git_repo
111	1629	------> type -q git
28	28	-------> set -q argv[1]
80	80	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
63	63	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
27	27	-------> set -l selection all
25	25	-------> set -l short no
11	151	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
40	40	--------> set -q _flag_quiet
100	100	--------> set mode quiet
30	30	-------> set -q _flag_all
24	24	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
40	933	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
63	63	--------> set -l found 0
22	365	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
51	51	---------> test $selection != files
4	54	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
50	50	----------> functions -q -- $i
5	238	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
182	233	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
29	29	--------> set -l paths
8	259	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
94	222	---------> set paths (command -s -- $i)
128	128	----------> command -s -- $i
22	147	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	61	---------> if test $multi != yes
                continue
            ...
31	31	----------> test $multi != yes
23	23	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
28	28	-------> return $res
9916	9916	------> git rev-parse --git-dir >/dev/null 2>&1
72	72	-----> echo 'git'
26	26	-----> return 0
116	14042	--> set -l repo_branch $red(_repo_branch_name $repo_type)
55	13926	---> _repo_branch_name $repo_type
42	13871	----> _$argv[1]_branch_name
183	13557	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
13374	13374	------> git symbolic-ref --quiet HEAD 2>/dev/null
11	272	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
34	34	------> set -q branch[1]
156	227	------> echo (string replace -r '^refs/heads/' '' $branch)
71	71	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
7	11810	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
121	11803	---> [ (_is_repo_dirty $repo_type) ]
46	11682	----> _is_repo_dirty $repo_type
42	11636	-----> _is_$argv[1]_dirty
186	11594	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11408	11408	-------> git status -s --ignore-submodules=dirty 2>/dev/null
91	91	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
75	1913	> fish_right_prompt
94	94	-> set_color $fish_color_autosuggestion 2> /dev/null
1684	1684	-> date "+%H:%M:%S"
60	60	-> set_color normal
53	369	> fish_title
8	316	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
157	275	--> echo (status current-command) (__fish_pwd)
38	38	---> status current-command
43	80	---> __fish_pwd
37	37	----> pwd
68	134	> __fish_disable_bracketed_paste 'cd ~/dotfiles'
66	66	-> printf "\e[?2004l"
79	665	> fish_title cd\ ~/dotfiles
13	586	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
37	37	--> not set -q INSIDE_EMACS
286	536	--> echo (status current-command) (__fish_pwd)
81	81	---> status current-command
101	169	---> __fish_pwd
68	68	----> pwd
91	1028	> cd ~/dotfiles
35	35	-> set -l MAX_DIR_HIST 25
6	417	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
124	411	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
212	212	---> count $argv
40	40	---> test "$argv[1]" = "--"
35	35	---> echo 1
5	31	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
26	26	--> status --is-command-substitution
34	34	-> set -l previous $PWD
20	50	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
30	30	--> test "$argv" = "-"
9	129	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
120	120	--> test "$argv" = "."
76	76	-> builtin cd $argv
37	37	-> set -l cd_status $status
7	72	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
65	65	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
56	56	-> return $cd_status
36	84	> __fish_enable_bracketed_paste
48	48	-> printf "\e[?2004h"
40	151	> fish_mode_prompt
35	111	-> fish_default_mode_prompt
8	76	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
36	36	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
103	39335	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	29	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
25	25	--> not set -q -g __fish_robbyrussell_functions_defined
102	150	-> set -l cyan (set_color -o cyan)
48	48	--> set_color -o cyan
90	138	-> set -l yellow (set_color -o yellow)
48	48	--> set_color -o yellow
119	163	-> set -l red (set_color -o red)
44	44	--> set_color -o red
94	139	-> set -l green (set_color -o green)
45	45	--> set_color -o green
128	171	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
100	149	-> set -l normal (set_color normal)
49	49	--> set_color normal
35	35	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
4	33	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
29	29	--> test "$USER" = 'root'
120	2068	-> set -l cwd $cyan(basename (prompt_pwd))
1437	1948	--> basename (prompt_pwd)
64	511	---> prompt_pwd
33	33	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
23	23	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
97	166	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
69	69	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	96	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
23	35942	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
251	13519	--> set -l repo_type (_repo_type)
35	13268	---> _repo_type
17	13233	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
25	321	-----> _is_hg_repo
101	296	------> fish_print_hg_root >/dev/null
19	195	-------> if not command -sq hg
        return 1
    ...
147	147	--------> not command -sq hg
29	29	--------> return 1
51	12788	-----> _is_git_repo
96	1457	------> type -q git
27	27	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
62	62	-------> argparse -n type -x t,p,P $options -- $argv
3	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
7	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
26	26	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
32	907	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
15	323	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
3	49	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
46	46	----------> functions -q -- $i
5	229	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
177	224	----------> contains -- $i (builtin -n)
47	47	-----------> builtin -n
29	29	--------> set -l paths
8	246	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
92	209	---------> set paths (command -s -- $i)
117	117	----------> command -s -- $i
21	186	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
27	27	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	102	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
66	66	----------> continue
8	64	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
56	56	---------> test $found = 0
38	38	-------> return $res
11280	11280	------> git rev-parse --git-dir >/dev/null 2>&1
77	77	-----> echo 'git'
30	30	-----> return 0
172	11127	--> set -l repo_branch $red(_repo_branch_name $repo_type)
88	10955	---> _repo_branch_name $repo_type
61	10867	----> _$argv[1]_branch_name
160	10588	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10428	10428	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	218	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
114	177	------> echo (string replace -r '^refs/heads/' '' $branch)
63	63	-------> string replace -r '^refs/heads/' '' $branch
58	58	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11215	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
114	11210	---> [ (_is_repo_dirty $repo_type) ]
57	11096	----> _is_repo_dirty $repo_type
55	11039	-----> _is_$argv[1]_dirty
199	10984	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10785	10785	-------> git status -s --ignore-submodules=dirty 2>/dev/null
111	111	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
101	2029	> fish_right_prompt
101	101	-> set_color $fish_color_autosuggestion 2> /dev/null
1765	1765	-> date "+%H:%M:%S"
62	62	-> set_color normal
40	373	> fish_title
11	333	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
179	291	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
43	79	---> __fish_pwd
36	36	----> pwd
217	282	> __fish_complete_cd
38	38	-> set -q CDPATH[1]
27	27	-> return 0
73	500	> __fish_disable_bracketed_paste ls
427	427	-> printf "\e[?2004l"
61	706	> fish_title ls
10	645	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
45	45	--> not set -q INSIDE_EMACS
265	590	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
154	290	---> __fish_pwd
136	136	----> pwd
932	14171	> ls
351	4542	-> isatty stdout
40	40	--> set -l options 'h/help'
42	42	--> argparse -n isatty $options -- $argv
7	32	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
25	25	---> set -q _flag_help
5	30	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
25	25	---> set -q argv[2]
26	26	--> set -l fd
36	77	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
41	41	---> set fd 1
3944	3944	--> command [ -t "$fd" ]
66	66	-> set -a opt -F
8631	8631	-> command ls $opt $argv
60	241	> __fish_enable_bracketed_paste
181	181	-> printf "\e[?2004h"
44	287	> fish_mode_prompt
160	243	-> fish_default_mode_prompt
7	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
43	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
104	40089	> fish_prompt
37	37	-> set -l __last_command_exit_status $status
3	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
175	428	-> set -l cyan (set_color -o cyan)
253	253	--> set_color -o cyan
209	271	-> set -l yellow (set_color -o yellow)
62	62	--> set_color -o yellow
150	201	-> set -l red (set_color -o red)
51	51	--> set_color -o red
137	182	-> set -l green (set_color -o green)
45	45	--> set_color -o green
131	175	-> set -l blue (set_color -o blue)
44	44	--> set_color -o blue
132	173	-> set -l normal (set_color normal)
41	41	--> set_color normal
33	33	-> set -l arrow_color "$green"
3	32	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
29	29	--> test $__last_command_exit_status != 0
32	32	-> set -l arrow "$arrow_color➜ "
3	38	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
35	35	--> test "$USER" = 'root'
116	2661	-> set -l cwd $cyan(basename (prompt_pwd))
1720	2545	--> basename (prompt_pwd)
221	825	---> prompt_pwd
55	55	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	43	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
39	39	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
32	32	----> set realhome ~
109	287	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
178	178	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	96	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
56	56	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
17	35629	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
117	13624	--> set -l repo_type (_repo_type)
38	13507	---> _repo_type
17	13469	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
29	394	-----> _is_hg_repo
204	365	------> fish_print_hg_root >/dev/null
9	161	-------> if not command -sq hg
        return 1
    ...
125	125	--------> not command -sq hg
27	27	--------> return 1
48	12959	-----> _is_git_repo
201	1853	------> type -q git
27	27	-------> set -q argv[1]
48	48	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
67	67	-------> argparse -n type -x t,p,P $options -- $argv
3	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
27	27	-------> set -l selection all
26	26	-------> set -l short no
8	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
29	1193	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
14	687	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	256	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
252	252	----------> functions -q -- $i
5	387	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
317	382	----------> contains -- $i (builtin -n)
65	65	-----------> builtin -n
30	30	--------> set -l paths
8	247	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
95	210	---------> set paths (command -s -- $i)
115	115	----------> command -s -- $i
21	142	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	57	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
22	22	----------> continue
5	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
28	28	-------> return $res
11058	11058	------> git rev-parse --git-dir >/dev/null 2>&1
73	73	-----> echo 'git'
26	26	-----> return 0
118	10537	--> set -l repo_branch $red(_repo_branch_name $repo_type)
60	10419	---> _repo_branch_name $repo_type
50	10359	----> _$argv[1]_branch_name
169	10004	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9835	9835	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	305	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
42	42	------> set -q branch[1]
162	251	------> echo (string replace -r '^refs/heads/' '' $branch)
89	89	-------> string replace -r '^refs/heads/' '' $branch
49	49	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11402	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
107	11397	---> [ (_is_repo_dirty $repo_type) ]
44	11290	----> _is_repo_dirty $repo_type
37	11246	-----> _is_$argv[1]_dirty
152	11209	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11057	11057	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
78	2054	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
1816	1816	-> date "+%H:%M:%S"
69	69	-> set_color normal
39	343	> fish_title
9	304	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
154	266	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
43	80	---> __fish_pwd
37	37	----> pwd
59	163	> __fish_disable_bracketed_paste 'ls -l'
104	104	-> printf "\e[?2004l"
59	573	> fish_title ls\ -l
14	514	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
39	39	--> not set -q INSIDE_EMACS
256	461	--> echo (status current-command) (__fish_pwd)
42	42	---> status current-command
76	163	---> __fish_pwd
87	87	----> pwd
219	9589	> ls -l
179	3889	-> isatty stdout
48	48	--> set -l options 'h/help'
53	53	--> argparse -n isatty $options -- $argv
10	78	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
68	68	---> set -q _flag_help
7	45	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
38	38	---> set -q argv[2]
36	36	--> set -l fd
22	57	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
35	35	---> set fd 1
3393	3393	--> command [ -t "$fd" ]
64	64	-> set -a opt -F
5417	5417	-> command ls $opt $argv
114	244	> __fish_enable_bracketed_paste
130	130	-> printf "\e[?2004h"
48	187	> fish_mode_prompt
50	139	-> fish_default_mode_prompt
8	89	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
47	47	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
34	34	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
122	39493	> fish_prompt
46	46	-> set -l __last_command_exit_status $status
4	34	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
30	30	--> not set -q -g __fish_robbyrussell_functions_defined
173	260	-> set -l cyan (set_color -o cyan)
87	87	--> set_color -o cyan
218	293	-> set -l yellow (set_color -o yellow)
75	75	--> set_color -o yellow
130	186	-> set -l red (set_color -o red)
56	56	--> set_color -o red
147	202	-> set -l green (set_color -o green)
55	55	--> set_color -o green
177	261	-> set -l blue (set_color -o blue)
84	84	--> set_color -o blue
152	235	-> set -l normal (set_color normal)
83	83	--> set_color normal
39	39	-> set -l arrow_color "$green"
6	45	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
39	39	--> test $__last_command_exit_status != 0
49	49	-> set -l arrow "$arrow_color➜ "
3	43	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
40	40	--> test "$USER" = 'root'
142	2702	-> set -l cwd $cyan(basename (prompt_pwd))
1653	2560	--> basename (prompt_pwd)
134	907	---> prompt_pwd
56	56	----> set -l options 'h/help'
54	54	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
8	77	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
69	69	-----> set -q _flag_help
60	60	----> set -q fish_prompt_pwd_dir_length
33	33	----> set -l fish_prompt_pwd_dir_length 1
36	36	----> set realhome ~
176	283	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
107	107	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
14	174	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
69	69	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
91	91	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
23	34912	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
152	13585	--> set -l repo_type (_repo_type)
53	13433	---> _repo_type
19	13380	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
29	281	-----> _is_hg_repo
74	252	------> fish_print_hg_root >/dev/null
9	178	-------> if not command -sq hg
        return 1
    ...
140	140	--------> not command -sq hg
29	29	--------> return 1
46	12981	-----> _is_git_repo
96	1875	------> type -q git
26	26	-------> set -q argv[1]
49	49	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
135	135	-------> argparse -n type -x t,p,P $options -- $argv
5	65	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
60	60	--------> set -q _flag_help
36	36	-------> set -l res 1
27	27	-------> set -l mode normal
27	27	-------> set -l multi no
27	27	-------> set -l selection all
26	26	-------> set -l short no
9	63	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
28	28	--------> set -q _flag_quiet
26	26	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
38	1201	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
24	616	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
78	78	---------> test $selection != files
4	75	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
71	71	----------> functions -q -- $i
7	439	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
380	432	----------> contains -- $i (builtin -n)
52	52	-----------> builtin -n
34	34	--------> set -l paths
10	304	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
31	31	---------> test $multi != yes
117	263	---------> set paths (command -s -- $i)
146	146	----------> command -s -- $i
24	151	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
29	29	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	59	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
23	23	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
11060	11060	------> git rev-parse --git-dir >/dev/null 2>&1
72	72	-----> echo 'git'
27	27	-----> return 0
144	9961	--> set -l repo_branch $red(_repo_branch_name $repo_type)
61	9817	---> _repo_branch_name $repo_type
37	9756	----> _$argv[1]_branch_name
140	9492	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9352	9352	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	227	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
117	186	------> echo (string replace -r '^refs/heads/' '' $branch)
69	69	-------> string replace -r '^refs/heads/' '' $branch
51	51	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11292	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
102	11287	---> [ (_is_repo_dirty $repo_type) ]
39	11185	----> _is_repo_dirty $repo_type
34	11146	-----> _is_$argv[1]_dirty
140	11112	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10972	10972	-------> git status -s --ignore-submodules=dirty 2>/dev/null
64	64	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
69	1935	> fish_right_prompt
90	90	-> set_color $fish_color_autosuggestion 2> /dev/null
1703	1703	-> date "+%H:%M:%S"
73	73	-> set_color normal
67	410	> fish_title
11	343	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
44	44	--> not set -q INSIDE_EMACS
169	288	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
47	85	---> __fish_pwd
38	38	----> pwd
726	5141	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/mkdir.fish
42	4079	-> if mkdir --version >/dev/null 2>/dev/null
    complete -c mkdir -l version -d 'Output version'
    complete -c mkdir -s m -l mode -d 'Set file mode (as in chmod)' -x
    complete -c mkdir -s p -l parents -d 'Make parent directories as needed'
    complete -c mkdir -s v -l verbose -d 'Print a message for each created directory'
    complete -c mkdir -l help -d 'Display help'

else
    complete -c mkdir -s m -d 'Set file mode (as in chmod)' -x
    complete -c mkdir -s p -d 'Make parent directories as needed'
    complete -c mkdir -s v -d 'Print a message for each created directory'
...
3642	3642	--> mkdir --version >/dev/null 2>/dev/null
250	250	--> complete -c mkdir -s m -d 'Set file mode (as in chmod)' -x
92	92	--> complete -c mkdir -s p -d 'Make parent directories as needed'
53	53	--> complete -c mkdir -s v -d 'Print a message for each created directory'
7	336	-> if command -s sestatus >/dev/null 2>/dev/null
    complete -c mkdir -l context -s Z -d 'Set SELinux security context of each created directory to the default type'
...
329	329	--> command -s sestatus >/dev/null 2>/dev/null
280	14023	> __fish_cancel_commandline
154	154	-> commandline -f cancel
113	152	-> set -l cmd (commandline)
39	39	--> commandline
30	13397	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
36	36	--> test -n "$cmd"
51	51	--> commandline -C 1000000
10	545	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
27	27	---> set -q fish_color_cancel
290	508	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
170	170	----> set_color $fish_color_cancel
48	48	----> set_color normal
22	6738	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
888	888	---> command -sq tput
240	5828	---> echo -n (tput el; or tput ce)
5588	5588	----> tput el
171	5673	--> for i in (seq (commandline -L))
            echo ""
        ...
5362	5422	---> seq (commandline -L)
60	60	----> commandline -L
80	80	---> echo ""
56	56	--> commandline ""
268	268	--> emit fish_cancel
40	40	-> commandline -f repaint
48	303	> fish_mode_prompt
169	255	-> fish_default_mode_prompt
8	86	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
45	45	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
143	41816	> fish_prompt
40	40	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
121	176	-> set -l cyan (set_color -o cyan)
55	55	--> set_color -o cyan
138	244	-> set -l yellow (set_color -o yellow)
106	106	--> set_color -o yellow
111	164	-> set -l red (set_color -o red)
53	53	--> set_color -o red
94	142	-> set -l green (set_color -o green)
48	48	--> set_color -o green
103	151	-> set -l blue (set_color -o blue)
48	48	--> set_color -o blue
103	152	-> set -l normal (set_color normal)
49	49	--> set_color normal
59	59	-> set -l arrow_color "$green"
5	51	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
46	46	--> test $__last_command_exit_status != 0
43	43	-> set -l arrow "$arrow_color➜ "
5	76	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
71	71	--> test "$USER" = 'root'
146	3122	-> set -l cwd $cyan(basename (prompt_pwd))
1709	2976	--> basename (prompt_pwd)
199	1267	---> prompt_pwd
37	37	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
171	617	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
446	446	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
27	257	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
79	79	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
151	151	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
18	37157	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
142	13511	--> set -l repo_type (_repo_type)
48	13369	---> _repo_type
21	13321	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
45	535	-----> _is_hg_repo
260	490	------> fish_print_hg_root >/dev/null
9	230	-------> if not command -sq hg
        return 1
    ...
179	179	--------> not command -sq hg
42	42	--------> return 1
48	12599	-----> _is_git_repo
201	2170	------> type -q git
29	29	-------> set -q argv[1]
50	50	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
68	68	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
33	33	-------> set -l multi no
28	28	-------> set -l selection all
40	40	-------> set -l short no
8	75	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
45	45	--------> set mode quiet
24	24	-------> set -q _flag_all
37	37	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
33	1453	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
16	841	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
4	258	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
254	254	----------> functions -q -- $i
7	535	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
444	528	----------> contains -- $i (builtin -n)
84	84	-----------> builtin -n
44	44	--------> set -l paths
10	330	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
32	32	---------> test $multi != yes
157	288	---------> set paths (command -s -- $i)
131	131	----------> command -s -- $i
24	147	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	59	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
23	23	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
10381	10381	------> git rev-parse --git-dir >/dev/null 2>&1
90	90	-----> echo 'git'
76	76	-----> return 0
156	11685	--> set -l repo_branch $red(_repo_branch_name $repo_type)
78	11529	---> _repo_branch_name $repo_type
86	11451	----> _$argv[1]_branch_name
247	11123	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10876	10876	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	242	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
35	35	------> set -q branch[1]
130	198	------> echo (string replace -r '^refs/heads/' '' $branch)
68	68	-------> string replace -r '^refs/heads/' '' $branch
45	45	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11898	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
105	11893	---> [ (_is_repo_dirty $repo_type) ]
42	11788	----> _is_repo_dirty $repo_type
37	11746	-----> _is_$argv[1]_dirty
162	11709	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11547	11547	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
164	2120	> fish_right_prompt
89	89	-> set_color $fish_color_autosuggestion 2> /dev/null
1807	1807	-> date "+%H:%M:%S"
60	60	-> set_color normal
40	564	> fish_title
9	524	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
159	484	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
156	293	---> __fish_pwd
137	137	----> pwd
211	279	> __fish_complete_cd
40	40	-> set -q CDPATH[1]
28	28	-> return 0
81	363	> __fish_disable_bracketed_paste 'cd nvim/'
282	282	-> printf "\e[?2004l"
66	1036	> fish_title cd\ nvim/
12	970	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
36	36	--> not set -q INSIDE_EMACS
362	922	--> echo (status current-command) (__fish_pwd)
44	44	---> status current-command
303	516	---> __fish_pwd
213	213	----> pwd
112	1369	> cd nvim/
39	39	-> set -l MAX_DIR_HIST 25
10	599	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
198	589	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
303	303	---> count $argv
45	45	---> test "$argv[1]" = "--"
43	43	---> echo 1
6	37	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
31	31	--> status --is-command-substitution
37	37	-> set -l previous $PWD
5	35	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
30	30	--> test "$argv" = "-"
5	33	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
28	28	--> test "$argv" = "."
90	90	-> builtin cd $argv
38	38	-> set -l cd_status $status
38	317	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
44	44	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
28	28	--> set -q dirprev
32	32	--> set -q dirprev[$MAX_DIR_HIST]
26	26	--> set -U -q dirprev
39	39	--> set -g -a dirprev $previous
25	25	--> set -U -q dirnext
25	25	--> set -e dirnext
25	25	--> set -U -q __fish_cd_direction
35	35	--> set -g __fish_cd_direction prev
32	32	-> return $cd_status
65	169	> __fish_enable_bracketed_paste
104	104	-> printf "\e[?2004h"
53	294	> fish_mode_prompt
158	241	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
96	40721	> fish_prompt
35	35	-> set -l __last_command_exit_status $status
4	29	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
25	25	--> not set -q -g __fish_robbyrussell_functions_defined
128	287	-> set -l cyan (set_color -o cyan)
159	159	--> set_color -o cyan
123	186	-> set -l yellow (set_color -o yellow)
63	63	--> set_color -o yellow
135	220	-> set -l red (set_color -o red)
85	85	--> set_color -o red
116	171	-> set -l green (set_color -o green)
55	55	--> set_color -o green
96	151	-> set -l blue (set_color -o blue)
55	55	--> set_color -o blue
112	159	-> set -l normal (set_color normal)
47	47	--> set_color normal
38	38	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
35	35	-> set -l arrow "$arrow_color➜ "
4	33	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
29	29	--> test "$USER" = 'root'
115	2482	-> set -l cwd $cyan(basename (prompt_pwd))
1619	2367	--> basename (prompt_pwd)
174	748	---> prompt_pwd
34	34	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
107	283	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
176	176	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	104	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
62	62	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
17	36700	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
207	12932	--> set -l repo_type (_repo_type)
29	12725	---> _repo_type
17	12696	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	390	-----> _is_hg_repo
191	364	------> fish_print_hg_root >/dev/null
8	173	-------> if not command -sq hg
        return 1
    ...
138	138	--------> not command -sq hg
27	27	--------> return 1
78	12182	-----> _is_git_repo
216	1969	------> type -q git
27	27	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
63	63	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
28	28	-------> set -l multi no
28	28	-------> set -l selection all
31	31	-------> set -l short no
9	86	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	--------> set -q _flag_quiet
52	52	--------> set mode quiet
70	70	-------> set -q _flag_all
26	26	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
37	1217	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
15	650	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	264	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
260	260	----------> functions -q -- $i
4	341	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
288	337	----------> contains -- $i (builtin -n)
49	49	-----------> builtin -n
31	31	--------> set -l paths
10	297	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
144	258	---------> set paths (command -s -- $i)
114	114	----------> command -s -- $i
21	144	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	57	---------> if test $multi != yes
                continue
            ...
27	27	----------> test $multi != yes
23	23	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
28	28	-------> return $res
10135	10135	------> git rev-parse --git-dir >/dev/null 2>&1
81	81	-----> echo 'git'
26	26	-----> return 0
149	12488	--> set -l repo_branch $red(_repo_branch_name $repo_type)
55	12339	---> _repo_branch_name $repo_type
54	12284	----> _$argv[1]_branch_name
232	11918	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11686	11686	------> git symbolic-ref --quiet HEAD 2>/dev/null
14	312	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
50	50	------> set -q branch[1]
162	248	------> echo (string replace -r '^refs/heads/' '' $branch)
86	86	-------> string replace -r '^refs/heads/' '' $branch
45	45	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11218	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
104	11213	---> [ (_is_repo_dirty $repo_type) ]
41	11109	----> _is_repo_dirty $repo_type
36	11068	-----> _is_$argv[1]_dirty
155	11032	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10877	10877	-------> git status -s --ignore-submodules=dirty 2>/dev/null
64	64	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
74	2178	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
1942	1942	-> date "+%H:%M:%S"
71	71	-> set_color normal
48	489	> fish_title
10	441	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
213	401	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
70	156	---> __fish_pwd
86	86	----> pwd
74	140	> __fish_disable_bracketed_paste ls
66	66	-> printf "\e[?2004l"
45	409	> fish_title ls
9	364	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
197	322	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
49	90	---> __fish_pwd
41	41	----> pwd
341	6892	> ls
323	3420	-> isatty stdout
40	40	--> set -l options 'h/help'
40	40	--> argparse -n isatty $options -- $argv
7	32	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
25	25	---> set -q _flag_help
4	29	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
25	25	---> set -q argv[2]
27	27	--> set -l fd
16	44	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
28	28	---> set fd 1
2885	2885	--> command [ -t "$fd" ]
59	59	-> set -a opt -F
3072	3072	-> command ls $opt $argv
73	127	> __fish_enable_bracketed_paste
54	54	-> printf "\e[?2004h"
102	243	> fish_mode_prompt
59	141	-> fish_default_mode_prompt
9	82	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
31	31	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
131	38544	> fish_prompt
50	50	-> set -l __last_command_exit_status $status
4	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
26	26	--> not set -q -g __fish_robbyrussell_functions_defined
98	152	-> set -l cyan (set_color -o cyan)
54	54	--> set_color -o cyan
88	131	-> set -l yellow (set_color -o yellow)
43	43	--> set_color -o yellow
83	124	-> set -l red (set_color -o red)
41	41	--> set_color -o red
85	129	-> set -l green (set_color -o green)
44	44	--> set_color -o green
84	124	-> set -l blue (set_color -o blue)
40	40	--> set_color -o blue
150	202	-> set -l normal (set_color normal)
52	52	--> set_color normal
37	37	-> set -l arrow_color "$green"
4	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
29	29	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	34	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
31	31	--> test "$USER" = 'root'
137	2177	-> set -l cwd $cyan(basename (prompt_pwd))
1437	2040	--> basename (prompt_pwd)
71	603	---> prompt_pwd
37	37	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	28	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
43	43	----> set -q fish_prompt_pwd_dir_length
68	68	----> set -l fish_prompt_pwd_dir_length 1
49	49	----> set realhome ~
95	172	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
77	77	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	96	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
18	35092	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
124	13117	--> set -l repo_type (_repo_type)
31	12993	---> _repo_type
17	12962	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
24	259	-----> _is_hg_repo
68	235	------> fish_print_hg_root >/dev/null
9	167	-------> if not command -sq hg
        return 1
    ...
131	131	--------> not command -sq hg
27	27	--------> return 1
47	12591	-----> _is_git_repo
93	1743	------> type -q git
26	26	-------> set -q argv[1]
81	81	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
150	150	-------> argparse -n type -x t,p,P $options -- $argv
3	44	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
41	41	--------> set -q _flag_help
26	26	-------> set -l res 1
24	24	-------> set -l mode normal
25	25	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
7	55	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
29	29	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
44	1055	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
26	26	--------> set -l found 0
17	397	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
29	29	---------> test $selection != files
4	56	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
52	52	----------> functions -q -- $i
3	295	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
240	292	----------> contains -- $i (builtin -n)
52	52	-----------> builtin -n
28	28	--------> set -l paths
9	361	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	---------> test $multi != yes
153	324	---------> set paths (command -s -- $i)
171	171	----------> command -s -- $i
32	160	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
31	31	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	60	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
23	23	----------> continue
5	39	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
34	34	---------> test $found = 0
39	39	-------> return $res
10801	10801	------> git rev-parse --git-dir >/dev/null 2>&1
69	69	-----> echo 'git'
26	26	-----> return 0
121	11068	--> set -l repo_branch $red(_repo_branch_name $repo_type)
44	10947	---> _repo_branch_name $repo_type
43	10903	----> _$argv[1]_branch_name
164	10591	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10427	10427	------> git symbolic-ref --quiet HEAD 2>/dev/null
11	269	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
154	226	------> echo (string replace -r '^refs/heads/' '' $branch)
72	72	-------> string replace -r '^refs/heads/' '' $branch
57	57	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	10832	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
123	10827	---> [ (_is_repo_dirty $repo_type) ]
87	10704	----> _is_repo_dirty $repo_type
44	10617	-----> _is_$argv[1]_dirty
180	10573	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10393	10393	-------> git status -s --ignore-submodules=dirty 2>/dev/null
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
70	1982	> fish_right_prompt
93	93	-> set_color $fish_color_autosuggestion 2> /dev/null
1750	1750	-> date "+%H:%M:%S"
69	69	-> set_color normal
43	456	> fish_title
9	413	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
183	373	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
54	157	---> __fish_pwd
103	103	----> pwd
62	330	> __fish_winch_handler SIGWINCH
268	268	-> commandline -f repaint >/dev/null 2>/dev/null
43	550	> fish_mode_prompt
244	507	-> fish_default_mode_prompt
164	263	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-75	64	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
48	139	----> __fish_winch_handler SIGWINCH
91	91	-----> commandline -f repaint >/dev/null 2>/dev/null
35	35	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
111	47564	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	29	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
25	25	--> not set -q -g __fish_robbyrussell_functions_defined
181	491	-> set -l cyan (set_color -o cyan)
310	310	--> set_color -o cyan
94	144	-> set -l yellow (set_color -o yellow)
50	50	--> set_color -o yellow
88	133	-> set -l red (set_color -o red)
45	45	--> set_color -o red
90	135	-> set -l green (set_color -o green)
45	45	--> set_color -o green
110	154	-> set -l blue (set_color -o blue)
44	44	--> set_color -o blue
102	152	-> set -l normal (set_color normal)
50	50	--> set_color normal
35	35	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	33	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
30	30	--> test "$USER" = 'root'
202	2931	-> set -l cwd $cyan(basename (prompt_pwd))
1963	2729	--> basename (prompt_pwd)
193	766	---> prompt_pwd
36	36	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
103	283	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
180	180	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	98	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
17	43050	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
191	16719	--> set -l repo_type (_repo_type)
40	16528	---> _repo_type
36	16488	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
28	452	-----> _is_hg_repo
251	424	------> fish_print_hg_root >/dev/null
10	173	-------> if not command -sq hg
        return 1
    ...
134	134	--------> not command -sq hg
29	29	--------> return 1
60	15776	-----> _is_git_repo
287	2737	------> type -q git
37	37	-------> set -q argv[1]
87	87	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
77	77	-------> argparse -n type -x t,p,P $options -- $argv
5	32	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
27	27	-------> set -l selection all
27	27	-------> set -l short no
18	87	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	--------> set -q _flag_quiet
44	44	--------> set mode quiet
29	29	-------> set -q _flag_all
44	44	-------> set -q _flag_short
44	44	-------> set -q _flag_no_functions
41	1837	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
36	36	--------> set -l found 0
23	1076	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
33	33	---------> test $selection != files
12	466	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
454	454	----------> functions -q -- $i
7	554	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
469	547	----------> contains -- $i (builtin -n)
78	78	-----------> builtin -n
35	35	--------> set -l paths
19	396	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
38	38	---------> test $multi != yes
160	339	---------> set paths (command -s -- $i)
179	179	----------> command -s -- $i
31	222	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
48	48	---------> set res 0
36	36	---------> set found 1
12	12	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	95	---------> if test $multi != yes
                continue
            ...
64	64	----------> test $multi != yes
23	23	----------> continue
5	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
42	42	-------> return $res
12979	12979	------> git rev-parse --git-dir >/dev/null 2>&1
199	199	-----> echo 'git'
25	25	-----> return 0
204	12605	--> set -l repo_branch $red(_repo_branch_name $repo_type)
71	12401	---> _repo_branch_name $repo_type
51	12330	----> _$argv[1]_branch_name
196	11972	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11776	11776	------> git symbolic-ref --quiet HEAD 2>/dev/null
11	307	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
30	30	------> set -q branch[1]
185	266	------> echo (string replace -r '^refs/heads/' '' $branch)
81	81	-------> string replace -r '^refs/heads/' '' $branch
47	47	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	13662	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
174	13657	---> [ (_is_repo_dirty $repo_type) ]
54	13483	----> _is_repo_dirty $repo_type
55	13429	-----> _is_$argv[1]_dirty
241	13374	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
13133	13133	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
166	2885	> fish_right_prompt
86	86	-> set_color $fish_color_autosuggestion 2> /dev/null
2551	2551	-> date "+%H:%M:%S"
82	82	-> set_color normal
65	875	> fish_title
10	810	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
261	768	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
231	472	---> __fish_pwd
241	241	----> pwd
53	168	> __fish_winch_handler SIGWINCH
115	115	-> commandline -f repaint >/dev/null 2>/dev/null
40	311	> fish_mode_prompt
47	271	-> fish_default_mode_prompt
141	224	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-70	46	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
29	116	----> __fish_winch_handler SIGWINCH
87	87	-----> commandline -f repaint >/dev/null 2>/dev/null
37	37	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
106	46864	> fish_prompt
41	41	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
105	159	-> set -l cyan (set_color -o cyan)
54	54	--> set_color -o cyan
93	139	-> set -l yellow (set_color -o yellow)
46	46	--> set_color -o yellow
88	133	-> set -l red (set_color -o red)
45	45	--> set_color -o red
90	134	-> set -l green (set_color -o green)
44	44	--> set_color -o green
121	169	-> set -l blue (set_color -o blue)
48	48	--> set_color -o blue
147	193	-> set -l normal (set_color normal)
46	46	--> set_color normal
60	60	-> set -l arrow_color "$green"
6	65	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
59	59	--> test $__last_command_exit_status != 0
50	50	-> set -l arrow "$arrow_color➜ "
4	39	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
35	35	--> test "$USER" = 'root'
140	2218	-> set -l cwd $cyan(basename (prompt_pwd))
1500	2078	--> basename (prompt_pwd)
71	578	---> prompt_pwd
35	35	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	31	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
27	27	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
30	30	----> set -l fish_prompt_pwd_dir_length 1
37	37	----> set realhome ~
133	211	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
78	78	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	96	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
56	56	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
22	43259	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
142	14071	--> set -l repo_type (_repo_type)
36	13929	---> _repo_type
24	13893	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
27	280	-----> _is_hg_repo
76	253	------> fish_print_hg_root >/dev/null
10	177	-------> if not command -sq hg
        return 1
    ...
138	138	--------> not command -sq hg
29	29	--------> return 1
83	13406	-----> _is_git_repo
100	1596	------> type -q git
26	26	-------> set -q argv[1]
50	50	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
70	70	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
27	27	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
8	58	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
26	26	--------> set mode quiet
26	26	-------> set -q _flag_all
24	24	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
46	1002	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
15	338	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
31	31	---------> test $selection != files
3	53	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
50	50	----------> functions -q -- $i
4	239	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
185	235	----------> contains -- $i (builtin -n)
50	50	-----------> builtin -n
29	29	--------> set -l paths
9	328	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
116	290	---------> set paths (command -s -- $i)
174	174	----------> command -s -- $i
25	161	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
31	31	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
17	68	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
22	22	----------> continue
8	73	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
65	65	---------> test $found = 0
56	56	-------> return $res
11727	11727	------> git rev-parse --git-dir >/dev/null 2>&1
124	124	-----> echo 'git'
59	59	-----> return 0
199	14714	--> set -l repo_branch $red(_repo_branch_name $repo_type)
66	14515	---> _repo_branch_name $repo_type
40	14449	----> _$argv[1]_branch_name
196	14075	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
13879	13879	------> git symbolic-ref --quiet HEAD 2>/dev/null
14	334	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
48	48	------> set -q branch[1]
181	272	------> echo (string replace -r '^refs/heads/' '' $branch)
91	91	-------> string replace -r '^refs/heads/' '' $branch
59	59	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
6	14393	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
127	14387	---> [ (_is_repo_dirty $repo_type) ]
71	14260	----> _is_repo_dirty $repo_type
68	14189	-----> _is_$argv[1]_dirty
196	14121	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
13925	13925	-------> git status -s --ignore-submodules=dirty 2>/dev/null
68	68	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
75	2302	> fish_right_prompt
102	102	-> set_color $fish_color_autosuggestion 2> /dev/null
2045	2045	-> date "+%H:%M:%S"
80	80	-> set_color normal
67	549	> fish_title
14	482	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
316	435	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
47	86	---> __fish_pwd
39	39	----> pwd
81	206	> __fish_winch_handler SIGWINCH
125	125	-> commandline -f repaint >/dev/null 2>/dev/null
44	310	> fish_mode_prompt
40	266	-> fish_default_mode_prompt
147	226	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-75	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
29	118	----> __fish_winch_handler SIGWINCH
89	89	-----> commandline -f repaint >/dev/null 2>/dev/null
36	36	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
96	41299	> fish_prompt
38	38	-> set -l __last_command_exit_status $status
4	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
26	26	--> not set -q -g __fish_robbyrussell_functions_defined
99	151	-> set -l cyan (set_color -o cyan)
52	52	--> set_color -o cyan
91	138	-> set -l yellow (set_color -o yellow)
47	47	--> set_color -o yellow
88	132	-> set -l red (set_color -o red)
44	44	--> set_color -o red
88	132	-> set -l green (set_color -o green)
44	44	--> set_color -o green
86	133	-> set -l blue (set_color -o blue)
47	47	--> set_color -o blue
87	129	-> set -l normal (set_color normal)
42	42	--> set_color normal
33	33	-> set -l arrow_color "$green"
3	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
35	35	-> set -l arrow "$arrow_color➜ "
4	37	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
142	2136	-> set -l cwd $cyan(basename (prompt_pwd))
1487	1994	--> basename (prompt_pwd)
60	507	---> prompt_pwd
32	32	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
96	165	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
69	69	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	97	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
25	37935	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
199	13325	--> set -l repo_type (_repo_type)
30	13126	---> _repo_type
25	13096	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
25	267	-----> _is_hg_repo
69	242	------> fish_print_hg_root >/dev/null
8	173	-------> if not command -sq hg
        return 1
    ...
138	138	--------> not command -sq hg
27	27	--------> return 1
70	12687	-----> _is_git_repo
106	1648	------> type -q git
62	62	-------> set -q argv[1]
67	67	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
66	66	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
27	27	-------> set -l selection all
25	25	-------> set -l short no
8	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
26	26	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
31	1030	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
18	393	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	51	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
47	47	----------> functions -q -- $i
6	294	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
237	288	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
33	33	--------> set -l paths
10	296	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
120	256	---------> set paths (command -s -- $i)
136	136	----------> command -s -- $i
23	218	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
32	32	---------> set found 1
25	25	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	109	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
72	72	----------> continue
4	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
28	28	-------> return $res
10969	10969	------> git rev-parse --git-dir >/dev/null 2>&1
90	90	-----> echo 'git'
27	27	-----> return 0
133	12245	--> set -l repo_branch $red(_repo_branch_name $repo_type)
75	12112	---> _repo_branch_name $repo_type
77	12037	----> _$argv[1]_branch_name
185	11686	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11501	11501	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	274	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
157	230	------> echo (string replace -r '^refs/heads/' '' $branch)
73	73	-------> string replace -r '^refs/heads/' '' $branch
132	132	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
7	12208	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
143	12201	---> [ (_is_repo_dirty $repo_type) ]
68	12058	----> _is_repo_dirty $repo_type
41	11990	-----> _is_$argv[1]_dirty
161	11949	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11788	11788	-------> git status -s --ignore-submodules=dirty 2>/dev/null
111	111	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
73	2216	> fish_right_prompt
90	90	-> set_color $fish_color_autosuggestion 2> /dev/null
1978	1978	-> date "+%H:%M:%S"
75	75	-> set_color normal
45	439	> fish_title
11	394	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
68	68	--> not set -q INSIDE_EMACS
190	315	--> echo (status current-command) (__fish_pwd)
38	38	---> status current-command
49	87	---> __fish_pwd
38	38	----> pwd
98	216	> __fish_winch_handler SIGWINCH
118	118	-> commandline -f repaint >/dev/null 2>/dev/null
38	289	> fish_mode_prompt
38	251	-> fish_default_mode_prompt
137	213	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-71	41	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
26	112	----> __fish_winch_handler SIGWINCH
86	86	-----> commandline -f repaint >/dev/null 2>/dev/null
35	35	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
179	38863	> fish_prompt
69	69	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
122	189	-> set -l cyan (set_color -o cyan)
67	67	--> set_color -o cyan
130	183	-> set -l yellow (set_color -o yellow)
53	53	--> set_color -o yellow
127	173	-> set -l red (set_color -o red)
46	46	--> set_color -o red
116	171	-> set -l green (set_color -o green)
55	55	--> set_color -o green
100	148	-> set -l blue (set_color -o blue)
48	48	--> set_color -o blue
133	175	-> set -l normal (set_color normal)
42	42	--> set_color normal
38	38	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
34	34	-> set -l arrow "$arrow_color➜ "
3	33	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
30	30	--> test "$USER" = 'root'
165	2299	-> set -l cwd $cyan(basename (prompt_pwd))
1586	2134	--> basename (prompt_pwd)
65	548	---> prompt_pwd
45	45	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
115	185	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
70	70	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	102	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
59	59	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
16	35042	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
124	12094	--> set -l repo_type (_repo_type)
38	11970	---> _repo_type
14	11932	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
34	293	-----> _is_hg_repo
76	259	------> fish_print_hg_root >/dev/null
11	183	-------> if not command -sq hg
        return 1
    ...
144	144	--------> not command -sq hg
28	28	--------> return 1
50	11527	-----> _is_git_repo
99	1578	------> type -q git
30	30	-------> set -q argv[1]
52	52	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
67	67	-------> argparse -n type -x t,p,P $options -- $argv
6	64	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
58	58	--------> set -q _flag_help
33	33	-------> set -l res 1
29	29	-------> set -l mode normal
66	66	-------> set -l multi no
34	34	-------> set -l selection all
27	27	-------> set -l short no
10	60	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
26	26	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
34	919	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
18	366	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
31	31	---------> test $selection != files
4	50	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
46	46	----------> functions -q -- $i
5	267	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
210	262	----------> contains -- $i (builtin -n)
52	52	-----------> builtin -n
30	30	--------> set -l paths
10	275	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	---------> test $multi != yes
107	237	---------> set paths (command -s -- $i)
130	130	----------> command -s -- $i
24	150	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
26	26	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	59	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
23	23	----------> continue
4	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
28	28	-------> return $res
9899	9899	------> git rev-parse --git-dir >/dev/null 2>&1
71	71	-----> echo 'git'
27	27	-----> return 0
104	11133	--> set -l repo_branch $red(_repo_branch_name $repo_type)
40	11029	---> _repo_branch_name $repo_type
37	10989	----> _$argv[1]_branch_name
154	10728	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10574	10574	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	224	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
118	183	------> echo (string replace -r '^refs/heads/' '' $branch)
65	65	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11756	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
98	11751	---> [ (_is_repo_dirty $repo_type) ]
39	11653	----> _is_repo_dirty $repo_type
35	11614	-----> _is_$argv[1]_dirty
139	11579	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11440	11440	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
66	2121	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
1892	1892	-> date "+%H:%M:%S"
75	75	-> set_color normal
44	374	> fish_title
9	330	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
170	290	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
49	87	---> __fish_pwd
38	38	----> pwd
54	287	> __fish_disable_bracketed_paste clear
233	233	-> printf "\e[?2004l"
55	550	> fish_title clear
12	495	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
37	37	--> not set -q INSIDE_EMACS
268	446	--> echo (status current-command) (__fish_pwd)
67	67	---> status current-command
62	111	---> __fish_pwd
49	49	----> pwd
3355	3355	> clear
104	184	> __fish_enable_bracketed_paste
80	80	-> printf "\e[?2004h"
111	269	> fish_mode_prompt
62	158	-> fish_default_mode_prompt
9	96	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
49	49	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
128	44476	> fish_prompt
41	41	-> set -l __last_command_exit_status $status
4	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
183	287	-> set -l cyan (set_color -o cyan)
104	104	--> set_color -o cyan
162	226	-> set -l yellow (set_color -o yellow)
64	64	--> set_color -o yellow
169	235	-> set -l red (set_color -o red)
66	66	--> set_color -o red
224	327	-> set -l green (set_color -o green)
103	103	--> set_color -o green
205	301	-> set -l blue (set_color -o blue)
96	96	--> set_color -o blue
139	209	-> set -l normal (set_color normal)
70	70	--> set_color normal
49	49	-> set -l arrow_color "$green"
7	58	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
51	51	--> test $__last_command_exit_status != 0
60	60	-> set -l arrow "$arrow_color➜ "
7	64	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
57	57	--> test "$USER" = 'root'
260	2886	-> set -l cwd $cyan(basename (prompt_pwd))
1646	2626	--> basename (prompt_pwd)
106	980	---> prompt_pwd
50	50	----> set -l options 'h/help'
49	49	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	41	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
35	35	-----> set -q _flag_help
77	77	----> set -q fish_prompt_pwd_dir_length
91	91	----> set -l fish_prompt_pwd_dir_length 1
44	44	----> set realhome ~
190	295	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
105	105	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
20	227	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
58	58	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
149	149	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
20	39507	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
203	15803	--> set -l repo_type (_repo_type)
50	15600	---> _repo_type
23	15550	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
46	574	-----> _is_hg_repo
127	528	------> fish_print_hg_root >/dev/null
22	401	-------> if not command -sq hg
        return 1
    ...
306	306	--------> not command -sq hg
73	73	--------> return 1
65	14847	-----> _is_git_repo
108	2182	------> type -q git
35	35	-------> set -q argv[1]
62	62	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
88	88	-------> argparse -n type -x t,p,P $options -- $argv
8	74	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
66	66	--------> set -q _flag_help
50	50	-------> set -l res 1
28	28	-------> set -l mode normal
32	32	-------> set -l multi no
27	27	-------> set -l selection all
31	31	-------> set -l short no
10	69	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
28	28	--------> set -q _flag_quiet
31	31	--------> set mode quiet
30	30	-------> set -q _flag_all
24	24	-------> set -q _flag_short
75	75	-------> set -q _flag_no_functions
61	1422	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
97	97	--------> set -l found 0
27	466	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
34	34	---------> test $selection != files
4	62	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
58	58	----------> functions -q -- $i
9	343	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
278	334	----------> contains -- $i (builtin -n)
56	56	-----------> builtin -n
57	57	--------> set -l paths
13	549	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
111	111	---------> test $multi != yes
235	425	---------> set paths (command -s -- $i)
190	190	----------> command -s -- $i
29	161	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
33	33	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	59	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
22	22	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
12600	12600	------> git rev-parse --git-dir >/dev/null 2>&1
80	80	-----> echo 'git'
26	26	-----> return 0
209	10641	--> set -l repo_branch $red(_repo_branch_name $repo_type)
77	10432	---> _repo_branch_name $repo_type
73	10355	----> _$argv[1]_branch_name
145	9987	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9842	9842	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	295	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
180	252	------> echo (string replace -r '^refs/heads/' '' $branch)
72	72	-------> string replace -r '^refs/heads/' '' $branch
46	46	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
6	12997	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
115	12991	---> [ (_is_repo_dirty $repo_type) ]
39	12876	----> _is_repo_dirty $repo_type
37	12837	-----> _is_$argv[1]_dirty
163	12800	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
12637	12637	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
74	2116	> fish_right_prompt
108	108	-> set_color $fish_color_autosuggestion 2> /dev/null
1849	1849	-> date "+%H:%M:%S"
85	85	-> set_color normal
54	582	> fish_title
12	528	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
220	484	--> echo (status current-command) (__fish_pwd)
79	79	---> status current-command
81	185	---> __fish_pwd
104	104	----> pwd
67	186	> __fish_disable_bracketed_paste clear
119	119	-> printf "\e[?2004l"
69	802	> fish_title clear
13	733	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
39	39	--> not set -q INSIDE_EMACS
510	681	--> echo (status current-command) (__fish_pwd)
57	57	---> status current-command
65	114	---> __fish_pwd
49	49	----> pwd
3275	3275	> clear
44	96	> __fish_enable_bracketed_paste
52	52	-> printf "\e[?2004h"
43	292	> fish_mode_prompt
166	249	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
142	42672	> fish_prompt
53	53	-> set -l __last_command_exit_status $status
5	34	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
112	289	-> set -l cyan (set_color -o cyan)
177	177	--> set_color -o cyan
97	144	-> set -l yellow (set_color -o yellow)
47	47	--> set_color -o yellow
101	158	-> set -l red (set_color -o red)
57	57	--> set_color -o red
101	146	-> set -l green (set_color -o green)
45	45	--> set_color -o green
90	134	-> set -l blue (set_color -o blue)
44	44	--> set_color -o blue
93	138	-> set -l normal (set_color normal)
45	45	--> set_color normal
33	33	-> set -l arrow_color "$green"
3	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
4	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
31	31	--> test "$USER" = 'root'
175	2568	-> set -l cwd $cyan(basename (prompt_pwd))
1638	2393	--> basename (prompt_pwd)
180	755	---> prompt_pwd
37	37	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
100	285	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
185	185	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	100	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
58	58	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
26	38647	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
141	16541	--> set -l repo_type (_repo_type)
45	16400	---> _repo_type
17	16355	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
40	440	-----> _is_hg_repo
230	400	------> fish_print_hg_root >/dev/null
10	170	-------> if not command -sq hg
        return 1
    ...
133	133	--------> not command -sq hg
27	27	--------> return 1
48	15797	-----> _is_git_repo
230	2366	------> type -q git
30	30	-------> set -q argv[1]
51	51	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
92	92	-------> argparse -n type -x t,p,P $options -- $argv
5	45	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
40	40	--------> set -q _flag_help
43	43	-------> set -l res 1
41	41	-------> set -l mode normal
30	30	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
10	62	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
28	28	--------> set mode quiet
38	38	-------> set -q _flag_all
36	36	-------> set -q _flag_short
36	36	-------> set -q _flag_no_functions
58	1541	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
42	42	--------> set -l found 0
22	762	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
44	44	---------> test $selection != files
6	331	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
325	325	----------> functions -q -- $i
5	365	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
303	360	----------> contains -- $i (builtin -n)
57	57	-----------> builtin -n
32	32	--------> set -l paths
13	305	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
143	262	---------> set paths (command -s -- $i)
119	119	----------> command -s -- $i
67	268	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
54	54	---------> set res 0
38	38	---------> set found 1
15	15	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
11	94	---------> if test $multi != yes
                continue
            ...
47	47	----------> test $multi != yes
36	36	----------> continue
9	74	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
65	65	---------> test $found = 0
40	40	-------> return $res
13383	13383	------> git rev-parse --git-dir >/dev/null 2>&1
75	75	-----> echo 'git'
26	26	-----> return 0
134	10454	--> set -l repo_branch $red(_repo_branch_name $repo_type)
58	10320	---> _repo_branch_name $repo_type
115	10262	----> _$argv[1]_branch_name
159	9918	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9759	9759	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	229	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
121	188	------> echo (string replace -r '^refs/heads/' '' $branch)
67	67	-------> string replace -r '^refs/heads/' '' $branch
49	49	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
17	11577	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
121	11560	---> [ (_is_repo_dirty $repo_type) ]
45	11439	----> _is_repo_dirty $repo_type
58	11394	-----> _is_$argv[1]_dirty
190	11336	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11146	11146	-------> git status -s --ignore-submodules=dirty 2>/dev/null
85	85	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
281	2725	> fish_right_prompt
123	123	-> set_color $fish_color_autosuggestion 2> /dev/null
2252	2252	-> date "+%H:%M:%S"
69	69	-> set_color normal
57	765	> fish_title
12	708	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
215	664	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
183	417	---> __fish_pwd
234	234	----> pwd
256	333	> __fish_complete_cd
45	45	-> set -q CDPATH[1]
32	32	-> return 0
264	7618	> __fish_cancel_commandline
205	205	-> commandline -f cancel
100	140	-> set -l cmd (commandline)
40	40	--> commandline
40	6950	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
34	34	--> test -n "$cmd"
71	71	--> commandline -C 1000000
13	454	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
28	28	---> set -q fish_color_cancel
283	413	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
53	53	----> set_color $fish_color_cancel
77	77	----> set_color normal
18	3019	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
117	117	---> command -sq tput
208	2884	---> echo -n (tput el; or tput ce)
2676	2676	----> tput el
175	2957	--> for i in (seq (commandline -L))
            echo ""
        ...
2576	2661	---> seq (commandline -L)
85	85	----> commandline -L
121	121	---> echo ""
102	102	--> commandline ""
273	273	--> emit fish_cancel
59	59	-> commandline -f repaint
65	238	> fish_mode_prompt
58	173	-> fish_default_mode_prompt
12	115	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
52	52	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
51	51	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
128	44388	> fish_prompt
49	49	-> set -l __last_command_exit_status $status
6	44	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
38	38	--> not set -q -g __fish_robbyrussell_functions_defined
140	217	-> set -l cyan (set_color -o cyan)
77	77	--> set_color -o cyan
124	189	-> set -l yellow (set_color -o yellow)
65	65	--> set_color -o yellow
247	322	-> set -l red (set_color -o red)
75	75	--> set_color -o red
138	204	-> set -l green (set_color -o green)
66	66	--> set_color -o green
140	194	-> set -l blue (set_color -o blue)
54	54	--> set_color -o blue
221	283	-> set -l normal (set_color normal)
62	62	--> set_color normal
51	51	-> set -l arrow_color "$green"
4	37	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
33	33	--> test $__last_command_exit_status != 0
35	35	-> set -l arrow "$arrow_color➜ "
3	38	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
35	35	--> test "$USER" = 'root'
201	2454	-> set -l cwd $cyan(basename (prompt_pwd))
1596	2253	--> basename (prompt_pwd)
79	657	---> prompt_pwd
38	38	----> set -l options 'h/help'
42	42	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	31	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
27	27	-----> set -q _flag_help
28	28	----> set -q fish_prompt_pwd_dir_length
34	34	----> set -l fish_prompt_pwd_dir_length 1
52	52	----> set realhome ~
156	249	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
93	93	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	104	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
61	61	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
25	40078	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
211	14848	--> set -l repo_type (_repo_type)
55	14637	---> _repo_type
51	14582	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
44	391	-----> _is_hg_repo
135	347	------> fish_print_hg_root >/dev/null
10	212	-------> if not command -sq hg
        return 1
    ...
158	158	--------> not command -sq hg
44	44	--------> return 1
74	13902	-----> _is_git_repo
106	1556	------> type -q git
28	28	-------> set -q argv[1]
49	49	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
67	67	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
27	27	-------> set -l res 1
27	27	-------> set -l mode normal
31	31	-------> set -l multi no
27	27	-------> set -l selection all
27	27	-------> set -l short no
7	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
26	26	--------> set mode quiet
25	25	-------> set -q _flag_all
24	24	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
36	979	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
18	351	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
4	51	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
47	47	----------> functions -q -- $i
4	250	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
196	246	----------> contains -- $i (builtin -n)
50	50	-----------> builtin -n
30	30	--------> set -l paths
12	328	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
163	287	---------> set paths (command -s -- $i)
124	124	----------> command -s -- $i
34	173	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
38	38	---------> set res 0
29	29	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	61	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
23	23	----------> continue
4	33	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
29	29	---------> test $found = 0
29	29	-------> return $res
12272	12272	------> git rev-parse --git-dir >/dev/null 2>&1
158	158	-----> echo 'git'
80	80	-----> return 0
160	12961	--> set -l repo_branch $red(_repo_branch_name $repo_type)
64	12801	---> _repo_branch_name $repo_type
64	12737	----> _$argv[1]_branch_name
207	12318	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
12111	12111	------> git symbolic-ref --quiet HEAD 2>/dev/null
14	355	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
34	34	------> set -q branch[1]
187	307	------> echo (string replace -r '^refs/heads/' '' $branch)
120	120	-------> string replace -r '^refs/heads/' '' $branch
63	63	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
7	12181	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
123	12174	---> [ (_is_repo_dirty $repo_type) ]
40	12051	----> _is_repo_dirty $repo_type
33	12011	-----> _is_$argv[1]_dirty
158	11978	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11820	11820	-------> git status -s --ignore-submodules=dirty 2>/dev/null
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
65	1959	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
1740	1740	-> date "+%H:%M:%S"
63	63	-> set_color normal
42	501	> fish_title
11	459	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
50	50	--> not set -q INSIDE_EMACS
250	398	--> echo (status current-command) (__fish_pwd)
58	58	---> status current-command
51	90	---> __fish_pwd
39	39	----> pwd
51	255	> __fish_disable_bracketed_paste lcear
204	204	-> printf "\e[?2004l"
-336	449	> fish_title lcear
11	404	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
204	360	--> echo (status current-command) (__fish_pwd)
36	36	---> status current-command
74	120	---> __fish_pwd
46	46	----> pwd
56	381	-> __fish_command_not_found_handler lcear
144	325	--> __fish_default_command_not_found_handler $argv[1]
127	181	---> printf "fish: Unknown command: %s\n" (string escape -- $argv[1]) >&2
54	54	----> string escape -- $argv[1]
33	81	> __fish_enable_bracketed_paste
48	48	-> printf "\e[?2004h"
39	163	> fish_mode_prompt
38	124	-> fish_default_mode_prompt
8	86	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
36	36	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
118	41518	> fish_prompt
47	47	-> set -l __last_command_exit_status $status
4	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
108	162	-> set -l cyan (set_color -o cyan)
54	54	--> set_color -o cyan
101	151	-> set -l yellow (set_color -o yellow)
50	50	--> set_color -o yellow
115	163	-> set -l red (set_color -o red)
48	48	--> set_color -o red
124	235	-> set -l green (set_color -o green)
111	111	--> set_color -o green
106	162	-> set -l blue (set_color -o blue)
56	56	--> set_color -o blue
100	149	-> set -l normal (set_color normal)
49	49	--> set_color normal
38	38	-> set -l arrow_color "$green"
8	76	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
33	33	--> test $__last_command_exit_status != 0
35	35	--> set arrow_color "$red"
37	37	-> set -l arrow "$arrow_color➜ "
4	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
126	2164	-> set -l cwd $cyan(basename (prompt_pwd))
1457	2038	--> basename (prompt_pwd)
66	581	---> prompt_pwd
36	36	----> set -l options 'h/help'
56	56	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
106	208	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
102	102	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	102	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
60	60	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
19	37877	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
171	13530	--> set -l repo_type (_repo_type)
50	13359	---> _repo_type
16	13309	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
39	337	-----> _is_hg_repo
118	298	------> fish_print_hg_root >/dev/null
11	180	-------> if not command -sq hg
        return 1
    ...
141	141	--------> not command -sq hg
28	28	--------> return 1
49	12812	-----> _is_git_repo
94	1475	------> type -q git
27	27	-------> set -q argv[1]
52	52	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
64	64	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
8	59	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	--------> set -q _flag_quiet
26	26	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
30	922	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
14	378	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
3	55	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
52	52	----------> functions -q -- $i
6	279	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
222	273	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
37	37	--------> set -l paths
10	275	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
32	32	---------> test $multi != yes
101	233	---------> set paths (command -s -- $i)
132	132	----------> command -s -- $i
21	144	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	58	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
22	22	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
11288	11288	------> git rev-parse --git-dir >/dev/null 2>&1
78	78	-----> echo 'git'
66	66	-----> return 0
256	12745	--> set -l repo_branch $red(_repo_branch_name $repo_type)
57	12489	---> _repo_branch_name $repo_type
37	12432	----> _$argv[1]_branch_name
247	12068	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11821	11821	------> git symbolic-ref --quiet HEAD 2>/dev/null
26	327	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
156	270	------> echo (string replace -r '^refs/heads/' '' $branch)
114	114	-------> string replace -r '^refs/heads/' '' $branch
64	64	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11519	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
112	11514	---> [ (_is_repo_dirty $repo_type) ]
59	11402	----> _is_repo_dirty $repo_type
34	11343	-----> _is_$argv[1]_dirty
166	11309	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11143	11143	-------> git status -s --ignore-submodules=dirty 2>/dev/null
68	68	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
62	1838	> fish_right_prompt
86	86	-> set_color $fish_color_autosuggestion 2> /dev/null
1629	1629	-> date "+%H:%M:%S"
61	61	-> set_color normal
38	353	> fish_title
10	315	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
164	275	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
43	78	---> __fish_pwd
35	35	----> pwd
66	131	> __fish_disable_bracketed_paste clear
65	65	-> printf "\e[?2004l"
66	571	> fish_title clear
18	505	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
46	46	--> not set -q INSIDE_EMACS
279	441	--> echo (status current-command) (__fish_pwd)
55	55	---> status current-command
60	107	---> __fish_pwd
47	47	----> pwd
3421	3421	> clear
42	96	> __fish_enable_bracketed_paste
54	54	-> printf "\e[?2004h"
38	164	> fish_mode_prompt
43	126	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
43	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
106	42611	> fish_prompt
42	42	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
103	166	-> set -l cyan (set_color -o cyan)
63	63	--> set_color -o cyan
166	213	-> set -l yellow (set_color -o yellow)
47	47	--> set_color -o yellow
99	149	-> set -l red (set_color -o red)
50	50	--> set_color -o red
94	140	-> set -l green (set_color -o green)
46	46	--> set_color -o green
88	132	-> set -l blue (set_color -o blue)
44	44	--> set_color -o blue
87	129	-> set -l normal (set_color normal)
42	42	--> set_color normal
33	33	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
4	37	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
117	2113	-> set -l cwd $cyan(basename (prompt_pwd))
1412	1996	--> basename (prompt_pwd)
74	584	---> prompt_pwd
35	35	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
120	196	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
76	76	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	128	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
38	38	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
79	79	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
18	39187	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
165	14383	--> set -l repo_type (_repo_type)
33	14218	---> _repo_type
15	14185	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
42	324	-----> _is_hg_repo
73	282	------> fish_print_hg_root >/dev/null
9	209	-------> if not command -sq hg
        return 1
    ...
157	157	--------> not command -sq hg
43	43	--------> return 1
46	13750	-----> _is_git_repo
127	1765	------> type -q git
25	25	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
66	66	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
25	25	-------> set -l res 1
44	44	-------> set -l mode normal
26	26	-------> set -l multi no
40	40	-------> set -l selection all
25	25	-------> set -l short no
8	55	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
25	25	--------> set mode quiet
23	23	-------> set -q _flag_all
100	100	-------> set -q _flag_short
70	70	-------> set -q _flag_no_functions
46	1035	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
17	369	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
31	31	---------> test $selection != files
4	54	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
50	50	----------> functions -q -- $i
5	267	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
173	262	----------> contains -- $i (builtin -n)
89	89	-----------> builtin -n
30	30	--------> set -l paths
10	304	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	---------> test $multi != yes
146	266	---------> set paths (command -s -- $i)
120	120	----------> command -s -- $i
34	223	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
52	52	---------> set res 0
58	58	---------> set found 1
13	13	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	66	---------> if test $multi != yes
                continue
            ...
34	34	----------> test $multi != yes
23	23	----------> continue
4	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
28	28	-------> return $res
11939	11939	------> git rev-parse --git-dir >/dev/null 2>&1
70	70	-----> echo 'git'
26	26	-----> return 0
141	12636	--> set -l repo_branch $red(_repo_branch_name $repo_type)
46	12495	---> _repo_branch_name $repo_type
41	12449	----> _$argv[1]_branch_name
227	12117	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11890	11890	------> git symbolic-ref --quiet HEAD 2>/dev/null
13	291	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
36	36	------> set -q branch[1]
174	242	------> echo (string replace -r '^refs/heads/' '' $branch)
68	68	-------> string replace -r '^refs/heads/' '' $branch
57	57	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	12093	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
123	12088	---> [ (_is_repo_dirty $repo_type) ]
70	11965	----> _is_repo_dirty $repo_type
39	11895	-----> _is_$argv[1]_dirty
155	11856	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11701	11701	-------> git status -s --ignore-submodules=dirty 2>/dev/null
64	64	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
65	2142	> fish_right_prompt
84	84	-> set_color $fish_color_autosuggestion 2> /dev/null
1919	1919	-> date "+%H:%M:%S"
74	74	-> set_color normal
42	483	> fish_title
11	441	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
251	400	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
70	114	---> __fish_pwd
44	44	----> pwd
317	8820	> __fish_cancel_commandline
165	165	-> commandline -f cancel
124	173	-> set -l cmd (commandline)
49	49	--> commandline
36	8118	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
35	35	--> test -n "$cmd"
49	49	--> commandline -C 1000000
10	602	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
29	29	---> set -q fish_color_cancel
312	563	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
194	194	----> set_color $fish_color_cancel
57	57	----> set_color normal
16	3876	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
127	127	---> command -sq tput
181	3733	---> echo -n (tput el; or tput ce)
3552	3552	----> tput el
173	3250	--> for i in (seq (commandline -L))
            echo ""
        ...
2921	2984	---> seq (commandline -L)
63	63	----> commandline -L
93	93	---> echo ""
80	80	--> commandline ""
190	190	--> emit fish_cancel
47	47	-> commandline -f repaint
54	311	> fish_mode_prompt
161	257	-> fish_default_mode_prompt
10	96	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
47	47	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
39	39	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
148	48835	> fish_prompt
43	43	-> set -l __last_command_exit_status $status
4	32	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
148	269	-> set -l cyan (set_color -o cyan)
121	121	--> set_color -o cyan
175	239	-> set -l yellow (set_color -o yellow)
64	64	--> set_color -o yellow
100	151	-> set -l red (set_color -o red)
51	51	--> set_color -o red
90	135	-> set -l green (set_color -o green)
45	45	--> set_color -o green
110	153	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
175	245	-> set -l normal (set_color normal)
70	70	--> set_color normal
55	55	-> set -l arrow_color "$green"
18	67	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
49	49	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
33	33	--> test "$USER" = 'root'
234	3830	-> set -l cwd $cyan(basename (prompt_pwd))
2131	3596	--> basename (prompt_pwd)
378	1465	---> prompt_pwd
102	102	----> set -l options 'h/help'
65	65	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	46	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
40	40	-----> set -q _flag_help
38	38	----> set -q fish_prompt_pwd_dir_length
42	42	----> set -l fish_prompt_pwd_dir_length 1
70	70	----> set realhome ~
195	594	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
399	399	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	130	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
35	35	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
85	85	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
30	43330	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
181	18136	--> set -l repo_type (_repo_type)
35	17955	---> _repo_type
15	17920	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
64	642	-----> _is_hg_repo
355	578	------> fish_print_hg_root >/dev/null
10	223	-------> if not command -sq hg
        return 1
    ...
183	183	--------> not command -sq hg
30	30	--------> return 1
54	17156	-----> _is_git_repo
325	3314	------> type -q git
61	61	-------> set -q argv[1]
146	146	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
108	108	-------> argparse -n type -x t,p,P $options -- $argv
8	67	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
59	59	--------> set -q _flag_help
58	58	-------> set -l res 1
39	39	-------> set -l mode normal
40	40	-------> set -l multi no
30	30	-------> set -l selection all
41	41	-------> set -l short no
13	83	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
38	38	--------> set -q _flag_quiet
32	32	--------> set mode quiet
32	32	-------> set -q _flag_all
26	26	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
45	2209	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
24	1272	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
39	39	---------> test $selection != files
7	588	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
581	581	----------> functions -q -- $i
8	621	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
468	613	----------> contains -- $i (builtin -n)
145	145	-----------> builtin -n
72	72	--------> set -l paths
97	566	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
75	75	---------> test $multi != yes
210	394	---------> set paths (command -s -- $i)
184	184	----------> command -s -- $i
31	194	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
43	43	---------> set res 0
31	31	---------> set found 1
12	12	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	77	---------> if test $multi != yes
                continue
            ...
46	46	----------> test $multi != yes
22	22	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
13788	13788	------> git rev-parse --git-dir >/dev/null 2>&1
80	80	-----> echo 'git'
27	27	-----> return 0
200	12861	--> set -l repo_branch $red(_repo_branch_name $repo_type)
77	12661	---> _repo_branch_name $repo_type
46	12584	----> _$argv[1]_branch_name
171	12274	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
12103	12103	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	264	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
33	33	------> set -q branch[1]
148	219	------> echo (string replace -r '^refs/heads/' '' $branch)
71	71	-------> string replace -r '^refs/heads/' '' $branch
46	46	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	12257	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
105	12252	---> [ (_is_repo_dirty $repo_type) ]
39	12147	----> _is_repo_dirty $repo_type
35	12108	-----> _is_$argv[1]_dirty
175	12073	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11898	11898	-------> git status -s --ignore-submodules=dirty 2>/dev/null
69	69	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
187	2343	> fish_right_prompt
107	107	-> set_color $fish_color_autosuggestion 2> /dev/null
1979	1979	-> date "+%H:%M:%S"
70	70	-> set_color normal
49	637	> fish_title
10	588	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
167	546	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
198	346	---> __fish_pwd
148	148	----> pwd
2000	10443	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/ls.fish
179	2312	-> set -l uname (uname -s)
2133	2133	--> uname -s
181	181	-> complete -c ls -s C -d "Force multi-column output"
34	34	-> test "$uname" != SunOS
39	39	-> complete -c ls -s S -d "Sort by size"
38	38	-> complete -c ls -s m -d "Comma-separated format, fills across screen"
37	37	-> complete -c ls -s x -d "Multi-column output, horizontally listed"
38	38	-> complete -c ls -s 1 -d "List one entry per line"
36	36	-> complete -c ls -s f -d "Unsorted output, enables -a"
37	37	-> complete -c ls -s t -d "Sort by modification time, most recent first"
37	37	-> complete -c ls -s c -d "Sort (-t) by modified time and show time (-l)"
37	37	-> complete -c ls -s u -d "Sort (-t) by access time and show time (-l)"
97	5617	-> if ls --version >/dev/null 2>/dev/null
    complete -c ls -s k -d "Set blocksize to 1kB" # BSD ls -k enables blocksize *output*
    complete -c ls -s a -l all -d "Show hidden"
    complete -c ls -s A -l almost-all -d "Show hidden except . and .."
    complete -c ls -s F -l classify -d "Append filetype indicator (*/=>@|)"
    complete -c ls -s H -l dereference-command-line -d "Follow symlinks"
    complete -c ls -s L -l dereference -d "Follow symlinks"
    complete -c ls -s R -l recursive -d "List subdirectory recursively"
    complete -c ls -s b -l escape -d "Octal escapes for non-graphic characters"
    complete -c ls -s d -l directory -d "List directories, not their content"
    complete -c ls -s h -l human-readable -d "Human readable sizes"
    complete -c ls -s i -l inode -d "Print inode number of files"
    complete -c ls -s n -l numeric-uid-gid -d "Long format, numeric UIDs and GIDs"
    complete -c ls -s p -l file-type -d "Append filetype indicator"
    complete -c ls -s q -l hide-control-chars -d "Replace non-graphic characters with '?'"
    complete -c ls -s r -l reverse -d "Reverse sort order"
    complete -c ls -s s -l size -d "Print size of files"

    # GNU specific ls switches
    complete -c ls -l group-directories-first -d "Group directories before files" -r
    complete -c ls -l hide -d "Do not list implied entries matching specified shell pattern" -r
    complete -c ls -l lcontext -d "Display security context"
    complete -c ls -l context -s Z -d "Display security  context  so  it fits on most displays"
    complete -c ls -l scontext -d "Display only security context and file name"
    complete -c ls -l author -d "Print author"
    complete -c ls -l block-size -x -d "Set block size"
    complete -c ls -s B -l ignore-backups -d "Ignore files ending with ~"
    complete -c ls -l color -f -a "never always auto" -d "Use colors"
    complete -c ls -s D -l dired -d "Generate dired output"
    complete -c ls -l format -x -a "across commas horizontal long single-column verbose vertical" -d "List format"
    complete -c ls -l full-time -d "Long format, full-iso time"
    complete -c ls -s G -l no-group -d "Don't print group information"
    complete -c ls -l si -d "Human readable sizes, powers of 1000"
    complete -c ls -l dereference-command-line-symlink-to-dir #-d "Follow directory symlinks from command line"
    complete -c ls -l indicator-style -x -a "none classify file-type" -d "Append filetype indicator"
    complete -c ls -s I -l ignore -r -d "Skip entries matching pattern"
    complete -c ls -s N -l literal -d "Print raw entry names"
    complete -c ls -s o -d "Long format without groups"
    complete -c ls -l show-control-chars -d "Non-graphic characters printed as-is"
    complete -c ls -s Q -l quote-name -d "Enclose entry in quotes"
    complete -c ls -l quoting-style -x -a "literal locale shell shell-always c escape" -d "Select quoting style"
    complete -c ls -l sort -x -d "Sort criteria" -a "
			extension\t'Sort by file extension'
			none\tDon\'t\ sort
			size\t'Sort by size'
			time\t'Sort by modification time'
			version\t'Sort by version'
			status\t'Sort by file status modification time'
			atime\t'Sort by access time'
			access\t'Sort by access time'
			use\t'Sort by access time'
		"
    complete -c ls -l time -x -d "Show time type" -a "
			time\t'Sort by modification time'
			access\t'Sort by access time'
			use\t'Sort by use time'
			ctime\t'Sort by file status modification time'
			status\t'Sort by status time'
		"
    complete -c ls -l time-style -x -a "full-iso long-iso iso locale" -d "Select time style"
    complete -c ls -s T -l tabsize -x -a "1 2 3 4 5 6 7 8 9 10 11 12" -d "Assume tab stops at each COLS"
    complete -c ls -s U -d "Do not sort"
    complete -c ls -s v -d "Sort by version"
    complete -c ls -s w -l width -x -d "Assume screen width"
    complete -c ls -s X -d "Sort by extension"
    complete -c ls -l help -d "Display help and exit"
    complete -c ls -l version -d "Display version and exit"
else
    ####              ls on eunichs                  ####
    # From latest checked-in man pages as of Nov 2018.
    # Reformatted with Open Group's ordering and spacing,
    # then sorted by prevelance, consolidating option
    # matches.

    #              [         IEEE 1003.1-2017 options         ]  [   extension options  ]
    # freebsd: ls -[ikqrs][glno][Aa][Cmx1][Fp][LH][Rd][Sft][cu]  [hbTBWwPUG ZyI,        ] [-D format] [--color=when] [file ...]
    # netbsd:  ls -[ikqrs][glno][Aa][Cmx1][Fp][L ][Rd][Sft][cu]  [hbTBWwP       XMO     ] [file ...]
    # macOS:   ls -[ikqrs][glno][Aa][Cmx1][Fp][LH][Rd][Sft][cu]  [hbTBWwPUG       Oe@   ] [file ...]
    # openbsd: ls -[ikqrs][glno][Aa][Cmx1][Fp][LH][Rd][Sft][cu]  [  TB                  ] [file ...]
    # solaris: ls -[i qrs][glno][Aa][Cmx1][Fp][LH][Rd][ ft][cu]  [hb               e@EvV] [file ...]

    # netbsd ls -O: only leaf files, no dirs | macos ls -O: include file flags in -l output
    # so: don't complete -H for netbsd, and return early after the ls -P completion.
    #     But not before adding their -X, -M, -O options. Same kind of thing for the other OSes.

    ## IEEE 1003.1-2017 standard options:

    complete -c ls -s i -d "Show inode numbers for files"
    test "$uname" != SunOS
    and complete -c ls -s k -d "for -s: Display sizes in kB, not blocks" # GNU sets block size with -k
    complete -c ls -s q -d "Replace non-graphic characters with '?'"
    complete -c ls -s r -d "Reverse sort order"
    complete -c ls -s s -d "Show file sizes"

    complete -c ls -s g -d "Show group instead of owner in long format"
    complete -c ls -s l -d "Long listing format"
    complete -c ls -s n -d "Long format, numerical UIDs and GIDs"
    contains "$uname" FreeBSD NetBSD OpenBSD DragonFly
    and complete -c ls -o o -d "Long format, show file flags" # annoying BSD
    or complete -c ls -s o -d "Long format, omit group names" # annoying POSIX

    complete -c ls -s A -d "Show hidden except . and .."
    complete -c ls -s a -d "Show hidden entries"

    # -C in common, -m in common, -x in common, -1 in common

    complete -c ls -s F -d "Append indicators. dir/ exec* link@ socket= fifo| whiteout%"
    complete -c ls -s p -d "Append directory indicators"

    complete -c ls -s L -d "Follow all symlinks Cancels -P option"
    test "$uname" != NetBSD
    and complete -c ls -s H -d "Follow symlink given on commandline" # not present on netbsd

    complete -c ls -s R -d "Recursively list subdirectories"
    complete -c ls -s d -d "List directories, not their content"

    # -S in common, -f in common, -t in common
    # -c in common, -u in common
    ## These options are not standardized:
    if [ "$uname" != OpenBSD ]
        complete -c ls -s h -d "Human-readable sizes"
        complete -c ls -s b -d "C escapes for non-graphic characters"
        if [ "$uname" = SunOS ]
            complete -c ls -s e -d "Like -l, but fixed time format with seconds"
            complete -c ls -s @ -d "Like -l, but xattrs shown instead of ACLs"
            complete -c ls -s E -d "Like -l, but fixed time format with nanoseconds"
            complete -c ls -s v -d "Like -l, but verbose ACL information shown as well as -l output"
            complete -c ls -s V -d "Like -l, but compact ACL information printed after -l output"
            exit 0
        end
    else
        exit 0 # OpenBSD
    end
    complete -c ls -s T -d "for -l: Show complete date and time"
    complete -c ls -s B -d "Octal escapes for non-graphic characters"
    complete -c ls -s W -d "Display whiteouts when scanning directories"
    complete -c ls -s w -d "Force raw printing of non-printable characters"
    complete -c ls -s P -d "Don't follow symlinks"
    switch "$uname"
        case NetBSD
            complete -c ls -s X -d "Don't cross mount points when recursing"
            complete -c ls -s M -d "for -l, -s: Format size/count with commas"
            complete -c ls -s O -d "Show only leaf files (not dirs), eliding other output"
            exit 0
        case Darwin
            complete -c ls -s O -d "for -l: Show file flags"
            complete -c ls -s e -d "for -l: Print ACL associated with file, if present"
            complete -c ls -s @ -d "for -l: Display extended attributes"
        case FreeBSD
            complete -c ls -s Z -d "Display each file's MAC label"
            complete -c ls -s y -d "for -t: Sort A-Z output in same order as time output"
            complete -c ls -s I -d "Prevent -A from being automatically set for root"
            complete -c ls -s , -d "for -l: Format size/count number groups with ,/locale"
            complete -r -c ls -s D -d "for -l: Format date with strptime string"
            complete -c ls -l color -f -a "auto always never" -d "Enable color output"
    end
    complete -c ls -s U -d "Sort (-t) by creation time and show time (-l)"
    complete -c ls -s G -d "Enable colorized output" # macos, freebsd.
...
127	3852	--> ls --version >/dev/null 2>/dev/null
232	2009	---> isatty stdout
38	38	----> set -l options 'h/help'
40	40	----> argparse -n isatty $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
26	26	-----> set -q _flag_help
3	28	----> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
25	25	-----> set -q argv[2]
26	26	----> set -l fd
15	41	----> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
26	26	-----> set fd 1
1574	1574	----> command [ -t "$fd" ]
1716	1716	---> command ls $opt $argv
73	73	--> complete -c ls -s i -d "Show inode numbers for files"
64	64	--> test "$uname" != SunOS
49	49	--> complete -c ls -s k -d "for -s: Display sizes in kB, not blocks"
39	39	--> complete -c ls -s q -d "Replace non-graphic characters with '?'"
116	116	--> complete -c ls -s r -d "Reverse sort order"
82	82	--> complete -c ls -s s -d "Show file sizes"
38	38	--> complete -c ls -s g -d "Show group instead of owner in long format"
41	41	--> complete -c ls -s l -d "Long listing format"
36	36	--> complete -c ls -s n -d "Long format, numerical UIDs and GIDs"
40	40	--> contains "$uname" FreeBSD NetBSD OpenBSD DragonFly
37	37	--> complete -c ls -s o -d "Long format, omit group names"
36	36	--> complete -c ls -s A -d "Show hidden except . and .."
104	104	--> complete -c ls -s a -d "Show hidden entries"
79	79	--> complete -c ls -s F -d "Append indicators. dir/ exec* link@ socket= fifo| whiteout%"
79	79	--> complete -c ls -s p -d "Append directory indicators"
55	55	--> complete -c ls -s L -d "Follow all symlinks Cancels -P option"
33	33	--> test "$uname" != NetBSD
39	39	--> complete -c ls -s H -d "Follow symlink given on commandline"
36	36	--> complete -c ls -s R -d "Recursively list subdirectories"
36	36	--> complete -c ls -s d -d "List directories, not their content"
26	170	--> if [ "$uname" != OpenBSD ]
        complete -c ls -s h -d "Human-readable sizes"
        complete -c ls -s b -d "C escapes for non-graphic characters"
        if [ "$uname" = SunOS ]
            complete -c ls -s e -d "Like -l, but fixed time format with seconds"
            complete -c ls -s @ -d "Like -l, but xattrs shown instead of ACLs"
            complete -c ls -s E -d "Like -l, but fixed time format with nanoseconds"
            complete -c ls -s v -d "Like -l, but verbose ACL information shown as well as -l output"
            complete -c ls -s V -d "Like -l, but compact ACL information printed after -l output"
            exit 0
        end
    else
        exit 0 # OpenBSD
    ...
30	30	---> [ "$uname" != OpenBSD ]
44	44	---> complete -c ls -s h -d "Human-readable sizes"
37	37	---> complete -c ls -s b -d "C escapes for non-graphic characters"
4	33	---> if [ "$uname" = SunOS ]
            complete -c ls -s e -d "Like -l, but fixed time format with seconds"
            complete -c ls -s @ -d "Like -l, but xattrs shown instead of ACLs"
            complete -c ls -s E -d "Like -l, but fixed time format with nanoseconds"
            complete -c ls -s v -d "Like -l, but verbose ACL information shown as well as -l output"
            complete -c ls -s V -d "Like -l, but compact ACL information printed after -l output"
            exit 0
        ...
29	29	----> [ "$uname" = SunOS ]
37	37	--> complete -c ls -s T -d "for -l: Show complete date and time"
37	37	--> complete -c ls -s B -d "Octal escapes for non-graphic characters"
36	36	--> complete -c ls -s W -d "Display whiteouts when scanning directories"
37	37	--> complete -c ls -s w -d "Force raw printing of non-printable characters"
36	36	--> complete -c ls -s P -d "Don't follow symlinks"
19	130	--> switch "$uname"
        case NetBSD
            complete -c ls -s X -d "Don't cross mount points when recursing"
            complete -c ls -s M -d "for -l, -s: Format size/count with commas"
            complete -c ls -s O -d "Show only leaf files (not dirs), eliding other output"
            exit 0
        case Darwin
            complete -c ls -s O -d "for -l: Show file flags"
            complete -c ls -s e -d "for -l: Print ACL associated with file, if present"
            complete -c ls -s @ -d "for -l: Display extended attributes"
        case FreeBSD
            complete -c ls -s Z -d "Display each file's MAC label"
            complete -c ls -s y -d "for -t: Sort A-Z output in same order as time output"
            complete -c ls -s I -d "Prevent -A from being automatically set for root"
            complete -c ls -s , -d "for -l: Format size/count number groups with ,/locale"
            complete -r -c ls -s D -d "for -l: Format date with strptime string"
            complete -c ls -l color -f -a "auto always never" -d "Enable color output"
    ...
40	40	---> complete -c ls -s O -d "for -l: Show file flags"
36	36	---> complete -c ls -s e -d "for -l: Print ACL associated with file, if present"
35	35	---> complete -c ls -s @ -d "for -l: Display extended attributes"
37	37	--> complete -c ls -s U -d "Sort (-t) by creation time and show time (-l)"
36	36	--> complete -c ls -s G -d "Enable colorized output"
62	319	> __fish_disable_bracketed_paste 'ls -s --help'
257	257	-> printf "\e[?2004l"
55	488	> fish_title ls\ -s\ --help
10	433	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
34	34	--> not set -q INSIDE_EMACS
256	389	--> echo (status current-command) (__fish_pwd)
41	41	---> status current-command
50	92	---> __fish_pwd
42	42	----> pwd
163	6966	> ls -s --help
110	3951	-> isatty stdout
39	39	--> set -l options 'h/help'
44	44	--> argparse -n isatty $options -- $argv
6	35	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
29	29	---> set -q _flag_help
6	43	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
37	37	---> set -q argv[2]
31	31	--> set -l fd
20	52	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
32	32	---> set fd 1
3597	3597	--> command [ -t "$fd" ]
108	108	-> set -a opt -F
2744	2744	-> command ls $opt $argv
75	236	> __fish_enable_bracketed_paste
161	161	-> printf "\e[?2004h"
56	216	> fish_mode_prompt
56	160	-> fish_default_mode_prompt
10	104	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
46	46	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
48	48	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
114	40360	> fish_prompt
43	43	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
104	165	-> set -l cyan (set_color -o cyan)
61	61	--> set_color -o cyan
96	141	-> set -l yellow (set_color -o yellow)
45	45	--> set_color -o yellow
92	136	-> set -l red (set_color -o red)
44	44	--> set_color -o red
102	162	-> set -l green (set_color -o green)
60	60	--> set_color -o green
162	205	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
126	178	-> set -l normal (set_color normal)
52	52	--> set_color normal
36	36	-> set -l arrow_color "$green"
8	71	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	--> set arrow_color "$red"
33	33	-> set -l arrow "$arrow_color➜ "
4	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
134	2414	-> set -l cwd $cyan(basename (prompt_pwd))
1675	2280	--> basename (prompt_pwd)
90	605	---> prompt_pwd
45	45	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
28	28	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
127	207	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
80	80	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	104	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
61	61	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
26	36523	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
116	12595	--> set -l repo_type (_repo_type)
35	12479	---> _repo_type
15	12444	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
29	274	-----> _is_hg_repo
71	245	------> fish_print_hg_root >/dev/null
9	174	-------> if not command -sq hg
        return 1
    ...
137	137	--------> not command -sq hg
28	28	--------> return 1
46	12063	-----> _is_git_repo
168	2079	------> type -q git
46	46	-------> set -q argv[1]
55	55	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
69	69	-------> argparse -n type -x t,p,P $options -- $argv
4	34	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
30	30	--------> set -q _flag_help
27	27	-------> set -l res 1
27	27	-------> set -l mode normal
27	27	-------> set -l multi no
28	28	-------> set -l selection all
28	28	-------> set -l short no
10	64	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
28	28	--------> set mode quiet
27	27	-------> set -q _flag_all
28	28	-------> set -q _flag_short
25	25	-------> set -q _flag_no_functions
40	1377	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
40	40	--------> set -l found 0
38	623	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
45	45	---------> test $selection != files
5	91	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
86	86	----------> functions -q -- $i
6	449	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
343	443	----------> contains -- $i (builtin -n)
100	100	-----------> builtin -n
38	38	--------> set -l paths
11	334	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
34	34	---------> test $multi != yes
152	289	---------> set paths (command -s -- $i)
137	137	----------> command -s -- $i
39	265	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
49	49	---------> set res 0
33	33	---------> set found 1
39	39	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
12	105	---------> if test $multi != yes
                continue
            ...
66	66	----------> test $multi != yes
27	27	----------> continue
5	37	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
32	32	---------> test $found = 0
49	49	-------> return $res
9938	9938	------> git rev-parse --git-dir >/dev/null 2>&1
67	67	-----> echo 'git'
25	25	-----> return 0
117	10592	--> set -l repo_branch $red(_repo_branch_name $repo_type)
43	10475	---> _repo_branch_name $repo_type
40	10432	----> _$argv[1]_branch_name
261	9956	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9695	9695	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	436	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
118	118	------> set -q branch[1]
178	306	------> echo (string replace -r '^refs/heads/' '' $branch)
128	128	-------> string replace -r '^refs/heads/' '' $branch
50	50	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
6	13260	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
163	13254	---> [ (_is_repo_dirty $repo_type) ]
40	13091	----> _is_repo_dirty $repo_type
38	13051	-----> _is_$argv[1]_dirty
235	13013	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
12778	12778	-------> git status -s --ignore-submodules=dirty 2>/dev/null
70	70	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
118	2741	> fish_right_prompt
112	112	-> set_color $fish_color_autosuggestion 2> /dev/null
2435	2435	-> date "+%H:%M:%S"
76	76	-> set_color normal
61	489	> fish_title
9	428	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
48	48	--> not set -q INSIDE_EMACS
218	371	--> echo (status current-command) (__fish_pwd)
50	50	---> status current-command
62	103	---> __fish_pwd
41	41	----> pwd
372	715	> up-or-search
7	53	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
46	46	--> commandline --search-mode
4	38	-> if commandline --paging-mode
        commandline -f up-line
        return
    ...
34	34	--> commandline --paging-mode
148	193	-> set lineno (commandline -L)
45	45	--> commandline -L
15	59	-> switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    ...
44	44	--> commandline -f history-search-backward
58	117	> __fish_disable_bracketed_paste 'ls -h'
59	59	-> printf "\e[?2004l"
53	456	> fish_title ls\ -h
10	403	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
207	363	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
79	122	---> __fish_pwd
43	43	----> pwd
115	6176	> ls -h
123	3388	-> isatty stdout
36	36	--> set -l options 'h/help'
40	40	--> argparse -n isatty $options -- $argv
6	32	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
26	26	---> set -q _flag_help
5	30	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
25	25	---> set -q argv[2]
27	27	--> set -l fd
16	48	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
32	32	---> set fd 1
3052	3052	--> command [ -t "$fd" ]
54	54	-> set -a opt -F
2619	2619	-> command ls $opt $argv
41	95	> __fish_enable_bracketed_paste
54	54	-> printf "\e[?2004h"
50	182	> fish_mode_prompt
49	132	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
43	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
93	40667	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
97	150	-> set -l cyan (set_color -o cyan)
53	53	--> set_color -o cyan
104	149	-> set -l yellow (set_color -o yellow)
45	45	--> set_color -o yellow
115	175	-> set -l red (set_color -o red)
60	60	--> set_color -o red
130	180	-> set -l green (set_color -o green)
50	50	--> set_color -o green
114	167	-> set -l blue (set_color -o blue)
53	53	--> set_color -o blue
97	140	-> set -l normal (set_color normal)
43	43	--> set_color normal
35	35	-> set -l arrow_color "$green"
3	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
4	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
31	31	--> test "$USER" = 'root'
118	2012	-> set -l cwd $cyan(basename (prompt_pwd))
1360	1894	--> basename (prompt_pwd)
73	534	---> prompt_pwd
35	35	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
3	28	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
32	32	----> set realhome ~
98	176	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
78	78	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	99	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
59	59	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
17	37320	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
170	11634	--> set -l repo_type (_repo_type)
43	11464	---> _repo_type
15	11421	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
28	282	-----> _is_hg_repo
75	254	------> fish_print_hg_root >/dev/null
10	179	-------> if not command -sq hg
        return 1
    ...
140	140	--------> not command -sq hg
29	29	--------> return 1
58	11029	-----> _is_git_repo
90	1493	------> type -q git
27	27	-------> set -q argv[1]
46	46	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
64	64	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
7	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
25	25	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
42	955	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
17	397	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
35	35	---------> test $selection != files
5	71	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
66	66	----------> functions -q -- $i
6	274	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
217	268	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
33	33	--------> set -l paths
9	271	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
111	232	---------> set paths (command -s -- $i)
121	121	----------> command -s -- $i
26	154	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
31	31	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	60	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
22	22	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
9478	9478	------> git rev-parse --git-dir >/dev/null 2>&1
68	68	-----> echo 'git'
27	27	-----> return 0
181	11511	--> set -l repo_branch $red(_repo_branch_name $repo_type)
43	11330	---> _repo_branch_name $repo_type
37	11287	----> _$argv[1]_branch_name
299	10977	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10678	10678	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	273	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
156	231	------> echo (string replace -r '^refs/heads/' '' $branch)
75	75	-------> string replace -r '^refs/heads/' '' $branch
91	91	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	14067	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
124	14062	---> [ (_is_repo_dirty $repo_type) ]
91	13938	----> _is_repo_dirty $repo_type
91	13847	-----> _is_$argv[1]_dirty
341	13756	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
13415	13415	-------> git status -s --ignore-submodules=dirty 2>/dev/null
78	78	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
75	2458	> fish_right_prompt
175	175	-> set_color $fish_color_autosuggestion 2> /dev/null
2140	2140	-> date "+%H:%M:%S"
68	68	-> set_color normal
62	494	> fish_title
10	432	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
264	391	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
53	93	---> __fish_pwd
40	40	----> pwd
575	1207	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/ln.fish
60	60	-> complete -c ln -s s -l symbolic -d 'Make symbolic links instead of hard links'
56	56	-> complete -c ln -l backup -d 'Make a backup of each existing destination file' -a "none off numbered t existing nil simple never"
40	40	-> complete -c ln -s b -d 'Make a backup of each existing destination file'
40	40	-> complete -c ln -s d -l directory -d 'Allow superuser to attempt to hard link directories'
39	39	-> complete -c ln -s f -l force -d 'Remove existing destination files'
42	42	-> complete -c ln -s i -l interactive -d 'Prompt whether to remove destinations'
38	38	-> complete -c ln -s L -l logical -d 'Dereference TARGETs that are symbolic links'
38	38	-> complete -c ln -s n -l no-dereference -d 'Treat symlink to directory as if it were a file'
37	37	-> complete -c ln -s P -l physical -d 'Make hard links directly to symbolic links'
40	40	-> complete -c ln -s S -l suffix -d 'Override the usual ~ backup suffix'
50	50	-> complete -c ln -s t -l target-directory -d 'Specify the DIRECTORY in which to create the links' -a '(__fish_complete_directories)'
40	40	-> complete -c ln -s T -l no-target-directory -d 'Treat LINK_NAME as a normal file'
40	40	-> complete -c ln -s v -l verbose -d 'Print name of each linked file'
36	36	-> complete -c ln -f -l help -d 'Display help and exit'
36	36	-> complete -c ln -f -l version -d 'Output version information and exit'
68	144	> __fish_disable_bracketed_paste 'ln -s --help'
76	76	-> printf "\e[?2004l"
138	1025	> fish_title ln\ -s\ --help
42	887	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
73	73	--> not set -q INSIDE_EMACS
388	772	--> echo (status current-command) (__fish_pwd)
95	95	---> status current-command
175	289	---> __fish_pwd
114	114	----> pwd
5046	5046	> ln -s --help
115	197	> __fish_enable_bracketed_paste
82	82	-> printf "\e[?2004h"
54	297	> fish_mode_prompt
65	243	-> fish_default_mode_prompt
10	178	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
56	56	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
112	112	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
204	43249	> fish_prompt
79	79	-> set -l __last_command_exit_status $status
16	70	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
54	54	--> not set -q -g __fish_robbyrussell_functions_defined
163	242	-> set -l cyan (set_color -o cyan)
79	79	--> set_color -o cyan
140	200	-> set -l yellow (set_color -o yellow)
60	60	--> set_color -o yellow
125	180	-> set -l red (set_color -o red)
55	55	--> set_color -o red
169	222	-> set -l green (set_color -o green)
53	53	--> set_color -o green
126	186	-> set -l blue (set_color -o blue)
60	60	--> set_color -o blue
112	160	-> set -l normal (set_color normal)
48	48	--> set_color normal
35	35	-> set -l arrow_color "$green"
8	70	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
32	32	--> set arrow_color "$red"
33	33	-> set -l arrow "$arrow_color➜ "
4	84	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
80	80	--> test "$USER" = 'root'
127	2183	-> set -l cwd $cyan(basename (prompt_pwd))
1391	2056	--> basename (prompt_pwd)
98	665	---> prompt_pwd
39	39	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
35	35	----> set realhome ~
133	211	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
78	78	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
15	159	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
74	74	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
70	70	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
21	39202	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
123	13281	--> set -l repo_type (_repo_type)
34	13158	---> _repo_type
15	13124	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
27	271	-----> _is_hg_repo
70	244	------> fish_print_hg_root >/dev/null
9	174	-------> if not command -sq hg
        return 1
    ...
138	138	--------> not command -sq hg
27	27	--------> return 1
47	12741	-----> _is_git_repo
132	1838	------> type -q git
26	26	-------> set -q argv[1]
48	48	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
67	67	-------> argparse -n type -x t,p,P $options -- $argv
3	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
49	49	-------> set -l res 1
42	42	-------> set -l mode normal
44	44	-------> set -l multi no
29	29	-------> set -l selection all
29	29	-------> set -l short no
7	58	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	--------> set -q _flag_quiet
26	26	--------> set mode quiet
25	25	-------> set -q _flag_all
30	30	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
58	1164	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
17	436	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	58	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
54	54	----------> functions -q -- $i
6	331	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
271	325	----------> contains -- $i (builtin -n)
54	54	-----------> builtin -n
34	34	--------> set -l paths
10	314	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
32	32	---------> test $multi != yes
129	272	---------> set paths (command -s -- $i)
143	143	----------> command -s -- $i
36	236	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
42	42	---------> set res 0
37	37	---------> set found 1
14	14	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
13	107	---------> if test $multi != yes
                continue
            ...
47	47	----------> test $multi != yes
47	47	----------> continue
6	57	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
51	51	---------> test $found = 0
41	41	-------> return $res
10856	10856	------> git rev-parse --git-dir >/dev/null 2>&1
70	70	-----> echo 'git'
27	27	-----> return 0
107	11212	--> set -l repo_branch $red(_repo_branch_name $repo_type)
45	11105	---> _repo_branch_name $repo_type
36	11060	----> _$argv[1]_branch_name
194	10714	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10520	10520	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	310	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
187	270	------> echo (string replace -r '^refs/heads/' '' $branch)
83	83	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
4	14645	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
177	14641	---> [ (_is_repo_dirty $repo_type) ]
39	14464	----> _is_repo_dirty $repo_type
37	14425	-----> _is_$argv[1]_dirty
205	14388	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
14183	14183	-------> git status -s --ignore-submodules=dirty 2>/dev/null
99	99	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
79	2224	> fish_right_prompt
93	93	-> set_color $fish_color_autosuggestion 2> /dev/null
1985	1985	-> date "+%H:%M:%S"
67	67	-> set_color normal
42	418	> fish_title
10	376	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
223	336	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
45	81	---> __fish_pwd
36	36	----> pwd
164	606	> __fish_cancel_commandline
68	68	-> commandline -f cancel
174	236	-> set -l cmd (commandline)
62	62	--> commandline
10	65	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
55	55	--> test -n "$cmd"
73	73	-> commandline -f repaint
54	195	> fish_mode_prompt
50	141	-> fish_default_mode_prompt
9	91	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
45	45	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
37	37	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
108	39836	> fish_prompt
40	40	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
126	180	-> set -l cyan (set_color -o cyan)
54	54	--> set_color -o cyan
267	345	-> set -l yellow (set_color -o yellow)
78	78	--> set_color -o yellow
129	186	-> set -l red (set_color -o red)
57	57	--> set_color -o red
123	183	-> set -l green (set_color -o green)
60	60	--> set_color -o green
116	175	-> set -l blue (set_color -o blue)
59	59	--> set_color -o blue
112	164	-> set -l normal (set_color normal)
52	52	--> set_color normal
40	40	-> set -l arrow_color "$green"
8	80	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
35	35	--> test $__last_command_exit_status != 0
37	37	--> set arrow_color "$red"
37	37	-> set -l arrow "$arrow_color➜ "
4	38	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
34	34	--> test "$USER" = 'root'
275	2972	-> set -l cwd $cyan(basename (prompt_pwd))
2124	2697	--> basename (prompt_pwd)
69	573	---> prompt_pwd
38	38	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
27	27	----> set -q fish_prompt_pwd_dir_length
29	29	----> set -l fish_prompt_pwd_dir_length 1
35	35	----> set realhome ~
123	202	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
79	79	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	102	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
58	58	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
17	35186	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
133	13315	--> set -l repo_type (_repo_type)
31	13182	---> _repo_type
48	13151	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
47	312	-----> _is_hg_repo
79	265	------> fish_print_hg_root >/dev/null
9	186	-------> if not command -sq hg
        return 1
    ...
148	148	--------> not command -sq hg
29	29	--------> return 1
58	12676	-----> _is_git_repo
133	2284	------> type -q git
36	36	-------> set -q argv[1]
99	99	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
183	183	-------> argparse -n type -x t,p,P $options -- $argv
5	67	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
62	62	--------> set -q _flag_help
46	46	-------> set -l res 1
26	26	-------> set -l mode normal
60	60	-------> set -l multi no
40	40	-------> set -l selection all
40	40	-------> set -l short no
13	90	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
37	37	--------> set -q _flag_quiet
40	40	--------> set mode quiet
37	37	-------> set -q _flag_all
34	34	-------> set -q _flag_short
35	35	-------> set -q _flag_no_functions
43	1330	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
60	60	--------> set -l found 0
22	542	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
47	47	---------> test $selection != files
7	87	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
80	80	----------> functions -q -- $i
5	386	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
297	381	----------> contains -- $i (builtin -n)
84	84	-----------> builtin -n
32	32	--------> set -l paths
9	358	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
172	319	---------> set paths (command -s -- $i)
147	147	----------> command -s -- $i
40	222	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
51	51	---------> set res 0
64	64	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	57	---------> if test $multi != yes
                continue
            ...
27	27	----------> test $multi != yes
22	22	----------> continue
20	73	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
53	53	---------> test $found = 0
28	28	-------> return $res
10334	10334	------> git rev-parse --git-dir >/dev/null 2>&1
88	88	-----> echo 'git'
27	27	-----> return 0
109	10529	--> set -l repo_branch $red(_repo_branch_name $repo_type)
40	10420	---> _repo_branch_name $repo_type
36	10380	----> _$argv[1]_branch_name
137	10112	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9975	9975	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	232	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
35	35	------> set -q branch[1]
123	185	------> echo (string replace -r '^refs/heads/' '' $branch)
62	62	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
6	11282	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
112	11276	---> [ (_is_repo_dirty $repo_type) ]
40	11164	----> _is_repo_dirty $repo_type
33	11124	-----> _is_$argv[1]_dirty
145	11091	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10946	10946	-------> git status -s --ignore-submodules=dirty 2>/dev/null
69	69	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
64	1949	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
1736	1736	-> date "+%H:%M:%S"
61	61	-> set_color normal
40	351	> fish_title
9	311	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
164	273	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
42	78	---> __fish_pwd
36	36	----> pwd
449	954	> __fish_cancel_commandline
207	207	-> commandline -f cancel
150	206	-> set -l cmd (commandline)
56	56	--> commandline
7	46	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
39	39	--> test -n "$cmd"
46	46	-> commandline -f repaint
84	522	> fish_mode_prompt
326	438	-> fish_default_mode_prompt
11	112	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
56	56	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
45	45	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
176	40874	> fish_prompt
54	54	-> set -l __last_command_exit_status $status
6	43	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
37	37	--> not set -q -g __fish_robbyrussell_functions_defined
168	394	-> set -l cyan (set_color -o cyan)
226	226	--> set_color -o cyan
168	246	-> set -l yellow (set_color -o yellow)
78	78	--> set_color -o yellow
155	223	-> set -l red (set_color -o red)
68	68	--> set_color -o red
185	251	-> set -l green (set_color -o green)
66	66	--> set_color -o green
197	279	-> set -l blue (set_color -o blue)
82	82	--> set_color -o blue
170	233	-> set -l normal (set_color normal)
63	63	--> set_color normal
50	50	-> set -l arrow_color "$green"
10	98	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
41	41	--> test $__last_command_exit_status != 0
47	47	--> set arrow_color "$red"
63	63	-> set -l arrow "$arrow_color➜ "
8	114	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
106	106	--> test "$USER" = 'root'
182	3296	-> set -l cwd $cyan(basename (prompt_pwd))
1983	3114	--> basename (prompt_pwd)
280	1131	---> prompt_pwd
58	58	----> set -l options 'h/help'
49	49	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	41	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
37	37	-----> set -q _flag_help
30	30	----> set -q fish_prompt_pwd_dir_length
31	31	----> set -l fish_prompt_pwd_dir_length 1
40	40	----> set realhome ~
222	472	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
250	250	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	130	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
44	44	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
74	74	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
16	35289	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
164	13149	--> set -l repo_type (_repo_type)
34	12985	---> _repo_type
16	12951	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
29	454	-----> _is_hg_repo
244	425	------> fish_print_hg_root >/dev/null
11	181	-------> if not command -sq hg
        return 1
    ...
140	140	--------> not command -sq hg
30	30	--------> return 1
47	12269	-----> _is_git_repo
220	2091	------> type -q git
30	30	-------> set -q argv[1]
51	51	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
89	89	-------> argparse -n type -x t,p,P $options -- $argv
6	67	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
61	61	--------> set -q _flag_help
35	35	-------> set -l res 1
32	32	-------> set -l mode normal
31	31	-------> set -l multi no
31	31	-------> set -l selection all
29	29	-------> set -l short no
10	65	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
29	29	--------> set mode quiet
27	27	-------> set -q _flag_all
26	26	-------> set -q _flag_short
25	25	-------> set -q _flag_no_functions
36	1302	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
13	735	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
34	34	---------> test $selection != files
5	309	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
304	304	----------> functions -q -- $i
6	379	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
316	373	----------> contains -- $i (builtin -n)
57	57	-----------> builtin -n
35	35	--------> set -l paths
9	274	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
33	33	---------> test $multi != yes
109	232	---------> set paths (command -s -- $i)
123	123	----------> command -s -- $i
25	158	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
31	31	---------> set res 0
29	29	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	63	---------> if test $multi != yes
                continue
            ...
31	31	----------> test $multi != yes
25	25	----------> continue
3	33	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	---------> test $found = 0
31	31	-------> return $res
10131	10131	------> git rev-parse --git-dir >/dev/null 2>&1
186	186	-----> echo 'git'
26	26	-----> return 0
115	10176	--> set -l repo_branch $red(_repo_branch_name $repo_type)
59	10061	---> _repo_branch_name $repo_type
44	10002	----> _$argv[1]_branch_name
140	9734	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9594	9594	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	224	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
116	183	------> echo (string replace -r '^refs/heads/' '' $branch)
67	67	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
4	11905	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
97	11901	---> [ (_is_repo_dirty $repo_type) ]
38	11804	----> _is_repo_dirty $repo_type
34	11766	-----> _is_$argv[1]_dirty
162	11732	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11570	11570	-------> git status -s --ignore-submodules=dirty 2>/dev/null
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
176	2343	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
2001	2001	-> date "+%H:%M:%S"
75	75	-> set_color normal
62	658	> fish_title
10	596	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
183	553	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
172	337	---> __fish_pwd
165	165	----> pwd
48	270	> __fish_disable_bracketed_paste clear
222	222	-> printf "\e[?2004l"
46	452	> fish_title clear
11	406	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
219	362	--> echo (status current-command) (__fish_pwd)
36	36	---> status current-command
62	107	---> __fish_pwd
45	45	----> pwd
2913	2913	> clear
57	118	> __fish_enable_bracketed_paste
61	61	-> printf "\e[?2004h"
57	195	> fish_mode_prompt
53	138	-> fish_default_mode_prompt
8	85	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
44	44	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
93	43259	> fish_prompt
38	38	-> set -l __last_command_exit_status $status
3	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
143	202	-> set -l cyan (set_color -o cyan)
59	59	--> set_color -o cyan
104	160	-> set -l yellow (set_color -o yellow)
56	56	--> set_color -o yellow
121	168	-> set -l red (set_color -o red)
47	47	--> set_color -o red
115	171	-> set -l green (set_color -o green)
56	56	--> set_color -o green
109	160	-> set -l blue (set_color -o blue)
51	51	--> set_color -o blue
95	139	-> set -l normal (set_color normal)
44	44	--> set_color normal
35	35	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
4	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
151	2280	-> set -l cwd $cyan(basename (prompt_pwd))
1568	2129	--> basename (prompt_pwd)
75	561	---> prompt_pwd
37	37	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
99	177	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
78	78	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	120	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
76	76	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
28	39616	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
167	13103	--> set -l repo_type (_repo_type)
37	12936	---> _repo_type
17	12899	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
27	287	-----> _is_hg_repo
81	260	------> fish_print_hg_root >/dev/null
9	179	-------> if not command -sq hg
        return 1
    ...
142	142	--------> not command -sq hg
28	28	--------> return 1
52	12488	-----> _is_git_repo
100	1379	------> type -q git
26	26	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
69	69	-------> argparse -n type -x t,p,P $options -- $argv
3	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
29	29	-------> set -l res 1
27	27	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
7	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
25	25	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
29	821	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
17	326	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
31	31	---------> test $selection != files
4	52	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
48	48	----------> functions -q -- $i
5	226	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
170	221	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
29	29	--------> set -l paths
8	240	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
28	28	---------> test $multi != yes
94	204	---------> set paths (command -s -- $i)
110	110	----------> command -s -- $i
21	140	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
27	27	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	56	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
22	22	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
27	27	-------> return $res
11057	11057	------> git rev-parse --git-dir >/dev/null 2>&1
79	79	-----> echo 'git'
28	28	-----> return 0
278	14131	--> set -l repo_branch $red(_repo_branch_name $repo_type)
60	13853	---> _repo_branch_name $repo_type
38	13793	----> _$argv[1]_branch_name
347	13437	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
13090	13090	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	318	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
175	278	------> echo (string replace -r '^refs/heads/' '' $branch)
103	103	-------> string replace -r '^refs/heads/' '' $branch
149	149	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
6	12205	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
153	12199	---> [ (_is_repo_dirty $repo_type) ]
93	12046	----> _is_repo_dirty $repo_type
72	11953	-----> _is_$argv[1]_dirty
234	11881	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11647	11647	-------> git status -s --ignore-submodules=dirty 2>/dev/null
62	62	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
67	1963	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
1733	1733	-> date "+%H:%M:%S"
75	75	-> set_color normal
39	351	> fish_title
10	312	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
158	272	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
42	81	---> __fish_pwd
39	39	----> pwd
144	500	> __fish_disable_bracketed_paste ls
356	356	-> printf "\e[?2004l"
65	1240	> fish_title ls
16	1175	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
38	38	--> not set -q INSIDE_EMACS
581	1121	--> echo (status current-command) (__fish_pwd)
45	45	---> status current-command
285	495	---> __fish_pwd
210	210	----> pwd
292	7523	> ls
286	4289	-> isatty stdout
59	59	--> set -l options 'h/help'
60	60	--> argparse -n isatty $options -- $argv
11	57	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
46	46	---> set -q _flag_help
9	52	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
43	43	---> set -q argv[2]
43	43	--> set -l fd
20	51	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
31	31	---> set fd 1
3681	3681	--> command [ -t "$fd" ]
57	57	-> set -a opt -F
2885	2885	-> command ls $opt $argv
45	101	> __fish_enable_bracketed_paste
56	56	-> printf "\e[?2004h"
56	316	> fish_mode_prompt
173	260	-> fish_default_mode_prompt
10	87	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
45	45	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
96	40465	> fish_prompt
37	37	-> set -l __last_command_exit_status $status
4	32	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
113	281	-> set -l cyan (set_color -o cyan)
168	168	--> set_color -o cyan
100	146	-> set -l yellow (set_color -o yellow)
46	46	--> set_color -o yellow
95	139	-> set -l red (set_color -o red)
44	44	--> set_color -o red
94	139	-> set -l green (set_color -o green)
45	45	--> set_color -o green
96	140	-> set -l blue (set_color -o blue)
44	44	--> set_color -o blue
95	137	-> set -l normal (set_color normal)
42	42	--> set_color normal
34	34	-> set -l arrow_color "$green"
4	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
29	29	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	34	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
31	31	--> test "$USER" = 'root'
230	3721	-> set -l cwd $cyan(basename (prompt_pwd))
2386	3491	--> basename (prompt_pwd)
314	1105	---> prompt_pwd
79	79	----> set -l options 'h/help'
54	54	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	32	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
28	28	-----> set -q _flag_help
37	37	----> set -q fish_prompt_pwd_dir_length
29	29	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
136	419	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
283	283	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	107	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
63	63	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
24	35400	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
129	13678	--> set -l repo_type (_repo_type)
69	13549	---> _repo_type
15	13480	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
37	509	-----> _is_hg_repo
283	472	------> fish_print_hg_root >/dev/null
12	189	-------> if not command -sq hg
        return 1
    ...
148	148	--------> not command -sq hg
29	29	--------> return 1
78	12862	-----> _is_git_repo
380	2386	------> type -q git
67	67	-------> set -q argv[1]
53	53	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
75	75	-------> argparse -n type -x t,p,P $options -- $argv
4	35	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
31	31	--------> set -q _flag_help
28	28	-------> set -l res 1
28	28	-------> set -l mode normal
30	30	-------> set -l multi no
29	29	-------> set -l selection all
26	26	-------> set -l short no
25	114	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
63	63	--------> set mode quiet
29	29	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
33	1418	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
30	30	--------> set -l found 0
21	861	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
3	296	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
293	293	----------> functions -q -- $i
5	512	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
448	507	----------> contains -- $i (builtin -n)
59	59	-----------> builtin -n
34	34	--------> set -l paths
9	281	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
32	32	---------> test $multi != yes
108	240	---------> set paths (command -s -- $i)
132	132	----------> command -s -- $i
23	148	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	60	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
23	23	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
10398	10398	------> git rev-parse --git-dir >/dev/null 2>&1
68	68	-----> echo 'git'
26	26	-----> return 0
138	10336	--> set -l repo_branch $red(_repo_branch_name $repo_type)
42	10198	---> _repo_branch_name $repo_type
39	10156	----> _$argv[1]_branch_name
137	9877	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9740	9740	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	240	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
126	199	------> echo (string replace -r '^refs/heads/' '' $branch)
73	73	-------> string replace -r '^refs/heads/' '' $branch
49	49	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11313	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
96	11308	---> [ (_is_repo_dirty $repo_type) ]
43	11212	----> _is_repo_dirty $repo_type
38	11169	-----> _is_$argv[1]_dirty
169	11131	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10962	10962	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
70	2365	> fish_right_prompt
155	155	-> set_color $fish_color_autosuggestion 2> /dev/null
2068	2068	-> date "+%H:%M:%S"
72	72	-> set_color normal
41	378	> fish_title
9	337	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
35	35	--> not set -q INSIDE_EMACS
176	293	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
47	84	---> __fish_pwd
37	37	----> pwd
66	143	> __fish_disable_bracketed_paste 'ls -l'
77	77	-> printf "\e[?2004l"
67	629	> fish_title ls\ -l
16	562	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
47	47	--> not set -q INSIDE_EMACS
306	499	--> echo (status current-command) (__fish_pwd)
47	47	---> status current-command
85	146	---> __fish_pwd
61	61	----> pwd
133	12766	> ls -l
150	6682	-> isatty stdout
53	53	--> set -l options 'h/help'
61	61	--> argparse -n isatty $options -- $argv
9	74	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
65	65	---> set -q _flag_help
7	47	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
40	40	---> set -q argv[2]
43	43	--> set -l fd
24	265	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
241	241	---> set fd 1
5989	5989	--> command [ -t "$fd" ]
61	61	-> set -a opt -F
5890	5890	-> command ls $opt $argv
45	120	> __fish_enable_bracketed_paste
75	75	-> printf "\e[?2004h"
54	221	> fish_mode_prompt
85	167	-> fish_default_mode_prompt
7	82	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
43	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
120	43597	> fish_prompt
42	42	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
211	301	-> set -l cyan (set_color -o cyan)
90	90	--> set_color -o cyan
226	290	-> set -l yellow (set_color -o yellow)
64	64	--> set_color -o yellow
170	237	-> set -l red (set_color -o red)
67	67	--> set_color -o red
231	296	-> set -l green (set_color -o green)
65	65	--> set_color -o green
205	289	-> set -l blue (set_color -o blue)
84	84	--> set_color -o blue
205	307	-> set -l normal (set_color normal)
102	102	--> set_color normal
35	35	-> set -l arrow_color "$green"
4	32	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
28	28	--> test $__last_command_exit_status != 0
51	51	-> set -l arrow "$arrow_color➜ "
4	50	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
46	46	--> test "$USER" = 'root'
218	2932	-> set -l cwd $cyan(basename (prompt_pwd))
2063	2714	--> basename (prompt_pwd)
118	651	---> prompt_pwd
52	52	----> set -l options 'h/help'
38	38	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	28	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
24	24	-----> set -q _flag_help
23	23	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
31	31	----> set realhome ~
165	242	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
77	77	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	93	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
29	29	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
56	56	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
21	38519	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
133	15540	--> set -l repo_type (_repo_type)
43	15407	---> _repo_type
21	15364	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
32	304	-----> _is_hg_repo
72	272	------> fish_print_hg_root >/dev/null
9	200	-------> if not command -sq hg
        return 1
    ...
164	164	--------> not command -sq hg
27	27	--------> return 1
46	14858	-----> _is_git_repo
96	2052	------> type -q git
26	26	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
64	64	-------> argparse -n type -x t,p,P $options -- $argv
70	111	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
41	41	--------> set -q _flag_help
61	61	-------> set -l res 1
47	47	-------> set -l mode normal
30	30	-------> set -l multi no
41	41	-------> set -l selection all
25	25	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
25	25	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
35	1345	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
16	487	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
28	28	---------> test $selection != files
3	51	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
48	48	----------> functions -q -- $i
5	392	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
316	387	----------> contains -- $i (builtin -n)
71	71	-----------> builtin -n
37	37	--------> set -l paths
10	425	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
243	385	---------> set paths (command -s -- $i)
142	142	----------> command -s -- $i
39	236	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
50	50	---------> set res 0
44	44	---------> set found 1
14	14	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
12	89	---------> if test $multi != yes
                continue
            ...
43	43	----------> test $multi != yes
34	34	----------> continue
7	97	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
90	90	---------> test $found = 0
33	33	-------> return $res
12760	12760	------> git rev-parse --git-dir >/dev/null 2>&1
127	127	-----> echo 'git'
54	54	-----> return 0
107	11347	--> set -l repo_branch $red(_repo_branch_name $repo_type)
44	11240	---> _repo_branch_name $repo_type
40	11196	----> _$argv[1]_branch_name
170	10838	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10668	10668	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	318	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
100	100	------> set -q branch[1]
130	206	------> echo (string replace -r '^refs/heads/' '' $branch)
76	76	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11568	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
95	11563	---> [ (_is_repo_dirty $repo_type) ]
39	11468	----> _is_repo_dirty $repo_type
34	11429	-----> _is_$argv[1]_dirty
148	11395	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11247	11247	-------> git status -s --ignore-submodules=dirty 2>/dev/null
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
104	2060	> fish_right_prompt
94	94	-> set_color $fish_color_autosuggestion 2> /dev/null
1783	1783	-> date "+%H:%M:%S"
79	79	-> set_color normal
40	350	> fish_title
9	310	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
162	271	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
41	78	---> __fish_pwd
37	37	----> pwd
112	455	> __fish_disable_bracketed_paste ls
343	343	-> printf "\e[?2004l"
119	1209	> fish_title ls
13	1090	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
37	37	--> not set -q INSIDE_EMACS
597	1040	--> echo (status current-command) (__fish_pwd)
96	96	---> status current-command
206	347	---> __fish_pwd
141	141	----> pwd
283	6436	> ls
314	3454	-> isatty stdout
63	63	--> set -l options 'h/help'
49	49	--> argparse -n isatty $options -- $argv
7	52	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
45	45	---> set -q _flag_help
6	33	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
27	27	---> set -q argv[2]
26	26	--> set -l fd
16	43	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
27	27	---> set fd 1
2874	2874	--> command [ -t "$fd" ]
52	52	-> set -a opt -F
2647	2647	-> command ls $opt $argv
39	109	> __fish_enable_bracketed_paste
70	70	-> printf "\e[?2004h"
44	292	> fish_mode_prompt
164	248	-> fish_default_mode_prompt
8	84	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
44	44	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
158	38982	> fish_prompt
59	59	-> set -l __last_command_exit_status $status
6	50	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
44	44	--> not set -q -g __fish_robbyrussell_functions_defined
141	445	-> set -l cyan (set_color -o cyan)
304	304	--> set_color -o cyan
103	156	-> set -l yellow (set_color -o yellow)
53	53	--> set_color -o yellow
90	135	-> set -l red (set_color -o red)
45	45	--> set_color -o red
89	133	-> set -l green (set_color -o green)
44	44	--> set_color -o green
87	131	-> set -l blue (set_color -o blue)
44	44	--> set_color -o blue
88	133	-> set -l normal (set_color normal)
45	45	--> set_color normal
33	33	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
36	36	-> set -l arrow "$arrow_color➜ "
3	37	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
34	34	--> test "$USER" = 'root'
135	2552	-> set -l cwd $cyan(basename (prompt_pwd))
1592	2417	--> basename (prompt_pwd)
188	825	---> prompt_pwd
38	38	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
28	28	----> set -l fish_prompt_pwd_dir_length 1
35	35	----> set realhome ~
121	335	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
214	214	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	107	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
61	61	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
27	34701	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
122	13319	--> set -l repo_type (_repo_type)
36	13197	---> _repo_type
14	13161	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	404	-----> _is_hg_repo
215	378	------> fish_print_hg_root >/dev/null
9	163	-------> if not command -sq hg
        return 1
    ...
126	126	--------> not command -sq hg
28	28	--------> return 1
44	12647	-----> _is_git_repo
200	1899	------> type -q git
28	28	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
74	74	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
7	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
26	26	--------> set mode quiet
23	23	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
33	1237	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
34	34	--------> set -l found 0
18	701	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	278	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
274	274	----------> functions -q -- $i
6	375	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
310	369	----------> contains -- $i (builtin -n)
59	59	-----------> builtin -n
34	34	--------> set -l paths
9	259	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
31	31	---------> test $multi != yes
101	219	---------> set paths (command -s -- $i)
118	118	----------> command -s -- $i
22	146	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	58	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
22	22	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
10704	10704	------> git rev-parse --git-dir >/dev/null 2>&1
70	70	-----> echo 'git'
26	26	-----> return 0
105	9925	--> set -l repo_branch $red(_repo_branch_name $repo_type)
44	9820	---> _repo_branch_name $repo_type
41	9776	----> _$argv[1]_branch_name
136	9511	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9375	9375	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	224	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
114	182	------> echo (string replace -r '^refs/heads/' '' $branch)
68	68	-------> string replace -r '^refs/heads/' '' $branch
44	44	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
8	11386	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
117	11378	---> [ (_is_repo_dirty $repo_type) ]
38	11261	----> _is_repo_dirty $repo_type
35	11223	-----> _is_$argv[1]_dirty
169	11188	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11019	11019	-------> git status -s --ignore-submodules=dirty 2>/dev/null
189	189	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
91	2193	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
1920	1920	-> date "+%H:%M:%S"
91	91	-> set_color normal
46	381	> fish_title
9	335	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
178	294	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
44	82	---> __fish_pwd
38	38	----> pwd
232	300	> __fish_complete_cd
40	40	-> set -q CDPATH[1]
28	28	-> return 0
101	216	> __fish_disable_bracketed_paste 'cd ~/.config/'
115	115	-> printf "\e[?2004l"
98	707	> fish_title cd\ ~/.config/
16	609	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
68	68	--> not set -q INSIDE_EMACS
312	525	--> echo (status current-command) (__fish_pwd)
77	77	---> status current-command
82	136	---> __fish_pwd
54	54	----> pwd
109	1609	> cd ~/.config/
42	42	-> set -l MAX_DIR_HIST 25
10	698	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
199	688	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
378	378	---> count $argv
60	60	---> test "$argv[1]" = "--"
51	51	---> echo 1
8	43	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
35	35	--> status --is-command-substitution
47	47	-> set -l previous $PWD
7	48	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
41	41	--> test "$argv" = "-"
6	44	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
38	38	--> test "$argv" = "."
105	105	-> builtin cd $argv
48	48	-> set -l cd_status $status
49	386	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
53	53	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
35	35	--> set -q dirprev
39	39	--> set -q dirprev[$MAX_DIR_HIST]
31	31	--> set -U -q dirprev
47	47	--> set -g -a dirprev $previous
32	32	--> set -U -q dirnext
31	31	--> set -e dirnext
30	30	--> set -U -q __fish_cd_direction
39	39	--> set -g __fish_cd_direction prev
39	39	-> return $cd_status
53	128	> __fish_enable_bracketed_paste
75	75	-> printf "\e[?2004h"
54	203	> fish_mode_prompt
45	149	-> fish_default_mode_prompt
10	104	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
47	47	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
47	47	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
151	18933	> fish_prompt
112	112	-> set -l __last_command_exit_status $status
9	69	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
60	60	--> not set -q -g __fish_robbyrussell_functions_defined
215	317	-> set -l cyan (set_color -o cyan)
102	102	--> set_color -o cyan
168	241	-> set -l yellow (set_color -o yellow)
73	73	--> set_color -o yellow
190	285	-> set -l red (set_color -o red)
95	95	--> set_color -o red
175	264	-> set -l green (set_color -o green)
89	89	--> set_color -o green
196	261	-> set -l blue (set_color -o blue)
65	65	--> set_color -o blue
152	272	-> set -l normal (set_color normal)
120	120	--> set_color normal
50	50	-> set -l arrow_color "$green"
7	48	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
41	41	--> test $__last_command_exit_status != 0
71	71	-> set -l arrow "$arrow_color➜ "
5	51	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
46	46	--> test "$USER" = 'root'
244	3048	-> set -l cwd $cyan(basename (prompt_pwd))
2153	2804	--> basename (prompt_pwd)
88	651	---> prompt_pwd
42	42	----> set -l options 'h/help'
45	45	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	34	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
30	30	-----> set -q _flag_help
33	33	----> set -q fish_prompt_pwd_dir_length
31	31	----> set -l fish_prompt_pwd_dir_length 1
37	37	----> set realhome ~
131	231	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
100	100	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	110	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
37	37	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
64	64	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
4	13627	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
178	13623	--> set -l repo_type (_repo_type)
68	13445	---> _repo_type
10	13329	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
51	497	-----> _is_hg_repo
129	446	------> fish_print_hg_root >/dev/null
18	317	-------> if not command -sq hg
        return 1
    ...
248	248	--------> not command -sq hg
51	51	--------> return 1
66	12822	-----> _is_git_repo
200	2841	------> type -q git
53	53	-------> set -q argv[1]
102	102	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
127	127	-------> argparse -n type -x t,p,P $options -- $argv
8	59	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
51	51	--------> set -q _flag_help
52	52	-------> set -l res 1
51	51	-------> set -l mode normal
55	55	-------> set -l multi no
56	56	-------> set -l selection all
57	57	-------> set -l short no
20	160	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
64	64	--------> set -q _flag_quiet
76	76	--------> set mode quiet
54	54	-------> set -q _flag_all
42	42	-------> set -q _flag_short
40	40	-------> set -q _flag_no_functions
50	1705	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
48	48	--------> set -l found 0
24	772	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
49	49	---------> test $selection != files
20	174	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
154	154	----------> functions -q -- $i
7	525	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
394	518	----------> contains -- $i (builtin -n)
124	124	-----------> builtin -n
72	72	--------> set -l paths
13	573	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
42	42	---------> test $multi != yes
195	518	---------> set paths (command -s -- $i)
323	323	----------> command -s -- $i
28	159	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
33	33	---------> set res 0
27	27	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	60	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
23	23	----------> continue
5	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
28	28	-------> return $res
9915	9915	------> git rev-parse --git-dir >/dev/null 2>&1
48	48	----> return 1
66	66	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
60	1879	> fish_right_prompt
84	84	-> set_color $fish_color_autosuggestion 2> /dev/null
1674	1674	-> date "+%H:%M:%S"
61	61	-> set_color normal
40	361	> fish_title
9	321	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
170	282	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
43	80	---> __fish_pwd
37	37	----> pwd
58	122	> __fish_disable_bracketed_paste ls
64	64	-> printf "\e[?2004l"
45	411	> fish_title ls
11	366	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
191	322	--> echo (status current-command) (__fish_pwd)
37	37	---> status current-command
49	94	---> __fish_pwd
45	45	----> pwd
174	13728	> ls
187	4097	-> isatty stdout
85	85	--> set -l options 'h/help'
84	84	--> argparse -n isatty $options -- $argv
28	81	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
53	53	---> set -q _flag_help
9	77	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
68	68	---> set -q argv[2]
42	42	--> set -l fd
21	52	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
31	31	---> set fd 1
3489	3489	--> command [ -t "$fd" ]
79	79	-> set -a opt -F
9378	9378	-> command ls $opt $argv
42	101	> __fish_enable_bracketed_paste
59	59	-> printf "\e[?2004h"
41	168	> fish_mode_prompt
45	127	-> fish_default_mode_prompt
9	82	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
41	41	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
93	14927	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
95	152	-> set -l cyan (set_color -o cyan)
57	57	--> set_color -o cyan
90	136	-> set -l yellow (set_color -o yellow)
46	46	--> set_color -o yellow
87	131	-> set -l red (set_color -o red)
44	44	--> set_color -o red
86	132	-> set -l green (set_color -o green)
46	46	--> set_color -o green
84	127	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
88	130	-> set -l normal (set_color normal)
42	42	--> set_color normal
34	34	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
32	32	-> set -l arrow "$arrow_color➜ "
3	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
120	2037	-> set -l cwd $cyan(basename (prompt_pwd))
1381	1917	--> basename (prompt_pwd)
75	536	---> prompt_pwd
36	36	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
97	171	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
74	74	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
11	102	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
58	58	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	11722	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
115	11717	--> set -l repo_type (_repo_type)
55	11602	---> _repo_type
8	11499	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
43	295	-----> _is_hg_repo
77	252	------> fish_print_hg_root >/dev/null
9	175	-------> if not command -sq hg
        return 1
    ...
138	138	--------> not command -sq hg
28	28	--------> return 1
42	11196	-----> _is_git_repo
95	1436	------> type -q git
26	26	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
69	69	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
8	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
39	887	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
16	329	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	54	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
50	50	----------> functions -q -- $i
4	229	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
173	225	----------> contains -- $i (builtin -n)
52	52	-----------> builtin -n
30	30	--------> set -l paths
11	267	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
114	227	---------> set paths (command -s -- $i)
113	113	----------> command -s -- $i
29	159	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
33	33	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	60	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
22	22	----------> continue
5	32	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
9718	9718	------> git rev-parse --git-dir >/dev/null 2>&1
48	48	----> return 1
65	65	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
67	1901	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
1678	1678	-> date "+%H:%M:%S"
68	68	-> set_color normal
42	357	> fish_title
9	315	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
164	275	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
42	79	---> __fish_pwd
37	37	----> pwd
342	8262	> __fish_cancel_commandline
167	167	-> commandline -f cancel
138	182	-> set -l cmd (commandline)
44	44	--> commandline
44	7496	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
47	47	--> test -n "$cmd"
63	63	--> commandline -C 1000000
12	378	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
31	31	---> set -q fish_color_cancel
218	335	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
64	64	----> set_color $fish_color_cancel
53	53	----> set_color normal
34	3465	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
204	204	---> command -sq tput
241	3227	---> echo -n (tput el; or tput ce)
2986	2986	----> tput el
165	3181	--> for i in (seq (commandline -L))
            echo ""
        ...
2624	2682	---> seq (commandline -L)
58	58	----> commandline -L
334	334	---> echo ""
77	77	--> commandline ""
241	241	--> emit fish_cancel
75	75	-> commandline -f repaint
70	259	> fish_mode_prompt
61	189	-> fish_default_mode_prompt
10	128	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
78	78	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
40	40	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
142	17825	> fish_prompt
48	48	-> set -l __last_command_exit_status $status
4	34	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
30	30	--> not set -q -g __fish_robbyrussell_functions_defined
187	251	-> set -l cyan (set_color -o cyan)
64	64	--> set_color -o cyan
171	248	-> set -l yellow (set_color -o yellow)
77	77	--> set_color -o yellow
163	217	-> set -l red (set_color -o red)
54	54	--> set_color -o red
140	203	-> set -l green (set_color -o green)
63	63	--> set_color -o green
120	177	-> set -l blue (set_color -o blue)
57	57	--> set_color -o blue
182	291	-> set -l normal (set_color normal)
109	109	--> set_color normal
62	62	-> set -l arrow_color "$green"
7	53	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
46	46	--> test $__last_command_exit_status != 0
60	60	-> set -l arrow "$arrow_color➜ "
6	58	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
52	52	--> test "$USER" = 'root'
225	3403	-> set -l cwd $cyan(basename (prompt_pwd))
2090	3178	--> basename (prompt_pwd)
131	1088	---> prompt_pwd
64	64	----> set -l options 'h/help'
65	65	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
7	52	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
45	45	-----> set -q _flag_help
42	42	----> set -q fish_prompt_pwd_dir_length
48	48	----> set -l fish_prompt_pwd_dir_length 1
57	57	----> set realhome ~
303	426	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
123	123	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
14	203	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
48	48	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
141	141	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
5	12512	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
114	12507	--> set -l repo_type (_repo_type)
38	12393	---> _repo_type
8	12303	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
29	316	-----> _is_hg_repo
76	287	------> fish_print_hg_root >/dev/null
10	211	-------> if not command -sq hg
        return 1
    ...
164	164	--------> not command -sq hg
37	37	--------> return 1
49	11979	-----> _is_git_repo
103	1982	------> type -q git
29	29	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
73	73	-------> argparse -n type -x t,p,P $options -- $argv
3	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
94	94	-------> set -l res 1
38	38	-------> set -l mode normal
28	28	-------> set -l multi no
27	27	-------> set -l selection all
27	27	-------> set -l short no
9	59	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
26	26	--------> set mode quiet
26	26	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
46	1326	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
30	30	--------> set -l found 0
16	380	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
4	50	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
46	46	----------> functions -q -- $i
5	282	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
220	277	----------> contains -- $i (builtin -n)
57	57	-----------> builtin -n
45	45	--------> set -l paths
16	382	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
54	54	---------> test $multi != yes
163	312	---------> set paths (command -s -- $i)
149	149	----------> command -s -- $i
34	406	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
45	45	---------> set res 0
75	75	---------> set found 1
12	12	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
81	240	---------> if test $multi != yes
                continue
            ...
120	120	----------> test $multi != yes
39	39	----------> continue
4	37	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
33	33	---------> test $found = 0
31	31	-------> return $res
9948	9948	------> git rev-parse --git-dir >/dev/null 2>&1
52	52	----> return 1
66	66	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
67	1885	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
1661	1661	-> date "+%H:%M:%S"
69	69	-> set_color normal
48	373	> fish_title
9	325	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
163	284	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
48	88	---> __fish_pwd
40	40	----> pwd
49	111	> __fish_disable_bracketed_paste clear
62	62	-> printf "\e[?2004l"
63	458	> fish_title clear
29	395	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
37	37	--> not set -q INSIDE_EMACS
195	329	--> echo (status current-command) (__fish_pwd)
43	43	---> status current-command
51	91	---> __fish_pwd
40	40	----> pwd
3334	3334	> clear
49	113	> __fish_enable_bracketed_paste
64	64	-> printf "\e[?2004h"
52	362	> fish_mode_prompt
65	310	-> fish_default_mode_prompt
17	245	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
160	160	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
68	68	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
166	18691	> fish_prompt
51	51	-> set -l __last_command_exit_status $status
5	37	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
32	32	--> not set -q -g __fish_robbyrussell_functions_defined
191	332	-> set -l cyan (set_color -o cyan)
141	141	--> set_color -o cyan
170	261	-> set -l yellow (set_color -o yellow)
91	91	--> set_color -o yellow
154	227	-> set -l red (set_color -o red)
73	73	--> set_color -o red
144	232	-> set -l green (set_color -o green)
88	88	--> set_color -o green
163	214	-> set -l blue (set_color -o blue)
51	51	--> set_color -o blue
153	228	-> set -l normal (set_color normal)
75	75	--> set_color normal
62	62	-> set -l arrow_color "$green"
5	58	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
53	53	--> test $__last_command_exit_status != 0
54	54	-> set -l arrow "$arrow_color➜ "
6	64	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
58	58	--> test "$USER" = 'root'
186	2697	-> set -l cwd $cyan(basename (prompt_pwd))
1712	2511	--> basename (prompt_pwd)
103	799	---> prompt_pwd
68	68	----> set -l options 'h/help'
45	45	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
5	32	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
27	27	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
28	28	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
204	292	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
88	88	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	171	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
81	81	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
78	78	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
6	13929	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
170	13923	--> set -l repo_type (_repo_type)
61	13753	---> _repo_type
7	13599	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
32	457	-----> _is_hg_repo
85	425	------> fish_print_hg_root >/dev/null
32	340	-------> if not command -sq hg
        return 1
    ...
230	230	--------> not command -sq hg
78	78	--------> return 1
53	13135	-----> _is_git_repo
227	1880	------> type -q git
49	49	-------> set -q argv[1]
70	70	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
83	83	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
63	63	-------> set -l res 1
40	40	-------> set -l mode normal
127	127	-------> set -l multi no
114	114	-------> set -l selection all
36	36	-------> set -l short no
9	59	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
26	26	--------> set mode quiet
26	26	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
33	883	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
15	351	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
3	58	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
55	55	----------> functions -q -- $i
4	248	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
189	244	----------> contains -- $i (builtin -n)
55	55	-----------> builtin -n
30	30	--------> set -l paths
8	274	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
109	237	---------> set paths (command -s -- $i)
128	128	----------> command -s -- $i
21	138	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
27	27	---------> set res 0
25	25	---------> set found 1
9	9	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	56	---------> if test $multi != yes
                continue
            ...
27	27	----------> test $multi != yes
22	22	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
27	27	-------> return $res
11202	11202	------> git rev-parse --git-dir >/dev/null 2>&1
93	93	----> return 1
79	79	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
92	2286	> fish_right_prompt
116	116	-> set_color $fish_color_autosuggestion 2> /dev/null
2017	2017	-> date "+%H:%M:%S"
61	61	-> set_color normal
40	452	> fish_title
9	412	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
212	374	--> echo (status current-command) (__fish_pwd)
50	50	---> status current-command
54	112	---> __fish_pwd
58	58	----> pwd
55	381	> __fish_disable_bracketed_paste 'cd ..'
326	326	-> printf "\e[?2004l"
71	1218	> fish_title cd\ ..
15	1147	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
38	38	--> not set -q INSIDE_EMACS
496	1094	--> echo (status current-command) (__fish_pwd)
46	46	---> status current-command
295	552	---> __fish_pwd
257	257	----> pwd
342	1654	> cd ..
54	54	-> set -l MAX_DIR_HIST 25
9	388	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
189	379	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
93	93	---> count $argv
51	51	---> test "$argv[1]" = "--"
46	46	---> echo 1
5	37	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
32	32	--> status --is-command-substitution
41	41	-> set -l previous $PWD
5	39	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
34	34	--> test "$argv" = "-"
5	36	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
31	31	--> test "$argv" = "."
104	104	-> builtin cd $argv
61	61	-> set -l cd_status $status
54	500	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
66	66	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
58	58	--> set -q dirprev
55	55	--> set -q dirprev[$MAX_DIR_HIST]
40	40	--> set -U -q dirprev
62	62	--> set -g -a dirprev $previous
38	38	--> set -U -q dirnext
38	38	--> set -e dirnext
37	37	--> set -U -q __fish_cd_direction
52	52	--> set -g __fish_cd_direction prev
52	52	-> return $cd_status
57	154	> __fish_enable_bracketed_paste
97	97	-> printf "\e[?2004h"
51	316	> fish_mode_prompt
170	265	-> fish_default_mode_prompt
10	95	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
50	50	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
35	35	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
129	17681	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
26	26	--> not set -q -g __fish_robbyrussell_functions_defined
123	328	-> set -l cyan (set_color -o cyan)
205	205	--> set_color -o cyan
125	173	-> set -l yellow (set_color -o yellow)
48	48	--> set_color -o yellow
121	175	-> set -l red (set_color -o red)
54	54	--> set_color -o red
141	188	-> set -l green (set_color -o green)
47	47	--> set_color -o green
170	242	-> set -l blue (set_color -o blue)
72	72	--> set_color -o blue
112	160	-> set -l normal (set_color normal)
48	48	--> set_color normal
37	37	-> set -l arrow_color "$green"
5	36	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
34	34	-> set -l arrow "$arrow_color➜ "
3	33	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
30	30	--> test "$USER" = 'root'
115	2515	-> set -l cwd $cyan(basename (prompt_pwd))
1586	2400	--> basename (prompt_pwd)
202	814	---> prompt_pwd
42	42	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
26	26	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
111	318	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
207	207	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	95	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
54	54	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
8	13424	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
146	13416	--> set -l repo_type (_repo_type)
43	13270	---> _repo_type
8	13136	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	393	-----> _is_hg_repo
201	367	------> fish_print_hg_root >/dev/null
9	166	-------> if not command -sq hg
        return 1
    ...
130	130	--------> not command -sq hg
27	27	--------> return 1
53	12735	-----> _is_git_repo
211	1918	------> type -q git
27	27	-------> set -q argv[1]
48	48	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
68	68	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
41	41	-------> set -l selection all
47	47	-------> set -l short no
10	65	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
27	27	--------> set -q _flag_quiet
28	28	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
34	1205	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
12	680	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	267	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
263	263	----------> functions -q -- $i
5	371	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
285	366	----------> contains -- $i (builtin -n)
81	81	-----------> builtin -n
32	32	--------> set -l paths
9	256	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
103	218	---------> set paths (command -s -- $i)
115	115	----------> command -s -- $i
22	144	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	58	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
23	23	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
10764	10764	------> git rev-parse --git-dir >/dev/null 2>&1
91	91	----> return 1
141	141	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
71	2646	> fish_right_prompt
102	102	-> set_color $fish_color_autosuggestion 2> /dev/null
2401	2401	-> date "+%H:%M:%S"
72	72	-> set_color normal
47	403	> fish_title
10	356	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
200	316	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
42	82	---> __fish_pwd
40	40	----> pwd
48	106	> __fish_disable_bracketed_paste ls
58	58	-> printf "\e[?2004l"
44	478	> fish_title ls
11	434	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
237	390	--> echo (status current-command) (__fish_pwd)
37	37	---> status current-command
70	116	---> __fish_pwd
46	46	----> pwd
432	10251	> ls
331	3805	-> isatty stdout
43	43	--> set -l options 'h/help'
74	74	--> argparse -n isatty $options -- $argv
8	44	--> if set -q _flag_help
        __fish_print_help isatty
        return 0
    ...
36	36	---> set -q _flag_help
8	64	--> if set -q argv[2]
        printf (_ "%s: Too many arguments") isatty >&2
        return 1
    ...
56	56	---> set -q argv[2]
33	33	--> set -l fd
19	49	--> switch "$argv"
        case stdin ''
            set fd 0
        case stdout
            set fd 1
        case stderr
            set fd 2
        case '*'
            set fd $argv[1]
    ...
30	30	---> set fd 1
3167	3167	--> command [ -t "$fd" ]
58	58	-> set -a opt -F
5956	5956	-> command ls $opt $argv
42	97	> __fish_enable_bracketed_paste
55	55	-> printf "\e[?2004h"
48	176	> fish_mode_prompt
45	128	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
43	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
208	16260	> fish_prompt
46	46	-> set -l __last_command_exit_status $status
4	34	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
30	30	--> not set -q -g __fish_robbyrussell_functions_defined
108	171	-> set -l cyan (set_color -o cyan)
63	63	--> set_color -o cyan
96	142	-> set -l yellow (set_color -o yellow)
46	46	--> set_color -o yellow
93	140	-> set -l red (set_color -o red)
47	47	--> set_color -o red
98	181	-> set -l green (set_color -o green)
83	83	--> set_color -o green
99	153	-> set -l blue (set_color -o blue)
54	54	--> set_color -o blue
95	138	-> set -l normal (set_color normal)
43	43	--> set_color normal
35	35	-> set -l arrow_color "$green"
3	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
34	34	-> set -l arrow "$arrow_color➜ "
18	52	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
34	34	--> test "$USER" = 'root'
116	2230	-> set -l cwd $cyan(basename (prompt_pwd))
1599	2114	--> basename (prompt_pwd)
68	515	---> prompt_pwd
34	34	----> set -l options 'h/help'
38	38	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
23	23	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
96	168	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
72	72	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	96	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
55	55	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
6	12512	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
193	12506	--> set -l repo_type (_repo_type)
41	12313	---> _repo_type
7	12221	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	270	-----> _is_hg_repo
72	244	------> fish_print_hg_root >/dev/null
8	172	-------> if not command -sq hg
        return 1
    ...
136	136	--------> not command -sq hg
28	28	--------> return 1
79	11944	-----> _is_git_repo
100	1408	------> type -q git
27	27	-------> set -q argv[1]
44	44	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
68	68	-------> argparse -n type -x t,p,P $options -- $argv
3	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
7	55	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
37	37	-------> set -q _flag_all
25	25	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
33	842	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
14	335	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
34	34	---------> test $selection != files
5	63	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
58	58	----------> functions -q -- $i
4	224	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
169	220	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
30	30	--------> set -l paths
8	246	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
92	209	---------> set paths (command -s -- $i)
117	117	----------> command -s -- $i
22	141	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
27	27	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	56	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
22	22	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
10457	10457	------> git rev-parse --git-dir >/dev/null 2>&1
51	51	----> return 1
150	150	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
115	2773	> fish_right_prompt
132	132	-> set_color $fish_color_autosuggestion 2> /dev/null
2457	2457	-> date "+%H:%M:%S"
69	69	-> set_color normal
43	541	> fish_title
29	498	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
283	440	--> echo (status current-command) (__fish_pwd)
63	63	---> status current-command
53	94	---> __fish_pwd
41	41	----> pwd
92	163	> __fish_complete_cd
42	42	-> set -q CDPATH[1]
29	29	-> return 0
73	174	> __fish_disable_bracketed_paste 'cd dotfiles/'
101	101	-> printf "\e[?2004l"
64	432	> fish_title cd\ dotfiles/
9	368	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
36	36	--> not set -q INSIDE_EMACS
190	323	--> echo (status current-command) (__fish_pwd)
40	40	---> status current-command
48	93	---> __fish_pwd
45	45	----> pwd
129	1481	> cd dotfiles/
52	52	-> set -l MAX_DIR_HIST 25
13	382	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
215	369	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
64	64	---> count $argv
49	49	---> test "$argv[1]" = "--"
41	41	---> echo 1
6	41	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
35	35	--> status --is-command-substitution
40	40	-> set -l previous $PWD
6	43	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
37	37	--> test "$argv" = "-"
4	38	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
34	34	--> test "$argv" = "."
97	97	-> builtin cd $argv
99	99	-> set -l cd_status $status
73	526	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
65	65	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
45	45	--> set -q dirprev
41	41	--> set -q dirprev[$MAX_DIR_HIST]
55	55	--> set -U -q dirprev
70	70	--> set -g -a dirprev $previous
59	59	--> set -U -q dirnext
51	51	--> set -e dirnext
33	33	--> set -U -q __fish_cd_direction
34	34	--> set -g __fish_cd_direction prev
34	34	-> return $cd_status
53	108	> __fish_enable_bracketed_paste
55	55	-> printf "\e[?2004h"
84	285	> fish_mode_prompt
82	201	-> fish_default_mode_prompt
8	119	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
78	78	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
101	39414	> fish_prompt
53	53	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
102	151	-> set -l cyan (set_color -o cyan)
49	49	--> set_color -o cyan
87	130	-> set -l yellow (set_color -o yellow)
43	43	--> set_color -o yellow
155	224	-> set -l red (set_color -o red)
69	69	--> set_color -o red
181	327	-> set -l green (set_color -o green)
146	146	--> set_color -o green
127	207	-> set -l blue (set_color -o blue)
80	80	--> set_color -o blue
279	326	-> set -l normal (set_color normal)
47	47	--> set_color normal
40	40	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
34	34	-> set -l arrow "$arrow_color➜ "
4	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
208	2559	-> set -l cwd $cyan(basename (prompt_pwd))
1832	2351	--> basename (prompt_pwd)
64	519	---> prompt_pwd
33	33	----> set -l options 'h/help'
46	46	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
98	165	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
67	67	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	98	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
56	56	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
16	35094	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
128	12521	--> set -l repo_type (_repo_type)
35	12393	---> _repo_type
18	12358	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
31	312	-----> _is_hg_repo
105	281	------> fish_print_hg_root >/dev/null
9	176	-------> if not command -sq hg
        return 1
    ...
139	139	--------> not command -sq hg
28	28	--------> return 1
57	11929	-----> _is_git_repo
94	1633	------> type -q git
26	26	-------> set -q argv[1]
45	45	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
63	63	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
26	26	-------> set -l short no
7	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
25	25	--------> set mode quiet
66	66	-------> set -q _flag_all
30	30	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
36	1039	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
23	389	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	58	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
54	54	----------> functions -q -- $i
8	278	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
219	270	----------> contains -- $i (builtin -n)
51	51	-----------> builtin -n
42	42	--------> set -l paths
9	261	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
32	32	---------> test $multi != yes
100	220	---------> set paths (command -s -- $i)
120	120	----------> command -s -- $i
22	248	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
36	161	---------> if test $multi != yes
                continue
            ...
92	92	----------> test $multi != yes
33	33	----------> continue
4	35	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
31	31	---------> test $found = 0
29	29	-------> return $res
10239	10239	------> git rev-parse --git-dir >/dev/null 2>&1
73	73	-----> echo 'git'
26	26	-----> return 0
110	10470	--> set -l repo_branch $red(_repo_branch_name $repo_type)
44	10360	---> _repo_branch_name $repo_type
38	10316	----> _$argv[1]_branch_name
155	10042	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9887	9887	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	236	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
33	33	------> set -q branch[1]
123	194	------> echo (string replace -r '^refs/heads/' '' $branch)
71	71	-------> string replace -r '^refs/heads/' '' $branch
44	44	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
4	12043	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
94	12039	---> [ (_is_repo_dirty $repo_type) ]
39	11945	----> _is_repo_dirty $repo_type
35	11906	-----> _is_$argv[1]_dirty
155	11871	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11716	11716	-------> git status -s --ignore-submodules=dirty 2>/dev/null
66	66	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
62	1934	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
1724	1724	-> date "+%H:%M:%S"
60	60	-> set_color normal
39	343	> fish_title
10	304	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
155	264	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
41	77	---> __fish_pwd
36	36	----> pwd
63	182	> __fish_disable_bracketed_paste 'cd nvim'
119	119	-> printf "\e[?2004l"
51	366	> fish_title cd\ nvim
9	315	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
163	276	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
43	80	---> __fish_pwd
37	37	----> pwd
72	1042	> cd nvim
31	31	-> set -l MAX_DIR_HIST 25
5	378	-> if test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
        printf "%s\n" (_ "Too many args for cd command")
        return 1
    ...
116	373	--> test (count $argv) -gt (test "$argv[1]" = "--" && echo 2 || echo 1)
183	183	---> count $argv
38	38	---> test "$argv[1]" = "--"
36	36	---> echo 1
5	31	-> if status --is-command-substitution
        builtin cd $argv
        return $status
    ...
26	26	--> status --is-command-substitution
35	35	-> set -l previous $PWD
5	34	-> if test "$argv" = "-"
        if test "$__fish_cd_direction" = "next"
            nextd
        else
            prevd
        end
        return $status
    ...
29	29	--> test "$argv" = "-"
3	31	-> if test "$argv" = "."
        cd "$PWD"
        return $status
    ...
28	28	--> test "$argv" = "."
73	73	-> builtin cd $argv
35	35	-> set -l cd_status $status
33	293	-> if test $cd_status -eq 0 -a "$PWD" != "$previous"
        set -q dirprev
        or set -l dirprev
        set -q dirprev[$MAX_DIR_HIST]
        and set -e dirprev[1]

        # If dirprev, dirnext, __fish_cd_direction
        # are set as universal variables, honor their scope.

        set -U -q dirprev
        and set -U -a dirprev $previous
        or set -g -a dirprev $previous

        set -U -q dirnext
        and set -U -e dirnext
        or set -e dirnext

        set -U -q __fish_cd_direction
        and set -U __fish_cd_direction prev
        or set -g __fish_cd_direction prev
    ...
41	41	--> test $cd_status -eq 0 -a "$PWD" != "$previous"
25	25	--> set -q dirprev
31	31	--> set -q dirprev[$MAX_DIR_HIST]
24	24	--> set -U -q dirprev
36	36	--> set -g -a dirprev $previous
28	28	--> set -U -q dirnext
24	24	--> set -e dirnext
24	24	--> set -U -q __fish_cd_direction
27	27	--> set -g __fish_cd_direction prev
29	29	-> return $cd_status
27	67	> __fish_enable_bracketed_paste
40	40	-> printf "\e[?2004h"
35	170	> fish_mode_prompt
37	135	-> fish_default_mode_prompt
20	98	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
44	44	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
34	34	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
91	41640	> fish_prompt
34	34	-> set -l __last_command_exit_status $status
4	29	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
25	25	--> not set -q -g __fish_robbyrussell_functions_defined
97	144	-> set -l cyan (set_color -o cyan)
47	47	--> set_color -o cyan
91	135	-> set -l yellow (set_color -o yellow)
44	44	--> set_color -o yellow
99	146	-> set -l red (set_color -o red)
47	47	--> set_color -o red
91	135	-> set -l green (set_color -o green)
44	44	--> set_color -o green
86	129	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
90	131	-> set -l normal (set_color normal)
41	41	--> set_color normal
39	39	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	32	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
29	29	--> test "$USER" = 'root'
134	2502	-> set -l cwd $cyan(basename (prompt_pwd))
1806	2368	--> basename (prompt_pwd)
80	562	---> prompt_pwd
39	39	----> set -l options 'h/help'
41	41	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
30	30	----> set -q fish_prompt_pwd_dir_length
29	29	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
107	179	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
72	72	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	100	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
58	58	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
14	37962	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
116	14205	--> set -l repo_type (_repo_type)
30	14089	---> _repo_type
16	14059	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	280	-----> _is_hg_repo
74	254	------> fish_print_hg_root >/dev/null
10	180	-------> if not command -sq hg
        return 1
    ...
142	142	--------> not command -sq hg
28	28	--------> return 1
47	13667	-----> _is_git_repo
107	1783	------> type -q git
26	26	-------> set -q argv[1]
46	46	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
136	136	-------> argparse -n type -x t,p,P $options -- $argv
7	70	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
63	63	--------> set -q _flag_help
55	55	-------> set -l res 1
29	29	-------> set -l mode normal
27	27	-------> set -l multi no
27	27	-------> set -l selection all
26	26	-------> set -l short no
8	59	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	--------> set -q _flag_quiet
26	26	--------> set mode quiet
24	24	-------> set -q _flag_all
24	24	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
41	1076	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
17	374	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
2	51	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
49	49	----------> functions -q -- $i
6	276	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
220	270	----------> contains -- $i (builtin -n)
50	50	-----------> builtin -n
33	33	--------> set -l paths
11	409	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
209	368	---------> set paths (command -s -- $i)
159	159	----------> command -s -- $i
27	158	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
31	31	---------> set res 0
28	28	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	61	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
24	24	----------> continue
4	33	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
29	29	---------> test $found = 0
29	29	-------> return $res
11837	11837	------> git rev-parse --git-dir >/dev/null 2>&1
70	70	-----> echo 'git'
26	26	-----> return 0
113	12200	--> set -l repo_branch $red(_repo_branch_name $repo_type)
41	12087	---> _repo_branch_name $repo_type
37	12046	----> _$argv[1]_branch_name
271	11664	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11393	11393	------> git symbolic-ref --quiet HEAD 2>/dev/null
29	345	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
52	52	------> set -q branch[1]
179	264	------> echo (string replace -r '^refs/heads/' '' $branch)
85	85	-------> string replace -r '^refs/heads/' '' $branch
45	45	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
6	11498	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
96	11492	---> [ (_is_repo_dirty $repo_type) ]
39	11396	----> _is_repo_dirty $repo_type
35	11357	-----> _is_$argv[1]_dirty
148	11322	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11174	11174	-------> git status -s --ignore-submodules=dirty 2>/dev/null
64	64	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
68	2272	> fish_right_prompt
91	91	-> set_color $fish_color_autosuggestion 2> /dev/null
2011	2011	-> date "+%H:%M:%S"
102	102	-> set_color normal
42	368	> fish_title
9	326	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
175	287	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
43	80	---> __fish_pwd
37	37	----> pwd
304	9083	> __fish_cancel_commandline
165	165	-> commandline -f cancel
135	184	-> set -l cmd (commandline)
49	49	--> commandline
31	8334	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
31	31	--> test -n "$cmd"
45	45	--> commandline -C 1000000
10	585	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
26	26	---> set -q fish_color_cancel
321	549	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
179	179	----> set_color $fish_color_cancel
49	49	----> set_color normal
24	4013	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
157	157	---> command -sq tput
223	3832	---> echo -n (tput el; or tput ce)
3609	3609	----> tput el
166	3318	--> for i in (seq (commandline -L))
            echo ""
        ...
2893	3071	---> seq (commandline -L)
178	178	----> commandline -L
81	81	---> echo ""
56	56	--> commandline ""
255	255	--> emit fish_cancel
96	96	-> commandline -f repaint
50	295	> fish_mode_prompt
162	245	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
42	42	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
33	33	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
107	40864	> fish_prompt
40	40	-> set -l __last_command_exit_status $status
3	32	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
96	151	-> set -l cyan (set_color -o cyan)
55	55	--> set_color -o cyan
89	133	-> set -l yellow (set_color -o yellow)
44	44	--> set_color -o yellow
90	132	-> set -l red (set_color -o red)
42	42	--> set_color -o red
84	127	-> set -l green (set_color -o green)
43	43	--> set_color -o green
84	127	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
84	125	-> set -l normal (set_color normal)
41	41	--> set_color normal
52	52	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
34	34	-> set -l arrow "$arrow_color➜ "
4	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
143	2674	-> set -l cwd $cyan(basename (prompt_pwd))
1655	2531	--> basename (prompt_pwd)
203	876	---> prompt_pwd
51	51	----> set -l options 'h/help'
42	42	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
83	83	----> set realhome ~
112	315	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
203	203	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	101	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
59	59	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
18	36989	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
149	13091	--> set -l repo_type (_repo_type)
48	12942	---> _repo_type
16	12894	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
28	573	-----> _is_hg_repo
221	545	------> fish_print_hg_root >/dev/null
13	324	-------> if not command -sq hg
        return 1
    ...
271	271	--------> not command -sq hg
40	40	--------> return 1
64	12210	-----> _is_git_repo
328	2211	------> type -q git
34	34	-------> set -q argv[1]
55	55	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
77	77	-------> argparse -n type -x t,p,P $options -- $argv
5	34	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
29	29	--------> set -q _flag_help
31	31	-------> set -l res 1
36	36	-------> set -l mode normal
42	42	-------> set -l multi no
33	33	-------> set -l selection all
27	27	-------> set -l short no
10	60	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
26	26	--------> set mode quiet
28	28	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
41	1351	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
28	28	--------> set -l found 0
18	727	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
34	34	---------> test $selection != files
4	292	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
288	288	----------> functions -q -- $i
6	383	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
315	377	----------> contains -- $i (builtin -n)
62	62	-----------> builtin -n
33	33	--------> set -l paths
12	328	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
111	286	---------> set paths (command -s -- $i)
175	175	----------> command -s -- $i
27	160	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
31	31	---------> set res 0
28	28	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	63	---------> if test $multi != yes
                continue
            ...
30	30	----------> test $multi != yes
24	24	----------> continue
4	34	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
30	30	---------> test $found = 0
29	29	-------> return $res
9935	9935	------> git rev-parse --git-dir >/dev/null 2>&1
68	68	-----> echo 'git'
27	27	-----> return 0
129	10895	--> set -l repo_branch $red(_repo_branch_name $repo_type)
44	10766	---> _repo_branch_name $repo_type
39	10722	----> _$argv[1]_branch_name
163	10373	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10210	10210	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	310	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
30	30	------> set -q branch[1]
197	270	------> echo (string replace -r '^refs/heads/' '' $branch)
73	73	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	12942	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
123	12937	---> [ (_is_repo_dirty $repo_type) ]
53	12814	----> _is_repo_dirty $repo_type
33	12761	-----> _is_$argv[1]_dirty
163	12728	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
12565	12565	-------> git status -s --ignore-submodules=dirty 2>/dev/null
66	66	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
165	2249	> fish_right_prompt
87	87	-> set_color $fish_color_autosuggestion 2> /dev/null
1936	1936	-> date "+%H:%M:%S"
61	61	-> set_color normal
42	565	> fish_title
9	523	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
157	484	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
156	295	---> __fish_pwd
139	139	----> pwd
834	7116	> source /usr/local/Cellar/fish/3.1.2/share/fish/completions/mv.fish
144	1979	-> set -l uname (uname -s)
1835	1835	--> uname -s
50	4303	-> if mv --version >/dev/null 2>/dev/null
    # --backup requires an argument, -b does not accept an argument
    complete -c mv -l backup -r -d "Backup each existing destination file" \
        -x -ka "none\t'Never make backups'
                     off\t'Never make backups'
                     numbered\t'Make numbered backups'
                     t\t'Make numbered backups'
                     existing\t'Numbered backups if any exist, else simple'
                     nil\t'Numbered backups if any exist, else simple'
                     simple\t'Make simple backups'
                     never\t'Make simple backups'"
    complete -c mv -s b -d "Backup each existing destination file"
    complete -c mv -s f -l force -d "Don't prompt to overwrite"
    complete -c mv -s i -l interactive -d "Prompt to overwrite"
    complete -c mv -s n -l no-clobber -d "Don't overwrite existing"
    # --reply has been deprecated for over a decade, and now GNU mv does not accept this option.
    # Better to use -f instead of --reply=yes.
    #   complete -c mv -l reply -x -a "yes no query" -d "Answer for overwrite questions"
    complete -c mv -l strip-trailing-slashes -d "Remove trailing '/' from source args"
    complete -c mv -s S -l suffix -x -d "Override default backup suffix"
    complete -c mv -s t -l target-directory -d "Move all source args into DIR" \
        -x -a "(__fish_complete_directories (commandline -ct) 'Directory')"
    complete -c mv -s T -l no-target-directory -d "Treat DEST as a normal file"
    complete -c mv -s u -l update -d "Don't overwrite newer"
    complete -c mv -s v -l verbose -d "Print filenames as it goes"
    test "$uname" = Linux
    and complete -c mv -s Z -l context -d "Set SELinux context to default"

    complete -c mv -l help -d "Print help and exit"
    complete -c mv -l version -d "Print version and exit"
    ## BSD-ish mv
else #[posix][ext]
    # freebsd:   mv [-fi][nvh] src dst
    # dragonfly: mv [-fi][nvh] src dst
    # macos:     mv [-fi][nv ] src dst
    # netbsd:    mv [-fi][ v ] src dst
    # openbsd:   mv [-fi][ v ] src dst
    # solaris:   mv [-fi][   ] src dst

    # POSIX options
    complete -c mv -s f -d "Don't prompt to overwrite"
    complete -c mv -s i -d "Prompt to overwrite existing"

    test uname = SunOS # -fi
    and exit 0

    # Extensions
    complete -c mv -s v -d "Print filenames as it goes"

    contains "$uname" NetBSD OpenBSD # -fiv
    and exit 0

    complete -c mv -s n -d "Don't overwrite existing"

    test "$uname" = Darwin # -fivn
    and exit 0

    complete -c mv -s h -d "Don't follow target if it links to a dir"
...
3341	3341	--> mv --version >/dev/null 2>/dev/null
207	207	--> complete -c mv -s f -d "Don't prompt to overwrite"
48	48	--> complete -c mv -s i -d "Prompt to overwrite existing"
32	32	--> test uname = SunOS
59	59	--> complete -c mv -s v -d "Print filenames as it goes"
81	81	--> contains "$uname" NetBSD OpenBSD
81	81	--> complete -c mv -s n -d "Don't overwrite existing"
38	38	--> test "$uname" = Darwin
366	366	--> exit 0
346	7903	> __fish_cancel_commandline
165	165	-> commandline -f cancel
132	178	-> set -l cmd (commandline)
46	46	--> commandline
29	7174	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
36	36	--> test -n "$cmd"
50	50	--> commandline -C 1000000
11	606	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
29	29	---> set -q fish_color_cancel
312	566	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
203	203	----> set_color $fish_color_cancel
51	51	----> set_color normal
18	3149	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
107	107	---> command -sq tput
203	3024	---> echo -n (tput el; or tput ce)
2821	2821	----> tput el
147	2980	--> for i in (seq (commandline -L))
            echo ""
        ...
2698	2758	---> seq (commandline -L)
60	60	----> commandline -L
75	75	---> echo ""
138	138	--> commandline ""
186	186	--> emit fish_cancel
40	40	-> commandline -f repaint
66	546	> fish_mode_prompt
285	480	-> fish_default_mode_prompt
31	195	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
64	64	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
100	100	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
186	39939	> fish_prompt
44	44	-> set -l __last_command_exit_status $status
9	83	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
74	74	--> not set -q -g __fish_robbyrussell_functions_defined
154	225	-> set -l cyan (set_color -o cyan)
71	71	--> set_color -o cyan
168	249	-> set -l yellow (set_color -o yellow)
81	81	--> set_color -o yellow
135	188	-> set -l red (set_color -o red)
53	53	--> set_color -o red
138	205	-> set -l green (set_color -o green)
67	67	--> set_color -o green
111	164	-> set -l blue (set_color -o blue)
53	53	--> set_color -o blue
103	152	-> set -l normal (set_color normal)
49	49	--> set_color normal
117	117	-> set -l arrow_color "$green"
6	52	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
46	46	--> test $__last_command_exit_status != 0
37	37	-> set -l arrow "$arrow_color➜ "
4	38	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
34	34	--> test "$USER" = 'root'
158	3224	-> set -l cwd $cyan(basename (prompt_pwd))
1761	3066	--> basename (prompt_pwd)
343	1305	---> prompt_pwd
66	66	----> set -l options 'h/help'
71	71	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
7	56	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
49	49	-----> set -q _flag_help
47	47	----> set -q fish_prompt_pwd_dir_length
61	61	----> set -l fish_prompt_pwd_dir_length 1
67	67	----> set realhome ~
199	486	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
287	287	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	108	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
35	35	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
64	64	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
18	34895	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
139	12947	--> set -l repo_type (_repo_type)
37	12808	---> _repo_type
16	12771	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
33	408	-----> _is_hg_repo
213	375	------> fish_print_hg_root >/dev/null
9	162	-------> if not command -sq hg
        return 1
    ...
126	126	--------> not command -sq hg
27	27	--------> return 1
43	12244	-----> _is_git_repo
220	2125	------> type -q git
69	69	-------> set -q argv[1]
73	73	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
79	79	-------> argparse -n type -x t,p,P $options -- $argv
4	33	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
29	29	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
26	26	-------> set -l selection all
33	33	-------> set -l short no
10	59	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
25	25	--------> set mode quiet
33	33	-------> set -q _flag_all
24	24	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
34	1349	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
58	58	--------> set -l found 0
25	793	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
53	53	---------> test $selection != files
6	350	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
344	344	----------> functions -q -- $i
5	365	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
301	360	----------> contains -- $i (builtin -n)
59	59	-----------> builtin -n
32	32	--------> set -l paths
9	254	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
98	215	---------> set paths (command -s -- $i)
117	117	----------> command -s -- $i
23	147	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
28	28	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	58	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
23	23	----------> continue
5	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
27	27	-------> return $res
10076	10076	------> git rev-parse --git-dir >/dev/null 2>&1
78	78	-----> echo 'git'
25	25	-----> return 0
120	10479	--> set -l repo_branch $red(_repo_branch_name $repo_type)
77	10359	---> _repo_branch_name $repo_type
45	10282	----> _$argv[1]_branch_name
152	10012	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9860	9860	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	225	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
121	184	------> echo (string replace -r '^refs/heads/' '' $branch)
63	63	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11408	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
105	11403	---> [ (_is_repo_dirty $repo_type) ]
44	11298	----> _is_repo_dirty $repo_type
53	11254	-----> _is_$argv[1]_dirty
157	11201	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11044	11044	-------> git status -s --ignore-submodules=dirty 2>/dev/null
80	80	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
244	2570	> fish_right_prompt
130	130	-> set_color $fish_color_autosuggestion 2> /dev/null
2078	2078	-> date "+%H:%M:%S"
118	118	-> set_color normal
58	662	> fish_title
12	604	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
33	33	--> not set -q INSIDE_EMACS
176	559	--> echo (status current-command) (__fish_pwd)
37	37	---> status current-command
200	346	---> __fish_pwd
146	146	----> pwd
322	677	> up-or-search
8	60	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
52	52	--> commandline --search-mode
4	42	-> if commandline --paging-mode
        commandline -f up-line
        return
    ...
38	38	--> commandline --paging-mode
149	198	-> set lineno (commandline -L)
49	49	--> commandline -L
14	55	-> switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    ...
41	41	--> commandline -f history-search-backward
116	325	> up-or-search
20	209	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
123	123	--> commandline --search-mode
43	43	--> commandline -f history-search-backward
23	23	--> return
517	1710	> down-or-search
1051	1067	-> source /usr/local/Cellar/fish/3.1.2/share/fish/functions/down-or-search.fish
16	16	--> function down-or-search -d "Depending on cursor position and current mode, either search forward or move down one line"
    # If we are already in search mode, continue
    if commandline --search-mode
        commandline -f history-search-forward
        return
    end

    # If we are navigating the pager, then up always navigates
    if commandline --paging-mode
        commandline -f down-line
        return
    end


    # We are not already in search mode.
    # If we are on the bottom line, start search mode,
    # otherwise move down
    set lineno (commandline -L)
    set line_count (count (commandline))

    switch $lineno
        case $line_count
            commandline -f history-search-forward

        case '*'
            commandline -f down-line
    end
...
15	126	-> if commandline --search-mode
        commandline -f history-search-forward
        return
    ...
46	46	--> commandline --search-mode
40	40	--> commandline -f history-search-forward
25	25	--> return
116	6969	> __fish_cancel_commandline
85	85	-> commandline -f cancel
129	179	-> set -l cmd (commandline)
50	50	--> commandline
38	6488	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
36	36	--> test -n "$cmd"
75	75	--> commandline -C 1000000
12	364	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
32	32	---> set -q fish_color_cancel
204	320	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
57	57	----> set_color $fish_color_cancel
59	59	----> set_color normal
19	3083	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
145	145	---> command -sq tput
199	2919	---> echo -n (tput el; or tput ce)
2720	2720	----> tput el
190	2795	--> for i in (seq (commandline -L))
            echo ""
        ...
2416	2526	---> seq (commandline -L)
110	110	----> commandline -L
79	79	---> echo ""
55	55	--> commandline ""
42	42	--> emit fish_cancel
101	101	-> commandline -f repaint
53	205	> fish_mode_prompt
47	152	-> fish_default_mode_prompt
11	105	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
45	45	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
49	49	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
112	43872	> fish_prompt
40	40	-> set -l __last_command_exit_status $status
4	32	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
140	197	-> set -l cyan (set_color -o cyan)
57	57	--> set_color -o cyan
122	183	-> set -l yellow (set_color -o yellow)
61	61	--> set_color -o yellow
108	159	-> set -l red (set_color -o red)
51	51	--> set_color -o red
126	192	-> set -l green (set_color -o green)
66	66	--> set_color -o green
137	192	-> set -l blue (set_color -o blue)
55	55	--> set_color -o blue
120	166	-> set -l normal (set_color normal)
46	46	--> set_color normal
37	37	-> set -l arrow_color "$green"
4	35	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
34	34	-> set -l arrow "$arrow_color➜ "
4	38	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
34	34	--> test "$USER" = 'root'
219	3119	-> set -l cwd $cyan(basename (prompt_pwd))
1887	2900	--> basename (prompt_pwd)
153	1013	---> prompt_pwd
74	74	----> set -l options 'h/help'
59	59	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	35	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
44	44	----> set -q fish_prompt_pwd_dir_length
52	52	----> set -l fish_prompt_pwd_dir_length 1
68	68	----> set realhome ~
170	272	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
102	102	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
16	256	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
106	106	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
134	134	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
28	39266	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
180	15761	--> set -l repo_type (_repo_type)
39	15581	---> _repo_type
30	15542	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
30	298	-----> _is_hg_repo
94	268	------> fish_print_hg_root >/dev/null
7	174	-------> if not command -sq hg
        return 1
    ...
139	139	--------> not command -sq hg
28	28	--------> return 1
50	15075	-----> _is_git_repo
103	1769	------> type -q git
27	27	-------> set -q argv[1]
46	46	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
74	74	-------> argparse -n type -x t,p,P $options -- $argv
3	45	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
42	42	--------> set -q _flag_help
25	25	-------> set -l res 1
25	25	-------> set -l mode normal
25	25	-------> set -l multi no
25	25	-------> set -l selection all
25	25	-------> set -l short no
7	53	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
22	22	--------> set -q _flag_quiet
24	24	--------> set mode quiet
22	22	-------> set -q _flag_all
21	21	-------> set -q _flag_short
21	21	-------> set -q _flag_no_functions
74	1206	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
31	31	--------> set -l found 0
37	565	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
50	50	---------> test $selection != files
4	112	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
108	108	----------> functions -q -- $i
5	366	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
289	361	----------> contains -- $i (builtin -n)
72	72	-----------> builtin -n
31	31	--------> set -l paths
9	309	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
27	27	---------> test $multi != yes
166	273	---------> set paths (command -s -- $i)
107	107	----------> command -s -- $i
36	168	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
42	42	---------> set res 0
26	26	---------> set found 1
9	9	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	55	---------> if test $multi != yes
                continue
            ...
26	26	----------> test $multi != yes
21	21	----------> continue
3	28	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
25	25	---------> test $found = 0
26	26	-------> return $res
13256	13256	------> git rev-parse --git-dir >/dev/null 2>&1
113	113	-----> echo 'git'
26	26	-----> return 0
185	11830	--> set -l repo_branch $red(_repo_branch_name $repo_type)
74	11645	---> _repo_branch_name $repo_type
46	11571	----> _$argv[1]_branch_name
183	11252	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
11069	11069	------> git symbolic-ref --quiet HEAD 2>/dev/null
11	273	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
33	33	------> set -q branch[1]
157	229	------> echo (string replace -r '^refs/heads/' '' $branch)
72	72	-------> string replace -r '^refs/heads/' '' $branch
50	50	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
7	11597	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
153	11590	---> [ (_is_repo_dirty $repo_type) ]
43	11437	----> _is_repo_dirty $repo_type
37	11394	-----> _is_$argv[1]_dirty
171	11357	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11186	11186	-------> git status -s --ignore-submodules=dirty 2>/dev/null
70	70	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
73	2306	> fish_right_prompt
106	106	-> set_color $fish_color_autosuggestion 2> /dev/null
2054	2054	-> date "+%H:%M:%S"
73	73	-> set_color normal
41	373	> fish_title
12	332	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
177	290	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
41	82	---> __fish_pwd
41	41	----> pwd
181	691	> up-or-search
9	105	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
96	96	--> commandline --search-mode
4	50	-> if commandline --paging-mode
        commandline -f up-line
        return
    ...
46	46	--> commandline --paging-mode
208	275	-> set lineno (commandline -L)
67	67	--> commandline -L
22	80	-> switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    ...
58	58	--> commandline -f history-search-backward
81	202	> up-or-search
15	121	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
46	46	--> commandline --search-mode
37	37	--> commandline -f history-search-backward
23	23	--> return
86	222	> down-or-search
19	136	-> if commandline --search-mode
        commandline -f history-search-forward
        return
    ...
52	52	--> commandline --search-mode
40	40	--> commandline -f history-search-forward
25	25	--> return
78	196	> down-or-search
16	118	-> if commandline --search-mode
        commandline -f history-search-forward
        return
    ...
45	45	--> commandline --search-mode
35	35	--> commandline -f history-search-forward
22	22	--> return
214	500	> __fish_cancel_commandline
54	54	-> commandline -f cancel
107	151	-> set -l cmd (commandline)
44	44	--> commandline
5	40	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
35	35	--> test -n "$cmd"
41	41	-> commandline -f repaint
44	173	> fish_mode_prompt
45	129	-> fish_default_mode_prompt
8	84	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
41	41	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
35	35	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
121	39371	> fish_prompt
45	45	-> set -l __last_command_exit_status $status
5	36	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
119	178	-> set -l cyan (set_color -o cyan)
59	59	--> set_color -o cyan
102	153	-> set -l yellow (set_color -o yellow)
51	51	--> set_color -o yellow
143	191	-> set -l red (set_color -o red)
48	48	--> set_color -o red
115	177	-> set -l green (set_color -o green)
62	62	--> set_color -o green
103	154	-> set -l blue (set_color -o blue)
51	51	--> set_color -o blue
101	148	-> set -l normal (set_color normal)
47	47	--> set_color normal
38	38	-> set -l arrow_color "$green"
4	38	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
34	34	--> test $__last_command_exit_status != 0
37	37	-> set -l arrow "$arrow_color➜ "
6	55	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
49	49	--> test "$USER" = 'root'
250	2852	-> set -l cwd $cyan(basename (prompt_pwd))
1844	2602	--> basename (prompt_pwd)
94	758	---> prompt_pwd
38	38	----> set -l options 'h/help'
48	48	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	33	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
29	29	-----> set -q _flag_help
28	28	----> set -q fish_prompt_pwd_dir_length
31	31	----> set -l fish_prompt_pwd_dir_length 1
38	38	----> set realhome ~
227	299	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
72	72	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
12	149	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
37	37	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
100	100	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
27	35079	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
131	11760	--> set -l repo_type (_repo_type)
32	11629	---> _repo_type
18	11597	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	300	-----> _is_hg_repo
83	274	------> fish_print_hg_root >/dev/null
11	191	-------> if not command -sq hg
        return 1
    ...
148	148	--------> not command -sq hg
32	32	--------> return 1
53	11184	-----> _is_git_repo
91	1745	------> type -q git
28	28	-------> set -q argv[1]
61	61	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
72	72	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
27	27	-------> set -l selection all
27	27	-------> set -l short no
9	64	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
25	25	--------> set -q _flag_quiet
30	30	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
33	1165	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
27	27	--------> set -l found 0
22	521	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
44	44	---------> test $selection != files
4	60	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
56	56	----------> functions -q -- $i
6	395	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
310	389	----------> contains -- $i (builtin -n)
79	79	-----------> builtin -n
52	52	--------> set -l paths
10	347	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
31	31	---------> test $multi != yes
137	306	---------> set paths (command -s -- $i)
169	169	----------> command -s -- $i
24	154	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
28	28	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	59	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
22	22	----------> continue
4	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
28	28	-------> return $res
9386	9386	------> git rev-parse --git-dir >/dev/null 2>&1
69	69	-----> echo 'git'
26	26	-----> return 0
161	11150	--> set -l repo_branch $red(_repo_branch_name $repo_type)
44	10989	---> _repo_branch_name $repo_type
58	10945	----> _$argv[1]_branch_name
232	10503	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10271	10271	------> git symbolic-ref --quiet HEAD 2>/dev/null
13	384	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
84	84	------> set -q branch[1]
199	287	------> echo (string replace -r '^refs/heads/' '' $branch)
88	88	-------> string replace -r '^refs/heads/' '' $branch
96	96	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
7	12046	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
146	12039	---> [ (_is_repo_dirty $repo_type) ]
79	11893	----> _is_repo_dirty $repo_type
53	11814	-----> _is_$argv[1]_dirty
213	11761	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11548	11548	-------> git status -s --ignore-submodules=dirty 2>/dev/null
69	69	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
73	2038	> fish_right_prompt
97	97	-> set_color $fish_color_autosuggestion 2> /dev/null
1804	1804	-> date "+%H:%M:%S"
64	64	-> set_color normal
41	350	> fish_title
8	309	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
159	271	--> echo (status current-command) (__fish_pwd)
31	31	---> status current-command
43	81	---> __fish_pwd
38	38	----> pwd
170	545	> up-or-search
9	75	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
66	66	--> commandline --search-mode
5	51	-> if commandline --paging-mode
        commandline -f up-line
        return
    ...
46	46	--> commandline --paging-mode
130	185	-> set lineno (commandline -L)
55	55	--> commandline -L
17	64	-> switch $lineno
        case 1
            commandline -f history-search-backward

        case '*'
            commandline -f up-line
    ...
47	47	--> commandline -f history-search-backward
95	243	> up-or-search
19	148	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
53	53	--> commandline --search-mode
50	50	--> commandline -f history-search-backward
26	26	--> return
130	278	> up-or-search
18	148	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
63	63	--> commandline --search-mode
41	41	--> commandline -f history-search-backward
26	26	--> return
91	225	> down-or-search
17	134	-> if commandline --search-mode
        commandline -f history-search-forward
        return
    ...
50	50	--> commandline --search-mode
43	43	--> commandline -f history-search-forward
24	24	--> return
92	243	> up-or-search
20	151	-> if commandline --search-mode
        commandline -f history-search-backward
        return
    ...
64	64	--> commandline --search-mode
41	41	--> commandline -f history-search-backward
26	26	--> return
93	233	> down-or-search
19	140	-> if commandline --search-mode
        commandline -f history-search-forward
        return
    ...
54	54	--> commandline --search-mode
42	42	--> commandline -f history-search-forward
25	25	--> return
311	9021	> __fish_cancel_commandline
170	170	-> commandline -f cancel
131	182	-> set -l cmd (commandline)
51	51	--> commandline
42	8311	-> if test -n "$cmd"
        commandline -C 1000000
        if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        end
        if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        end
        for i in (seq (commandline -L))
            echo ""
        end
        commandline ""
        emit fish_cancel
    ...
36	36	--> test -n "$cmd"
77	77	--> commandline -C 1000000
11	599	--> if set -q fish_color_cancel
            echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
        else
            echo -ns "^C"
        ...
32	32	---> set -q fish_color_cancel
326	556	---> echo -ns (set_color $fish_color_cancel) "^C" (set_color normal)
178	178	----> set_color $fish_color_cancel
52	52	----> set_color normal
16	4224	--> if command -sq tput
            # Clear to EOL (to erase any autosuggestion).
            echo -n (tput el; or tput ce)
        ...
111	111	---> command -sq tput
267	4097	---> echo -n (tput el; or tput ce)
3830	3830	----> tput el
209	3073	--> for i in (seq (commandline -L))
            echo ""
        ...
2721	2786	---> seq (commandline -L)
65	65	----> commandline -L
78	78	---> echo ""
78	78	--> commandline ""
182	182	--> emit fish_cancel
47	47	-> commandline -f repaint
85	469	> fish_mode_prompt
286	384	-> fish_default_mode_prompt
9	98	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
55	55	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
34	34	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
172	46093	> fish_prompt
39	39	-> set -l __last_command_exit_status $status
4	33	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
29	29	--> not set -q -g __fish_robbyrussell_functions_defined
136	197	-> set -l cyan (set_color -o cyan)
61	61	--> set_color -o cyan
110	156	-> set -l yellow (set_color -o yellow)
46	46	--> set_color -o yellow
107	152	-> set -l red (set_color -o red)
45	45	--> set_color -o red
163	235	-> set -l green (set_color -o green)
72	72	--> set_color -o green
133	208	-> set -l blue (set_color -o blue)
75	75	--> set_color -o blue
142	198	-> set -l normal (set_color normal)
56	56	--> set_color normal
45	45	-> set -l arrow_color "$green"
7	58	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
51	51	--> test $__last_command_exit_status != 0
109	109	-> set -l arrow "$arrow_color➜ "
6	77	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
71	71	--> test "$USER" = 'root'
253	3127	-> set -l cwd $cyan(basename (prompt_pwd))
1994	2874	--> basename (prompt_pwd)
271	880	---> prompt_pwd
43	43	----> set -l options 'h/help'
42	42	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
28	28	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
112	304	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
192	192	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	103	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
33	33	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
60	60	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
22	41224	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
212	19348	--> set -l repo_type (_repo_type)
51	19136	---> _repo_type
25	19085	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
57	595	-----> _is_hg_repo
287	538	------> fish_print_hg_root >/dev/null
13	251	-------> if not command -sq hg
        return 1
    ...
201	201	--------> not command -sq hg
37	37	--------> return 1
96	18216	-----> _is_git_repo
443	2562	------> type -q git
49	49	-------> set -q argv[1]
57	57	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
67	67	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
26	26	-------> set -l multi no
39	39	-------> set -l selection all
35	35	-------> set -l short no
13	102	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
45	45	--------> set -q _flag_quiet
44	44	--------> set mode quiet
25	25	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
38	1564	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
46	46	--------> set -l found 0
19	886	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
4	307	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
303	303	----------> functions -q -- $i
6	528	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
448	522	----------> contains -- $i (builtin -n)
74	74	-----------> builtin -n
33	33	--------> set -l paths
31	363	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
182	302	---------> set paths (command -s -- $i)
120	120	----------> command -s -- $i
27	168	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
32	32	---------> set res 0
27	27	---------> set found 1
11	11	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	71	---------> if test $multi != yes
                continue
            ...
42	42	----------> test $multi != yes
23	23	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
28	28	-------> return $res
15558	15558	------> git rev-parse --git-dir >/dev/null 2>&1
128	128	-----> echo 'git'
121	121	-----> return 0
157	10554	--> set -l repo_branch $red(_repo_branch_name $repo_type)
59	10397	---> _repo_branch_name $repo_type
35	10338	----> _$argv[1]_branch_name
158	10073	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9915	9915	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	230	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
121	190	------> echo (string replace -r '^refs/heads/' '' $branch)
69	69	-------> string replace -r '^refs/heads/' '' $branch
50	50	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
4	11250	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
102	11246	---> [ (_is_repo_dirty $repo_type) ]
48	11144	----> _is_repo_dirty $repo_type
37	11096	-----> _is_$argv[1]_dirty
164	11059	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10895	10895	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
163	2196	> fish_right_prompt
87	87	-> set_color $fish_color_autosuggestion 2> /dev/null
1881	1881	-> date "+%H:%M:%S"
65	65	-> set_color normal
41	582	> fish_title
10	541	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
163	501	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
157	306	---> __fish_pwd
149	149	----> pwd
68	286	> __fish_disable_bracketed_paste clear
218	218	-> printf "\e[?2004l"
50	386	> fish_title clear
10	336	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
177	297	--> echo (status current-command) (__fish_pwd)
35	35	---> status current-command
44	85	---> __fish_pwd
41	41	----> pwd
4364	4364	> clear
43	99	> __fish_enable_bracketed_paste
56	56	-> printf "\e[?2004h"
42	168	> fish_mode_prompt
43	126	-> fish_default_mode_prompt
8	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
43	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
101	38845	> fish_prompt
37	37	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
106	166	-> set -l cyan (set_color -o cyan)
60	60	--> set_color -o cyan
118	167	-> set -l yellow (set_color -o yellow)
49	49	--> set_color -o yellow
118	175	-> set -l red (set_color -o red)
57	57	--> set_color -o red
94	142	-> set -l green (set_color -o green)
48	48	--> set_color -o green
103	197	-> set -l blue (set_color -o blue)
94	94	--> set_color -o blue
94	141	-> set -l normal (set_color normal)
47	47	--> set_color normal
35	35	-> set -l arrow_color "$green"
3	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
33	33	-> set -l arrow "$arrow_color➜ "
3	35	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
294	3256	-> set -l cwd $cyan(basename (prompt_pwd))
2422	2962	--> basename (prompt_pwd)
70	540	---> prompt_pwd
34	34	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	35	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
31	31	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
101	177	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
76	76	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	100	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
58	58	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
23	34233	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
180	12506	--> set -l repo_type (_repo_type)
63	12326	---> _repo_type
24	12263	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
45	515	-----> _is_hg_repo
126	470	------> fish_print_hg_root >/dev/null
16	344	-------> if not command -sq hg
        return 1
    ...
280	280	--------> not command -sq hg
48	48	--------> return 1
69	11593	-----> _is_git_repo
137	1747	------> type -q git
43	43	-------> set -q argv[1]
53	53	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
114	114	-------> argparse -n type -x t,p,P $options -- $argv
5	47	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
42	42	--------> set -q _flag_help
30	30	-------> set -l res 1
27	27	-------> set -l mode normal
27	27	-------> set -l multi no
28	28	-------> set -l selection all
29	29	-------> set -l short no
13	85	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
37	37	--------> set -q _flag_quiet
35	35	--------> set mode quiet
38	38	-------> set -q _flag_all
24	24	-------> set -q _flag_short
24	24	-------> set -q _flag_no_functions
41	1014	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
43	43	--------> set -l found 0
22	393	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
47	47	---------> test $selection != files
4	60	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
56	56	----------> functions -q -- $i
5	264	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
196	259	----------> contains -- $i (builtin -n)
63	63	-----------> builtin -n
30	30	--------> set -l paths
9	325	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
37	37	---------> test $multi != yes
133	279	---------> set paths (command -s -- $i)
146	146	----------> command -s -- $i
24	151	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
27	27	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
9	61	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
23	23	----------> continue
5	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
27	27	-------> return $res
9777	9777	------> git rev-parse --git-dir >/dev/null 2>&1
103	103	-----> echo 'git'
28	28	-----> return 0
105	9843	--> set -l repo_branch $red(_repo_branch_name $repo_type)
45	9738	---> _repo_branch_name $repo_type
38	9693	----> _$argv[1]_branch_name
150	9425	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9275	9275	------> git symbolic-ref --quiet HEAD 2>/dev/null
10	230	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
119	188	------> echo (string replace -r '^refs/heads/' '' $branch)
69	69	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	11818	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
94	11813	---> [ (_is_repo_dirty $repo_type) ]
38	11719	----> _is_repo_dirty $repo_type
34	11681	-----> _is_$argv[1]_dirty
145	11647	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11502	11502	-------> git status -s --ignore-submodules=dirty 2>/dev/null
62	62	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
67	1989	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
1764	1764	-> date "+%H:%M:%S"
70	70	-> set_color normal
41	357	> fish_title
9	316	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
29	29	--> not set -q INSIDE_EMACS
166	278	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
43	80	---> __fish_pwd
37	37	----> pwd
80	450	> __fish_disable_bracketed_paste 'nvim ~/dotfiles/nvim/init.vim'
370	370	-> printf "\e[?2004l"
64	918	> fish_title nvim\ ~/dotfiles/nvim/init.vim
14	854	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
39	39	--> not set -q INSIDE_EMACS
409	801	--> echo (status current-command) (__fish_pwd)
44	44	---> status current-command
191	348	---> __fish_pwd
157	157	----> pwd
28031503	28031503	> nvim ~/dotfiles/nvim/init.vim
46	217	> __fish_enable_bracketed_paste
171	171	-> printf "\e[?2004h"
46	292	> fish_mode_prompt
163	246	-> fish_default_mode_prompt
9	83	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
43	43	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
31	31	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
97	38504	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	31	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
27	27	--> not set -q -g __fish_robbyrussell_functions_defined
177	473	-> set -l cyan (set_color -o cyan)
296	296	--> set_color -o cyan
110	159	-> set -l yellow (set_color -o yellow)
49	49	--> set_color -o yellow
96	140	-> set -l red (set_color -o red)
44	44	--> set_color -o red
102	146	-> set -l green (set_color -o green)
44	44	--> set_color -o green
188	231	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
137	187	-> set -l normal (set_color normal)
50	50	--> set_color normal
41	41	-> set -l arrow_color "$green"
5	36	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
31	31	--> test $__last_command_exit_status != 0
35	35	-> set -l arrow "$arrow_color➜ "
4	36	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
32	32	--> test "$USER" = 'root'
142	2481	-> set -l cwd $cyan(basename (prompt_pwd))
1518	2339	--> basename (prompt_pwd)
187	821	---> prompt_pwd
35	35	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
109	342	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
233	233	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	101	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
60	60	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
16	34311	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
112	13903	--> set -l repo_type (_repo_type)
32	13791	---> _repo_type
16	13759	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
25	435	-----> _is_hg_repo
245	410	------> fish_print_hg_root >/dev/null
10	165	-------> if not command -sq hg
        return 1
    ...
127	127	--------> not command -sq hg
28	28	--------> return 1
47	13087	-----> _is_git_repo
241	2070	------> type -q git
30	30	-------> set -q argv[1]
50	50	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
66	66	-------> argparse -n type -x t,p,P $options -- $argv
3	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
27	27	-------> set -l res 1
26	26	-------> set -l mode normal
29	29	-------> set -l multi no
32	32	-------> set -l selection all
26	26	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
35	1359	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
22	767	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
6	339	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
333	333	----------> functions -q -- $i
5	376	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
306	371	----------> contains -- $i (builtin -n)
65	65	-----------> builtin -n
32	32	--------> set -l paths
11	303	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
30	30	---------> test $multi != yes
144	262	---------> set paths (command -s -- $i)
118	118	----------> command -s -- $i
30	162	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
34	34	---------> set res 0
28	28	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
8	60	---------> if test $multi != yes
                continue
            ...
29	29	----------> test $multi != yes
23	23	----------> continue
3	31	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
28	28	---------> test $found = 0
28	28	-------> return $res
10970	10970	------> git rev-parse --git-dir >/dev/null 2>&1
194	194	-----> echo 'git'
27	27	-----> return 0
110	9536	--> set -l repo_branch $red(_repo_branch_name $repo_type)
44	9426	---> _repo_branch_name $repo_type
36	9382	----> _$argv[1]_branch_name
135	9086	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
8951	8951	------> git symbolic-ref --quiet HEAD 2>/dev/null
12	260	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
52	52	------> set -q branch[1]
122	196	------> echo (string replace -r '^refs/heads/' '' $branch)
74	74	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	10813	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
126	10808	---> [ (_is_repo_dirty $repo_type) ]
39	10682	----> _is_repo_dirty $repo_type
35	10643	-----> _is_$argv[1]_dirty
193	10608	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10415	10415	-------> git status -s --ignore-submodules=dirty 2>/dev/null
64	64	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
67	2331	> fish_right_prompt
90	90	-> set_color $fish_color_autosuggestion 2> /dev/null
2098	2098	-> date "+%H:%M:%S"
76	76	-> set_color normal
46	678	> fish_title
11	632	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
231	590	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
172	325	---> __fish_pwd
153	153	----> pwd
44	96	> __fish_disable_bracketed_paste vimtutor
52	52	-> printf "\e[?2004l"
58	521	> fish_title vimtutor
14	463	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
45	45	--> not set -q INSIDE_EMACS
252	404	--> echo (status current-command) (__fish_pwd)
64	64	---> status current-command
47	88	---> __fish_pwd
41	41	----> pwd
21424652	21424652	> vimtutor
51	224	> __fish_enable_bracketed_paste
173	173	-> printf "\e[?2004h"
47	294	> fish_mode_prompt
161	247	-> fish_default_mode_prompt
8	86	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
46	46	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
32	32	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
98	45561	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	32	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
28	28	--> not set -q -g __fish_robbyrussell_functions_defined
93	263	-> set -l cyan (set_color -o cyan)
170	170	--> set_color -o cyan
96	142	-> set -l yellow (set_color -o yellow)
46	46	--> set_color -o yellow
162	234	-> set -l red (set_color -o red)
72	72	--> set_color -o red
139	200	-> set -l green (set_color -o green)
61	61	--> set_color -o green
105	153	-> set -l blue (set_color -o blue)
48	48	--> set_color -o blue
95	138	-> set -l normal (set_color normal)
43	43	--> set_color normal
39	39	-> set -l arrow_color "$green"
4	40	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
36	36	--> test $__last_command_exit_status != 0
39	39	-> set -l arrow "$arrow_color➜ "
4	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
131	2991	-> set -l cwd $cyan(basename (prompt_pwd))
1947	2860	--> basename (prompt_pwd)
202	913	---> prompt_pwd
36	36	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
6	32	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
104	411	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
307	307	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	108	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
35	35	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
65	65	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
20	41053	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
142	18024	--> set -l repo_type (_repo_type)
52	17882	---> _repo_type
16	17830	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
30	484	-----> _is_hg_repo
287	454	------> fish_print_hg_root >/dev/null
11	167	-------> if not command -sq hg
        return 1
    ...
129	129	--------> not command -sq hg
27	27	--------> return 1
46	17088	-----> _is_git_repo
214	2060	------> type -q git
28	28	-------> set -q argv[1]
46	46	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
69	69	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
27	27	-------> set -l multi no
79	79	-------> set -l selection all
43	43	-------> set -l short no
9	63	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
26	26	--------> set -q _flag_quiet
28	28	--------> set mode quiet
24	24	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
66	1312	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
30	30	--------> set -l found 0
19	703	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
5	279	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
274	274	----------> functions -q -- $i
5	375	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
316	370	----------> contains -- $i (builtin -n)
54	54	-----------> builtin -n
49	49	--------> set -l paths
10	279	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
36	36	---------> test $multi != yes
105	233	---------> set paths (command -s -- $i)
128	128	----------> command -s -- $i
24	152	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
30	30	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	58	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
23	23	----------> continue
4	33	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
29	29	---------> test $found = 0
28	28	-------> return $res
14982	14982	------> git rev-parse --git-dir >/dev/null 2>&1
213	213	-----> echo 'git'
29	29	-----> return 0
119	10692	--> set -l repo_branch $red(_repo_branch_name $repo_type)
51	10573	---> _repo_branch_name $repo_type
41	10522	----> _$argv[1]_branch_name
141	10258	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10117	10117	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	223	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
116	182	------> echo (string replace -r '^refs/heads/' '' $branch)
66	66	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
5	12274	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
135	12269	---> [ (_is_repo_dirty $repo_type) ]
66	12134	----> _is_repo_dirty $repo_type
40	12068	-----> _is_$argv[1]_dirty
149	12028	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11879	11879	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
68	2324	> fish_right_prompt
88	88	-> set_color $fish_color_autosuggestion 2> /dev/null
2095	2095	-> date "+%H:%M:%S"
73	73	-> set_color normal
44	589	> fish_title
10	545	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
169	504	--> echo (status current-command) (__fish_pwd)
33	33	---> status current-command
163	302	---> __fish_pwd
139	139	----> pwd
47	105	> __fish_disable_bracketed_paste clear
58	58	-> printf "\e[?2004l"
53	491	> fish_title clear
13	438	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
34	34	--> not set -q INSIDE_EMACS
242	391	--> echo (status current-command) (__fish_pwd)
37	37	---> status current-command
66	112	---> __fish_pwd
46	46	----> pwd
3313	3313	> clear
48	112	> __fish_enable_bracketed_paste
64	64	-> printf "\e[?2004h"
46	190	> fish_mode_prompt
52	144	-> fish_default_mode_prompt
10	92	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
46	46	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
36	36	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
103	39737	> fish_prompt
40	40	-> set -l __last_command_exit_status $status
4	35	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
110	172	-> set -l cyan (set_color -o cyan)
62	62	--> set_color -o cyan
99	148	-> set -l yellow (set_color -o yellow)
49	49	--> set_color -o yellow
97	148	-> set -l red (set_color -o red)
51	51	--> set_color -o red
97	144	-> set -l green (set_color -o green)
47	47	--> set_color -o green
112	159	-> set -l blue (set_color -o blue)
47	47	--> set_color -o blue
95	141	-> set -l normal (set_color normal)
46	46	--> set_color normal
37	37	-> set -l arrow_color "$green"
5	37	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
32	32	--> test $__last_command_exit_status != 0
36	36	-> set -l arrow "$arrow_color➜ "
4	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
110	2064	-> set -l cwd $cyan(basename (prompt_pwd))
1432	1954	--> basename (prompt_pwd)
67	522	---> prompt_pwd
37	37	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	29	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
25	25	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
95	169	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
74	74	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	97	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
57	57	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
44	36355	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
133	13571	--> set -l repo_type (_repo_type)
58	13438	---> _repo_type
21	13380	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
36	275	-----> _is_hg_repo
72	239	------> fish_print_hg_root >/dev/null
9	167	-------> if not command -sq hg
        return 1
    ...
130	130	--------> not command -sq hg
28	28	--------> return 1
45	12868	-----> _is_git_repo
190	2032	------> type -q git
33	33	-------> set -q argv[1]
50	50	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
91	91	-------> argparse -n type -x t,p,P $options -- $argv
4	31	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
27	27	--------> set -q _flag_help
27	27	-------> set -l res 1
27	27	-------> set -l mode normal
34	34	-------> set -l multi no
47	47	-------> set -l selection all
33	33	-------> set -l short no
9	59	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
24	24	--------> set -q _flag_quiet
26	26	--------> set mode quiet
25	25	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
51	1309	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
56	56	--------> set -l found 0
17	362	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
32	32	---------> test $selection != files
4	55	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
51	51	----------> functions -q -- $i
5	258	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
197	253	----------> contains -- $i (builtin -n)
56	56	-----------> builtin -n
45	45	--------> set -l paths
16	428	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
90	90	---------> test $multi != yes
162	322	---------> set paths (command -s -- $i)
160	160	----------> command -s -- $i
35	280	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
30	30	---------> set res 0
30	30	---------> set found 1
60	60	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
14	125	---------> if test $multi != yes
                continue
            ...
49	49	----------> test $multi != yes
62	62	----------> continue
28	87	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
59	59	---------> test $found = 0
30	30	-------> return $res
10791	10791	------> git rev-parse --git-dir >/dev/null 2>&1
123	123	-----> echo 'git'
93	93	-----> return 0
145	11379	--> set -l repo_branch $red(_repo_branch_name $repo_type)
92	11234	---> _repo_branch_name $repo_type
71	11142	----> _$argv[1]_branch_name
141	10852	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10711	10711	------> git symbolic-ref --quiet HEAD 2>/dev/null
8	219	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
31	31	------> set -q branch[1]
115	180	------> echo (string replace -r '^refs/heads/' '' $branch)
65	65	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
7	11318	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
135	11311	---> [ (_is_repo_dirty $repo_type) ]
43	11176	----> _is_repo_dirty $repo_type
35	11133	-----> _is_$argv[1]_dirty
180	11098	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
10918	10918	-------> git status -s --ignore-submodules=dirty 2>/dev/null
78	78	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
80	2275	> fish_right_prompt
96	96	-> set_color $fish_color_autosuggestion 2> /dev/null
2012	2012	-> date "+%H:%M:%S"
87	87	-> set_color normal
44	376	> fish_title
10	332	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
34	34	--> not set -q INSIDE_EMACS
172	288	--> echo (status current-command) (__fish_pwd)
36	36	---> status current-command
44	80	---> __fish_pwd
36	36	----> pwd
52	111	> __fish_disable_bracketed_paste clear
59	59	-> printf "\e[?2004l"
55	454	> fish_title clear
12	399	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
32	32	--> not set -q INSIDE_EMACS
223	355	--> echo (status current-command) (__fish_pwd)
36	36	---> status current-command
52	96	---> __fish_pwd
44	44	----> pwd
3079	3079	> clear
56	122	> __fish_enable_bracketed_paste
66	66	-> printf "\e[?2004h"
53	206	> fish_mode_prompt
56	153	-> fish_default_mode_prompt
10	97	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
49	49	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
38	38	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
119	38065	> fish_prompt
42	42	-> set -l __last_command_exit_status $status
5	36	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
31	31	--> not set -q -g __fish_robbyrussell_functions_defined
121	188	-> set -l cyan (set_color -o cyan)
67	67	--> set_color -o cyan
150	204	-> set -l yellow (set_color -o yellow)
54	54	--> set_color -o yellow
173	224	-> set -l red (set_color -o red)
51	51	--> set_color -o red
196	280	-> set -l green (set_color -o green)
84	84	--> set_color -o green
156	237	-> set -l blue (set_color -o blue)
81	81	--> set_color -o blue
188	238	-> set -l normal (set_color normal)
50	50	--> set_color normal
83	83	-> set -l arrow_color "$green"
15	79	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
64	64	--> test $__last_command_exit_status != 0
48	48	-> set -l arrow "$arrow_color➜ "
4	40	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
36	36	--> test "$USER" = 'root'
127	2182	-> set -l cwd $cyan(basename (prompt_pwd))
1526	2055	--> basename (prompt_pwd)
67	529	---> prompt_pwd
36	36	----> set -l options 'h/help'
40	40	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	31	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
27	27	-----> set -q _flag_help
24	24	----> set -q fish_prompt_pwd_dir_length
27	27	----> set -l fish_prompt_pwd_dir_length 1
33	33	----> set realhome ~
97	172	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
75	75	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
10	99	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
31	31	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
58	58	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
17	34002	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
114	11112	--> set -l repo_type (_repo_type)
34	10998	---> _repo_type
15	10964	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
26	270	-----> _is_hg_repo
73	244	------> fish_print_hg_root >/dev/null
8	171	-------> if not command -sq hg
        return 1
    ...
135	135	--------> not command -sq hg
28	28	--------> return 1
43	10585	-----> _is_git_repo
99	1442	------> type -q git
26	26	-------> set -q argv[1]
46	46	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
66	66	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
25	25	-------> set -l mode normal
26	26	-------> set -l multi no
27	27	-------> set -l selection all
25	25	-------> set -l short no
8	56	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
33	896	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
29	29	--------> set -l found 0
15	377	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
30	30	---------> test $selection != files
4	52	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
48	48	----------> functions -q -- $i
5	280	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
222	275	----------> contains -- $i (builtin -n)
53	53	-----------> builtin -n
32	32	--------> set -l paths
9	253	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
100	215	---------> set paths (command -s -- $i)
115	115	----------> command -s -- $i
21	142	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
28	28	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
6	57	---------> if test $multi != yes
                continue
            ...
28	28	----------> test $multi != yes
23	23	----------> continue
3	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
27	27	---------> test $found = 0
27	27	-------> return $res
9100	9100	------> git rev-parse --git-dir >/dev/null 2>&1
68	68	-----> echo 'git'
26	26	-----> return 0
204	11421	--> set -l repo_branch $red(_repo_branch_name $repo_type)
43	11217	---> _repo_branch_name $repo_type
41	11174	----> _$argv[1]_branch_name
199	10894	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
10695	10695	------> git symbolic-ref --quiet HEAD 2>/dev/null
9	239	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
34	34	------> set -q branch[1]
125	196	------> echo (string replace -r '^refs/heads/' '' $branch)
71	71	-------> string replace -r '^refs/heads/' '' $branch
50	50	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
4	11402	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
117	11398	---> [ (_is_repo_dirty $repo_type) ]
58	11281	----> _is_repo_dirty $repo_type
37	11223	-----> _is_$argv[1]_dirty
166	11186	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
11020	11020	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
63	1884	> fish_right_prompt
86	86	-> set_color $fish_color_autosuggestion 2> /dev/null
1675	1675	-> date "+%H:%M:%S"
60	60	-> set_color normal
41	348	> fish_title
8	307	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
158	269	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
43	79	---> __fish_pwd
36	36	----> pwd
953	8363	> __fish_winch_handler SIGWINCH
7410	7410	-> commandline -f repaint >/dev/null 2>/dev/null
28867	66130	> fish_mode_prompt
36688	37263	-> fish_default_mode_prompt
425	575	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-246	88	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
168	334	----> __fish_winch_handler SIGWINCH
166	166	-----> commandline -f repaint >/dev/null 2>/dev/null
62	62	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
27524	209744	> fish_prompt
124	124	-> set -l __last_command_exit_status $status
8	52	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
44	44	--> not set -q -g __fish_robbyrussell_functions_defined
17435	17829	-> set -l cyan (set_color -o cyan)
394	394	--> set_color -o cyan
6758	7033	-> set -l yellow (set_color -o yellow)
275	275	--> set_color -o yellow
239	324	-> set -l red (set_color -o red)
85	85	--> set_color -o red
1872	4540	-> set -l green (set_color -o green)
2668	2668	--> set_color -o green
8387	8575	-> set -l blue (set_color -o blue)
188	188	--> set_color -o blue
2460	2579	-> set -l normal (set_color normal)
119	119	--> set_color normal
96	96	-> set -l arrow_color "$green"
12	1122	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
1110	1110	--> test $__last_command_exit_status != 0
91	91	-> set -l arrow "$arrow_color➜ "
7	97	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
90	90	--> test "$USER" = 'root'
301	50438	-> set -l cwd $cyan(basename (prompt_pwd))
41028	50137	--> basename (prompt_pwd)
894	9109	---> prompt_pwd
150	150	----> set -l options 'h/help'
89	89	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
10	404	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
394	394	-----> set -q _flag_help
1214	1214	----> set -q fish_prompt_pwd_dir_length
54	54	----> set -l fish_prompt_pwd_dir_length 1
56	56	----> set realhome ~
233	821	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
588	588	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
18	5427	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
55	55	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
5354	5354	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
36	89242	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
178	44617	--> set -l repo_type (_repo_type)
85	44439	---> _repo_type
20	44354	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
43	846	-----> _is_hg_repo
445	803	------> fish_print_hg_root >/dev/null
21	358	-------> if not command -sq hg
        return 1
    ...
276	276	--------> not command -sq hg
61	61	--------> return 1
69	43149	-----> _is_git_repo
511	4396	------> type -q git
50	50	-------> set -q argv[1]
87	87	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
107	107	-------> argparse -n type -x t,p,P $options -- $argv
7	50	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
43	43	--------> set -q _flag_help
44	44	-------> set -l res 1
41	41	-------> set -l mode normal
44	44	-------> set -l multi no
115	115	-------> set -l selection all
42	42	-------> set -l short no
23	837	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
38	38	--------> set -q _flag_quiet
776	776	--------> set mode quiet
72	72	-------> set -q _flag_all
41	41	-------> set -q _flag_short
38	38	-------> set -q _flag_no_functions
53	2275	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
46	46	--------> set -l found 0
33	1440	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
48	48	---------> test $selection != files
10	707	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
697	697	----------> functions -q -- $i
8	652	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
530	644	----------> contains -- $i (builtin -n)
114	114	-----------> builtin -n
49	49	--------> set -l paths
14	412	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
46	46	---------> test $multi != yes
172	352	---------> set paths (command -s -- $i)
180	180	----------> command -s -- $i
33	227	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
44	44	---------> set res 0
42	42	---------> set found 1
15	15	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
11	93	---------> if test $multi != yes
                continue
            ...
45	45	----------> test $multi != yes
37	37	----------> continue
6	48	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
42	42	---------> test $found = 0
42	42	-------> return $res
38684	38684	------> git rev-parse --git-dir >/dev/null 2>&1
270	270	-----> echo 'git'
69	69	-----> return 0
170	17833	--> set -l repo_branch $red(_repo_branch_name $repo_type)
47	17663	---> _repo_branch_name $repo_type
38	17616	----> _$argv[1]_branch_name
276	17249	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
16973	16973	------> git symbolic-ref --quiet HEAD 2>/dev/null
11	329	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
45	45	------> set -q branch[1]
194	273	------> echo (string replace -r '^refs/heads/' '' $branch)
79	79	-------> string replace -r '^refs/heads/' '' $branch
45	45	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
12	26711	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
169	26699	---> [ (_is_repo_dirty $repo_type) ]
61	26530	----> _is_repo_dirty $repo_type
54	26469	-----> _is_$argv[1]_dirty
1230	26415	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
25185	25185	-------> git status -s --ignore-submodules=dirty 2>/dev/null
78	78	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
376	5578	> fish_right_prompt
94	94	-> set_color $fish_color_autosuggestion 2> /dev/null
5037	5037	-> date "+%H:%M:%S"
71	71	-> set_color normal
47	764	> fish_title
11	717	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
31	31	--> not set -q INSIDE_EMACS
232	675	--> echo (status current-command) (__fish_pwd)
34	34	---> status current-command
232	409	---> __fish_pwd
177	177	----> pwd
69	257	> __fish_winch_handler SIGWINCH
188	188	-> commandline -f repaint >/dev/null 2>/dev/null
61	208	> fish_mode_prompt
57	147	-> fish_default_mode_prompt
9	90	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
47	47	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
34	34	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
118	77887	> fish_prompt
36	36	-> set -l __last_command_exit_status $status
4	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
26	26	--> not set -q -g __fish_robbyrussell_functions_defined
97	159	-> set -l cyan (set_color -o cyan)
62	62	--> set_color -o cyan
90	137	-> set -l yellow (set_color -o yellow)
47	47	--> set_color -o yellow
88	131	-> set -l red (set_color -o red)
43	43	--> set_color -o red
89	132	-> set -l green (set_color -o green)
43	43	--> set_color -o green
86	129	-> set -l blue (set_color -o blue)
43	43	--> set_color -o blue
94	136	-> set -l normal (set_color normal)
42	42	--> set_color normal
34	34	-> set -l arrow_color "$green"
4	34	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
30	30	--> test $__last_command_exit_status != 0
32	32	-> set -l arrow "$arrow_color➜ "
2	32	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
30	30	--> test "$USER" = 'root'
124	2224	-> set -l cwd $cyan(basename (prompt_pwd))
1534	2100	--> basename (prompt_pwd)
63	566	---> prompt_pwd
33	33	----> set -l options 'h/help'
39	39	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	30	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
26	26	-----> set -q _flag_help
25	25	----> set -q fish_prompt_pwd_dir_length
28	28	----> set -l fish_prompt_pwd_dir_length 1
34	34	----> set realhome ~
125	217	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
92	92	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
9	97	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
32	32	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
56	56	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
36	74439	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
133	36724	--> set -l repo_type (_repo_type)
34	36591	---> _repo_type
19	36557	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
28	369	-----> _is_hg_repo
80	341	------> fish_print_hg_root >/dev/null
16	261	-------> if not command -sq hg
        return 1
    ...
205	205	--------> not command -sq hg
40	40	--------> return 1
59	36061	-----> _is_git_repo
268	3700	------> type -q git
27	27	-------> set -q argv[1]
47	47	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
64	64	-------> argparse -n type -x t,p,P $options -- $argv
4	30	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
26	26	--------> set -q _flag_help
26	26	-------> set -l res 1
26	26	-------> set -l mode normal
38	38	-------> set -l multi no
26	26	-------> set -l selection all
25	25	-------> set -l short no
9	57	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
25	25	--------> set mode quiet
24	24	-------> set -q _flag_all
23	23	-------> set -q _flag_short
23	23	-------> set -q _flag_no_functions
555	2941	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
32	32	--------> set -l found 0
413	1383	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
132	132	---------> test $selection != files
6	112	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
106	106	----------> functions -q -- $i
6	726	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
616	720	----------> contains -- $i (builtin -n)
104	104	-----------> builtin -n
49	49	--------> set -l paths
31	411	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
56	56	---------> test $multi != yes
147	324	---------> set paths (command -s -- $i)
177	177	----------> command -s -- $i
48	407	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
61	61	---------> set res 0
144	144	---------> set found 1
27	27	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
31	127	---------> if test $multi != yes
                continue
            ...
71	71	----------> test $multi != yes
25	25	----------> continue
9	104	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
95	95	---------> test $found = 0
55	55	-------> return $res
32302	32302	------> git rev-parse --git-dir >/dev/null 2>&1
82	82	-----> echo 'git'
26	26	-----> return 0
215	17290	--> set -l repo_branch $red(_repo_branch_name $repo_type)
43	17075	---> _repo_branch_name $repo_type
47	17032	----> _$argv[1]_branch_name
210	16551	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
16341	16341	------> git symbolic-ref --quiet HEAD 2>/dev/null
15	434	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
83	83	------> set -q branch[1]
194	336	------> echo (string replace -r '^refs/heads/' '' $branch)
142	142	-------> string replace -r '^refs/heads/' '' $branch
94	94	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
6	20295	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
100	20289	---> [ (_is_repo_dirty $repo_type) ]
47	20189	----> _is_repo_dirty $repo_type
35	20142	-----> _is_$argv[1]_dirty
220	20107	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
19887	19887	-------> git status -s --ignore-submodules=dirty 2>/dev/null
84	84	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
81	2049	> fish_right_prompt
90	90	-> set_color $fish_color_autosuggestion 2> /dev/null
1799	1799	-> date "+%H:%M:%S"
79	79	-> set_color normal
42	469	> fish_title
8	427	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
216	389	--> echo (status current-command) (__fish_pwd)
68	68	---> status current-command
59	105	---> __fish_pwd
46	46	----> pwd
74	196	> __fish_winch_handler SIGWINCH
122	122	-> commandline -f repaint >/dev/null 2>/dev/null
53	313	> fish_mode_prompt
47	260	-> fish_default_mode_prompt
139	213	--> if test "$fish_key_bindings" = "fish_vi_key_bindings"
        or test "$fish_key_bindings" = "fish_hybrid_key_bindings"
        switch $fish_bind_mode
            case default
                set_color --bold --background red white
                echo '[N]'
            case insert
                set_color --bold --background green white
                echo '[I]'
            case replace_one
                set_color --bold --background green white
                echo '[R]'
            case replace
                set_color --bold --background cyan white
                echo '[R]'
            case visual
                set_color --bold --background magenta white
                echo '[V]'
        end
        set_color normal
        echo -n ' '
    ...
-75	40	---> test "$fish_key_bindings" = "fish_vi_key_bindings"
26	115	----> __fish_winch_handler SIGWINCH
89	89	-----> commandline -f repaint >/dev/null 2>/dev/null
34	34	---> test "$fish_key_bindings" = "fish_hybrid_key_bindings"
122	36998	> fish_prompt
41	41	-> set -l __last_command_exit_status $status
4	30	-> if not set -q -g __fish_robbyrussell_functions_defined
        set -g __fish_robbyrussell_functions_defined
        function _git_branch_name
            set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
            if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            end
        end

        function _is_git_dirty
            echo (git status -s --ignore-submodules=dirty 2>/dev/null)
        end

        function _is_git_repo
            type -q git
            or return 1
            git rev-parse --git-dir >/dev/null 2>&1
        end

        function _hg_branch_name
            echo (hg branch 2>/dev/null)
        end

        function _is_hg_dirty
            echo (hg status -mard 2>/dev/null)
        end

        function _is_hg_repo
            fish_print_hg_root >/dev/null
        end

        function _repo_branch_name
            _$argv[1]_branch_name
        end

        function _is_repo_dirty
            _is_$argv[1]_dirty
        end

        function _repo_type
            if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            end
            return 1
        end
    ...
26	26	--> not set -q -g __fish_robbyrussell_functions_defined
176	245	-> set -l cyan (set_color -o cyan)
69	69	--> set_color -o cyan
139	224	-> set -l yellow (set_color -o yellow)
85	85	--> set_color -o yellow
189	242	-> set -l red (set_color -o red)
53	53	--> set_color -o red
175	240	-> set -l green (set_color -o green)
65	65	--> set_color -o green
174	241	-> set -l blue (set_color -o blue)
67	67	--> set_color -o blue
165	224	-> set -l normal (set_color normal)
59	59	--> set_color normal
35	35	-> set -l arrow_color "$green"
4	33	-> if test $__last_command_exit_status != 0
        set arrow_color "$red"
    ...
29	29	--> test $__last_command_exit_status != 0
32	32	-> set -l arrow "$arrow_color➜ "
3	32	-> if test "$USER" = 'root'
        set arrow "$arrow_color# "
    ...
29	29	--> test "$USER" = 'root'
197	2394	-> set -l cwd $cyan(basename (prompt_pwd))
1564	2197	--> basename (prompt_pwd)
81	633	---> prompt_pwd
31	31	----> set -l options 'h/help'
37	37	----> argparse -n prompt_pwd --max-args=0 $options -- $argv
4	28	----> if set -q _flag_help
        __fish_print_help prompt_pwd
        return 0
    ...
24	24	-----> set -q _flag_help
23	23	----> set -q fish_prompt_pwd_dir_length
26	26	----> set -l fish_prompt_pwd_dir_length 1
32	32	----> set realhome ~
183	273	----> set -l tmp (string replace -r '^'"$realhome"'($|/)' '~$1' $PWD)
90	90	-----> string replace -r '^'"$realhome"'($|/)' '~$1' $PWD
8	102	----> if [ $fish_prompt_pwd_dir_length -eq 0 ]
        echo $tmp
    else
        # Shorten to at most $fish_prompt_pwd_dir_length characters per directory
        string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
    ...
34	34	-----> [ $fish_prompt_pwd_dir_length -eq 0 ]
60	60	-----> string replace -ar '(\.?[^/]{'"$fish_prompt_pwd_dir_length"'})[^/]*/' '$1/' $tmp
29	32800	-> if set -l repo_type (_repo_type)
        set -l repo_branch $red(_repo_branch_name $repo_type)
        set repo_info "$blue $repo_type:($repo_branch$blue)"

        if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        end
    ...
141	12776	--> set -l repo_type (_repo_type)
31	12635	---> _repo_type
14	12604	----> if _is_hg_repo
                echo 'hg'
                return 0
            else if _is_git_repo
                echo 'git'
                return 0
            ...
40	284	-----> _is_hg_repo
82	244	------> fish_print_hg_root >/dev/null
8	162	-------> if not command -sq hg
        return 1
    ...
127	127	--------> not command -sq hg
27	27	--------> return 1
61	12202	-----> _is_git_repo
83	1527	------> type -q git
24	24	-------> set -q argv[1]
43	43	-------> set -l options 'h/help' 'a/all' 's/short' 'f/no-functions' 't/type' 'p/path' 'P/force-path' 'q/quiet'
60	60	-------> argparse -n type -x t,p,P $options -- $argv
4	29	-------> if set -q _flag_help
        __fish_print_help type
        return 0
    ...
25	25	--------> set -q _flag_help
25	25	-------> set -l res 1
24	24	-------> set -l mode normal
25	25	-------> set -l multi no
26	26	-------> set -l selection all
24	24	-------> set -l short no
7	54	-------> if set -q _flag_quiet
        set mode quiet
    else if set -q _flag_type
        set mode type
    else if set -q _flag_path
        set mode path
    else if set -q _flag_force_path
        set mode path
        set selection files
    ...
23	23	--------> set -q _flag_quiet
24	24	--------> set mode quiet
23	23	-------> set -q _flag_all
22	22	-------> set -q _flag_short
22	22	-------> set -q _flag_no_functions
28	1016	-------> for i in $argv
        # Found will be set to 1 if a match is found.
        set -l found 0

        if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        end

        set -l paths
        if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        end
        for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        end

        if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        end
    ...
26	26	--------> set -l found 0
12	423	--------> if test $selection != files
            if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            end

            if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            end
        ...
28	28	---------> test $selection != files
4	58	---------> if functions -q -- $i
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a function') $i
                        if test $short != yes
                            echo (_ ' with definition')
                            functions $i
                        else
                            set -l func_path (functions --details $i)
                            if not contains -- $func_path - stdin
                                printf (_ ' (defined in %s)') $func_path
                            end
                            echo
                        end
                    case type
                        echo (_ 'function')
                    case path
                        set -l func_path (functions --details $i)
                        switch $func_path
                            case "-"
                            case "n/a"
                            case "stdin"
                                break
                            case "*"
                                echo $func_path
                        end
                end
                if test $multi != yes
                    continue
                end
            ...
54	54	----------> functions -q -- $i
6	325	---------> if contains -- $i (builtin -n)
                set res 0
                set found 1
                switch $mode
                    case normal
                        printf (_ '%s is a builtin\n') $i

                    case type
                        echo (_ 'builtin')
                end
                if test $multi != yes
                    continue
                end
            ...
255	319	----------> contains -- $i (builtin -n)
64	64	-----------> builtin -n
31	31	--------> set -l paths
10	335	--------> if test $multi != yes
            set paths (command -s -- $i)
        else
            set paths (command -sa -- $i)
        ...
29	29	---------> test $multi != yes
169	296	---------> set paths (command -s -- $i)
127	127	----------> command -s -- $i
22	143	--------> for path in $paths
            set res 0
            set found 1
            switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            end
            if test $multi != yes
                continue
            end
        ...
29	29	---------> set res 0
26	26	---------> set found 1
10	10	---------> switch $mode
                case normal
                    printf (_ '%s is %s\n') $i $path
                case type
                    echo (_ 'file')
                case path
                    echo $path
            ...
7	56	---------> if test $multi != yes
                continue
            ...
27	27	----------> test $multi != yes
22	22	----------> continue
4	30	--------> if test $found = 0
            and test $mode != quiet
            and test $mode != path
            printf (_ "%s: Could not find '%s'\n") type $i >&2
        ...
26	26	---------> test $found = 0
27	27	-------> return $res
10614	10614	------> git rev-parse --git-dir >/dev/null 2>&1
79	79	-----> echo 'git'
25	25	-----> return 0
106	9700	--> set -l repo_branch $red(_repo_branch_name $repo_type)
40	9594	---> _repo_branch_name $repo_type
36	9554	----> _$argv[1]_branch_name
130	9299	-----> set -l branch (git symbolic-ref --quiet HEAD 2>/dev/null)
9169	9169	------> git symbolic-ref --quiet HEAD 2>/dev/null
8	219	-----> if set -q branch[1]
                echo (string replace -r '^refs/heads/' '' $branch)
            else
                echo (git rev-parse --short HEAD 2>/dev/null)
            ...
32	32	------> set -q branch[1]
116	179	------> echo (string replace -r '^refs/heads/' '' $branch)
63	63	-------> string replace -r '^refs/heads/' '' $branch
43	43	--> set repo_info "$blue $repo_type:($repo_branch$blue)"
4	10252	--> if [ (_is_repo_dirty $repo_type) ]
            set -l dirty "$yellow ✗"
            set repo_info "$repo_info$dirty"
        ...
91	10248	---> [ (_is_repo_dirty $repo_type) ]
39	10157	----> _is_repo_dirty $repo_type
35	10118	-----> _is_$argv[1]_dirty
133	10083	------> echo (git status -s --ignore-submodules=dirty 2>/dev/null)
9950	9950	-------> git status -s --ignore-submodules=dirty 2>/dev/null
63	63	-> echo -n -s $arrow ' '$cwd $repo_info $normal ' '
60	1915	> fish_right_prompt
85	85	-> set_color $fish_color_autosuggestion 2> /dev/null
1711	1711	-> date "+%H:%M:%S"
59	59	-> set_color normal
40	345	> fish_title
8	305	-> if not set -q INSIDE_EMACS
        echo (status current-command) (__fish_pwd)
    ...
30	30	--> not set -q INSIDE_EMACS
154	267	--> echo (status current-command) (__fish_pwd)
32	32	---> status current-command
43	81	---> __fish_pwd
38	38	----> pwd
